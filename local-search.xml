<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>BUAA_OS_lab3</title>
    <link href="/2024/04/05/BUAA-OS-lab3/"/>
    <url>/2024/04/05/BUAA-OS-lab3/</url>
    
    <content type="html"><![CDATA[<h1 id="BUAA-OS-lab3学习日记"><a href="#BUAA-OS-lab3学习日记" class="headerlink" title="BUAA_OS_lab3学习日记"></a>BUAA_OS_lab3学习日记</h1><h2 id="Thinking思考题"><a href="#Thinking思考题" class="headerlink" title="Thinking思考题"></a>Thinking思考题</h2><h3 id="Thinking-3-1"><a href="#Thinking-3-1" class="headerlink" title="Thinking 3.1"></a>Thinking 3.1</h3><p>问：请结合 MOS 中的页目录自映射应用解释代码中 e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_V 的含义。 </p><p>答：</p><p>UVPT：用户页表的起始处的内核虚拟地址</p><p>PDX(UVPT)：UVPT所处的页目录号（即 UVPT 处于第 PDX(UVPT) 个页目录项所映射的4MB空间。PDX获得的是这个虚拟地址的页目录号。</p><p>e-&gt;env_pgdir：进程 e 的页目录的内核虚拟地址</p><p>PADDR(e-&gt;env_pgdir)：进程 e 的页目录的物理地址</p><p>PADDR(e-&gt;env_pgdir) | PTE_V：页目录的物理基地址，加上权限位（只读权限）</p><p>自映射的意义即是我只需要知道二级页表的初始地址，我就能构造出页目录的初始地址以及指向页目录自身的PDE，这样，方便我们访问管理页表与页目录。</p><h3 id="Thinking-3-2"><a href="#Thinking-3-2" class="headerlink" title="Thinking 3.2"></a>Thinking 3.2</h3><p>问：elf_load_seg 以函数指针的形式，接受外部自定义的回调函数 map_page。 请你找到与之相关的 data 这一参数在此处的来源，并思考它的作用。没有这个参数可不可 以？为什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">elf_load_seg</span><span class="hljs-params">(Elf32_Phdr *ph, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *bin, <span class="hljs-type">elf_mapper_t</span> map_page, <span class="hljs-type">void</span> *data)</span>;<br></code></pre></td></tr></table></figure><p>data 是传入的进程控制块指针，在 load_icode_mapper 和 load_icode 函数中被调用，在 load_icode 函数中 data 被赋予进程控制块的指针 e。</p><p>作用：在增加虚拟地址到物理地址映射的时候提供env_pgdir和env_asid；如果没有data，load_icode_mapper就不能知道当前进程空间的页目录基地址和asid，所以必须要有这个参数。</p><h3 id="Thinking-3-3"><a href="#Thinking-3-3" class="headerlink" title="Thinking 3.3"></a>Thinking 3.3</h3><p>问：结合 elf_load_seg 的参数和实现，考虑该函数需要处理哪些页面加载的情 况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">elf_load_seg</span><span class="hljs-params">(Elf32_Phdr *ph, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *bin, <span class="hljs-type">elf_mapper_t</span> map_page, <span class="hljs-type">void</span> *data)</span> &#123;<br>u_long va = ph-&gt;p_vaddr;<br><span class="hljs-type">size_t</span> bin_size = ph-&gt;p_filesz;<br><span class="hljs-type">size_t</span> sgsize = ph-&gt;p_memsz;<br>u_int perm = PTE_V;<br><span class="hljs-keyword">if</span> (ph-&gt;p_flags &amp; PF_W) &#123;<br>perm |= PTE_D;<br>&#125;<br><br><span class="hljs-type">int</span> r;<br><span class="hljs-type">size_t</span> i;<br>u_long offset = va - ROUNDDOWN(va, PAGE_SIZE);<br><span class="hljs-keyword">if</span> (offset != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> ((r = map_page(data, va, offset, perm, bin,<br>  MIN(bin_size, PAGE_SIZE - offset))) != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> r;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/* Step 1: load all content of bin into memory. */</span><br><span class="hljs-keyword">for</span> (i = offset ? MIN(bin_size, PAGE_SIZE - offset) : <span class="hljs-number">0</span>; i &lt; bin_size; i += PAGE_SIZE) &#123;<br><span class="hljs-keyword">if</span> ((r = map_page(data, va + i, <span class="hljs-number">0</span>, perm, bin + i, MIN(bin_size - i, PAGE_SIZE))) !=<br>    <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> r;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/* Step 2: alloc pages to reach `sgsize` when `bin_size` &lt; `sgsize`. */</span><br><span class="hljs-keyword">while</span> (i &lt; sgsize) &#123;<br><span class="hljs-keyword">if</span> ((r = map_page(data, va + i, <span class="hljs-number">0</span>, perm, <span class="hljs-literal">NULL</span>, MIN(sgsize - i, PAGE_SIZE))) != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> r;<br>&#125;<br>i += PAGE_SIZE;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>函数判断va是否页对齐，如果不对齐，需要将多余的地址记为offset，我们将最开头不对齐的部分 “剪切” 下来，先映射到内存的页中。</li><li>将段内所有页映射到物理空间</li><li>最后我们处理段大小大于数据大小的情况。在这一部分，我们不断创建新的页，但是并不向其中加载任何内容。</li></ul><h3 id="Thinking-3-4"><a href="#Thinking-3-4" class="headerlink" title="Thinking 3.4"></a>Thinking 3.4</h3><p>根据上学期计组的知识，因为epc存储的是发生错误时CPU所处的指令地址，而对于CPU来说，在程序中引用访存的都应该是虚拟地址，因此env_tf.cp0_epc存储的是虚拟地址.</p><h3 id="Thinking-3-5"><a href="#Thinking-3-5" class="headerlink" title="Thinking 3.5"></a>Thinking 3.5</h3><p>备注： C 的拓展语法 [first … last] = value 来对数组某个区间上的 元素赋成同一个值</p><p>查找结果如下：</p><p>kern/genex.S:20:NESTED(handle_int, TF_SIZE, zero)<br>kern/genex.S:29:END(handle_int)</p><p>handle_int在genex.S文件中</p><p>handle_mod和handle_tlb，handle_sys藏得比较深，三者都是通过genex.S文件中的宏函数BUILD_HANDLER实现的，代码如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">BUILD_HANDLER </span>tlb do_tlb_refill<br><br><span class="hljs-comment">#if !defined(LAB) || LAB &gt;= 4</span><br><span class="hljs-keyword">BUILD_HANDLER </span>mod do_tlb_mod<br><span class="hljs-keyword">BUILD_HANDLER </span>sys do_syscall<br><span class="hljs-comment">#endif</span><br><br><span class="hljs-keyword">BUILD_HANDLER </span>reserved do_reserved<br></code></pre></td></tr></table></figure><h3 id="Exercise-3-1"><a href="#Exercise-3-1" class="headerlink" title="Exercise 3.1"></a>Exercise 3.1</h3><p>实现进程控制快的初始化功能，具体实现参考注释即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* Step 1: Initialize &#x27;env_free_list&#x27; with &#x27;LIST_INIT&#x27; and &#x27;env_sched_list&#x27; with</span><br><span class="hljs-comment"> * &#x27;TAILQ_INIT&#x27;. */</span><br><span class="hljs-comment">/* Exercise 3.1: Your code here. (1/2) */</span><br>LIST_INIT(&amp;env_free_list);<br>TAILQ_INIT(&amp;env_sched_list);<br><span class="hljs-comment">/* Step 2: Traverse the elements of &#x27;envs&#x27; array, set their status to &#x27;ENV_FREE&#x27; and insert</span><br><span class="hljs-comment"> * them into the &#x27;env_free_list&#x27;. Make sure, after the insertion, the order of envs in the</span><br><span class="hljs-comment"> * list should be the same as they are in the &#x27;envs&#x27; array. */</span><br><span class="hljs-keyword">for</span> (i = NENV - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>envs-&gt;env_status = ENV_FREE;<br>LIST_INSERT_HEAD(&amp;env_free_list,&amp;envs[i], env_link);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Exercise-3-2"><a href="#Exercise-3-2" class="headerlink" title="Exercise 3.2"></a>Exercise 3.2</h3><p>段地址的初始化使用 map_segment 函数在该页表中将内核数组 pages 和 envs 映射到了用户空间的 UPAGES 和 UENVS 处</p><p>map_segment功能是在一级页表基地址 pgdir 对应的两级页表结构中做段地址映射，将虚拟地 址段 [va,va+size) 映射到物理地址段 [pa,pa+size)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">page_insert(pgdir, asid, pa2page(pa + i), va + i, perm);<br></code></pre></td></tr></table></figure><h3 id="Exercise-3-3"><a href="#Exercise-3-3" class="headerlink" title="Exercise 3.3"></a>Exercise 3.3</h3><p>env_setup_vm函数：初始化新进程的地址空间</p><p>步骤如下：</p><ul><li>申请一块页表，并将页表转化为kernel地址赋值给e-&gt;env_pgdir</li><li>制了 <code>UTOP</code> 到 <code>UVPT</code> 的虚拟地址空间对应的页表项</li><li>我们将 <code>UVPT</code> 虚拟地址映射到页目录本身的物理地址，并设置只读权限。这样的话，页目录中的项所对应的，就不只是二级页表，还包含有一个一级页表，也就是页目录自身。这就是自映射。</li></ul><h3 id="Exercise-3-4"><a href="#Exercise-3-4" class="headerlink" title="Exercise 3.4"></a>Exercise 3.4</h3><p>步骤如下：</p><ul><li>获取从空进程块表中获取到一个进程块</li><li>初始化新进程的地址空间</li><li>将进程块的各属性赋值（env_user_tlb_mod_entry、env_runs、env_tf.cp0_status……），手工初始化进程控制块。</li><li>将该进程块从空进程块表移除</li></ul><h3 id="Exercise-3-5"><a href="#Exercise-3-5" class="headerlink" title="Exercise 3.5"></a>Exercise 3.5</h3><p>load_icode_mapper函数</p><p>需要分配所需的物理页面，并在页表中建立映射。若 src 非空，你还需要将该处的 ELF 数据拷贝到物理页面中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Step 1: Allocate a page with &#x27;page_alloc&#x27;. */</span><br><span class="hljs-comment">/* Exercise 3.5: Your code here. (1/2) */</span><br><span class="hljs-keyword">if</span> ((r = page_alloc(p)) != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> r;<br>&#125;<br><span class="hljs-comment">/* Step 2: If &#x27;src&#x27; is not NULL, copy the &#x27;len&#x27; bytes started at &#x27;src&#x27; into &#x27;offset&#x27; at this</span><br><span class="hljs-comment"> * page. */</span><br><span class="hljs-comment">// Hint: You may want to use &#x27;memcpy&#x27;.</span><br><span class="hljs-keyword">if</span> (src != <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-comment">/* Exercise 3.5: Your code here. (2/2) */</span><br><span class="hljs-built_in">memcpy</span>((<span class="hljs-type">void</span> *)(page2kva(p) + offset), src, len);<br>&#125;<br><br><span class="hljs-comment">/* Step 3: Insert &#x27;p&#x27; into &#x27;env-&gt;env_pgdir&#x27; at &#x27;va&#x27; with &#x27;perm&#x27;. */</span><br><span class="hljs-keyword">return</span> page_insert(env-&gt;env_pgdir, env-&gt;env_asid, p, va, perm);<br></code></pre></td></tr></table></figure><h3 id="Exercise-3-6"><a href="#Exercise-3-6" class="headerlink" title="Exercise 3.6"></a>Exercise 3.6</h3><p>步骤：</p><ul><li>elf_from做类型转化并检查是否为正确的ELF文件头</li><li>接下来使用ELF_FOREACH_PHDR_OFF遍历所有程序表头，在循环中，取出对应的程序头，如果其中的 <code>p_type</code> 类型为 <code>PT_LOAD</code>，说明其对应的程序需要被加载到内存中。我们调用 <code>elf_load_seg</code> 函数来进行加载</li><li>将进程控制块中 trap frame 的 epc cp0 寄存器的值设置为 ELF 文件中设定的程序入口地址</li></ul><h3 id="Exercise-3-7"><a href="#Exercise-3-7" class="headerlink" title="Exercise 3.7"></a>Exercise 3.7</h3><p>直接创建进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">struct</span> Env *<span class="hljs-title function_">env_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *binary, <span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> priority)</span> &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">e</span>;</span><br><span class="hljs-comment">/* Step 1: Use &#x27;env_alloc&#x27; to alloc a new env, with 0 as &#x27;parent_id&#x27;. */</span><br><span class="hljs-comment">/* Exercise 3.7: Your code here. (1/3) */</span><br>env_alloc(&amp;e, <span class="hljs-number">0</span>);<br><span class="hljs-comment">/* Step 2: Assign the &#x27;priority&#x27; to &#x27;e&#x27; and mark its &#x27;env_status&#x27; as runnable. */</span><br><span class="hljs-comment">/* Exercise 3.7: Your code here. (2/3) */</span><br>e-&gt;env_pri = priority;<br>e-&gt;env_status = ENV_RUNNABLE;<br><span class="hljs-comment">/* Step 3: Use &#x27;load_icode&#x27; to load the image from &#x27;binary&#x27;, and insert &#x27;e&#x27; into</span><br><span class="hljs-comment"> * &#x27;env_sched_list&#x27; using &#x27;TAILQ_INSERT_HEAD&#x27;. */</span><br><span class="hljs-comment">/* Exercise 3.7: Your code here. (3/3) */</span><br>load_icode(e, binary, size);<br>TAILQ_INSERT_HEAD(&amp;env_sched_list, e, env_sched_link);<br><span class="hljs-keyword">return</span> e;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Exercise-3-8"><a href="#Exercise-3-8" class="headerlink" title="Exercise 3.8"></a>Exercise 3.8</h3><ul><li>保存当前进程的上下文信息。 </li><li>切换 curenv 为即将运行的进程。</li><li>设置全局变量 cur_pgdir 为当前进程页目录地址，在 TLB 重填时将用到该全局变量。</li><li>调用 env_pop_tf 函数，恢复现场、异常返回。</li></ul><h3 id="Exercise-3-9"><a href="#Exercise-3-9" class="headerlink" title="Exercise 3.9"></a>Exercise 3.9</h3><p>完成异常分发代码</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">SAVE_ALL<br><span class="hljs-comment">#使用 SAVE_ALL 宏将当前上下文保存到内核的异常栈中。</span><br><span class="hljs-keyword">mfc0 </span>   <span class="hljs-built_in">t0</span>, CP0_STATUS<br><span class="hljs-keyword">and </span>    <span class="hljs-built_in">t0</span>, <span class="hljs-built_in">t0</span>, ~(STATUS_UM <span class="hljs-title">| STATUS_EXL |</span> STATUS_IE)<br><span class="hljs-keyword">mtc0 </span>   <span class="hljs-built_in">t0</span>, CP0_STATUS<br><span class="hljs-keyword">andi</span><span class="hljs-built_in">t0</span>, <span class="hljs-number">0x7c</span><br><span class="hljs-keyword">lw</span><span class="hljs-built_in">t0</span>, exception_handlers(<span class="hljs-built_in">t0</span>)<br><span class="hljs-keyword">jr</span><span class="hljs-built_in">t0</span><br></code></pre></td></tr></table></figure><h3 id="Exercise-3-10"><a href="#Exercise-3-10" class="headerlink" title="Exercise 3.10"></a>Exercise 3.10</h3><p>.text.exc_gen_entry 段和 .text.tlb_miss_entry 段需要被链接器放到特定的位置。</p><p>CPU 发生异常（除了用户态地址的 TLB Miss 异常）后，就会自动跳转 到地址 0x80000180 处；发生用户态地址的 TLB Miss 异常时，会自动跳转到地址 0x80000000 处。开始执行。</p><h3 id="Exercise-3-11"><a href="#Exercise-3-11" class="headerlink" title="Exercise 3.11"></a>Exercise 3.11</h3><p>时钟中断</p><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><h4 id="进程初始化与分配"><a href="#进程初始化与分配" class="headerlink" title="进程初始化与分配"></a>进程初始化与分配</h4><p>初始化：</p><p>map_segment 函数 $\rightarrow$ env_init 函数</p><p>分配</p><p>env_setup_vm函数：初始化新进程的地址空间 $\rightarrow$ env_alloc函数</p><h4 id="加载二进制镜像"><a href="#加载二进制镜像" class="headerlink" title="加载二进制镜像"></a>加载二进制镜像</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">load_icode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *binary, <span class="hljs-type">size_t</span> size)</span>; <br><span class="hljs-comment">//负责加载可执行文件 binary 到进程 e 的内存中。它调用的 elf_from 函数完成了解析 ELF 文件头的部分，elf_load_seg 负责将 ELF 文件的一个 segment 加载到内存。</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">load_icode_mapper</span><span class="hljs-params">(<span class="hljs-type">void</span> *data, u_long va, <span class="hljs-type">size_t</span> offset, u_int perm, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> len)</span><br><span class="hljs-comment">//成作为回调函数的 load_icode_mapper 函数，需要分配所需的物理页面，并在页表中建立映射。若 src 非空，需要将该处的 ELF 数据拷贝到物理页面中</span><br></code></pre></td></tr></table></figure><h4 id="进程创建与切换运行"><a href="#进程创建与切换运行" class="headerlink" title="进程创建与切换运行"></a>进程创建与切换运行</h4><p>创建：分配一个新的 Env 结构体，设置进程控制块，并将程序 载入到该进程的地址空间</p><p>进程切换的时候，为了保证下一次进入这个进程 的时候我们不会再“从头来过”，而是有记忆地从离开的地方继续往后走，我们要保存一些信息， 那么，需要保存什么信息呢？事实上，我们只需要保存进程的上下文信息，包括通用寄存器、HI、 LO 和 CP0 中的 Status，EPC，Cause 和 BadVAddr 寄存器。进程控制块除了 env_tf 其他的字 段在进程切换后还保留在原本的进程控制块中，并不会改变，因此不需要保存。（发生进程调度，或当陷入内 核时，会将当时的进程上下文环境保存在 env_tf 变量中（Trapframe结构体））</p><h4 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h4><p>时间片：比如设定某个进程的时间片的长度为 200 倍的 TIMER_INTERVAL（时钟中断间隔），那么当 MOS 记录到该进程的执行中发生了 200 个时钟中断 时，MOS 就知晓该进程的时间片结束了。</p>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA_OO_Unit2</title>
    <link href="/2024/03/29/BUAA-OO-Unit2/"/>
    <url>/2024/03/29/BUAA-OO-Unit2/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="BUAA-OO-Unit1第二单元总结"><a href="#BUAA-OO-Unit1第二单元总结" class="headerlink" title="BUAA_OO_Unit1第二单元总结"></a>BUAA_OO_Unit1第二单元总结</h1><h2 id="一、第一次作业"><a href="#一、第一次作业" class="headerlink" title="一、第一次作业"></a>一、第一次作业</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本次作业完成没有耗费多少时间，但由于对多线程的锁的了解不够深刻，将近花了两天时间来debug，中测也是交了五六次才通过。相比第一单元的作业，第二单元作业在代码复杂度，或者说代码量上存在明显下降，但是理解难度却有了更大的提升，以及由于加入了时间戳的原因，对于某些数据需要耗费大量时间在等待结果上。</p><h3 id="UML图架构"><a href="#UML图架构" class="headerlink" title="UML图架构"></a>UML图架构</h3><p><img src="UML2_1.png" alt="UML2_1"></p><p>本次作业中实现了三个线程类：<code>InputThread（输入线程）</code>，<code>Dispather（调度线程）</code>，<code>Elevator（电梯线程）</code></p><p>此外，<code>RequestTable</code>需求表类作为共享对象，所以内部方法全部加上<code>synchronized</code>关键字修饰，Strategy作为Elvator的附属类位电梯提供建议（按照作业提示，虽然本人觉得有点多余，但是确实代码理解起来简单）。</p><p>作业核心思路是<code>Inputread</code>读取到请求就加入到请求表中，接下来再由调度器将其分配加入各个电梯的分请求表中，当输入线程读取到EOF时电梯线程结束并将调度器Over标志设为true，当调度器的请求表为空且Over表示为true时调度器进程结束并将电梯进程Over标志设为true，对于某个电梯如果其分请求表为空且Over标志位为true时则电梯进程结束。</p><p>LOOK算法：电梯接收开门、沿着原方向运行一层、结束、等待、调转五种建议首先判断是否需要开门，如果需要开门则电梯执行开关门</p><p>然后，如果电梯内部还有人则电梯沿着原方向运行一层，反之，就判断请求表是否为空，如果请求表为空，如果请求表同时Over标志为true则该电梯进程结束，否则该电梯等待请求表填入，如果请求表不为空，则判断是否需要调整运行方向，不需要调整方向则沿着原方向运行一层。</p><p>分配关系如下</p><p><img src="Dispatch.png" alt="Dispatch"></p><h3 id="作业体会"><a href="#作业体会" class="headerlink" title="作业体会"></a>作业体会</h3><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>本次作业，最难的也是最重要的就是如何保证线程安全。其中下面这个bug是我感悟最深。</p><p>我们知道，在我们采用增强for循环遍历时若删除对象是线程不安全的，于是我们引进了迭代器删除的方法，但是在多线程中，对于共享对象即使采用迭代器删除仍然需要采用对对象加锁的方式保证线程安全，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (requestTable) &#123; <span class="hljs-comment">//同步</span><br>                Iterator&lt;PersonRequest&gt; iterator = personRequests.iterator();<br>                <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                    <span class="hljs-comment">/**/</span><br><span class="hljs-comment">                        iterator.remove();</span><br><span class="hljs-comment">                        requestTable.subRequestNum();</span><br><span class="hljs-comment">                    &#125;</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">            &#125;</span><br></code></pre></td></tr></table></figure><p>而不加入对象锁时，运行结果可能正确，而且同意输入可能需要多次运行才能复现bug。</p><h4 id="锁的理解"><a href="#锁的理解" class="headerlink" title="锁的理解"></a>锁的理解</h4><p>由于本次作业对锁理解不够深入，于是我再次学习了相关知识：</p><p>java中有方法锁、对象锁、类锁、静态锁，核心都是为了达到访问的有序。</p><p>对象锁：JVM 在创建对象的时候，默认会给每个对象一把唯一的对象锁，一把钥匙</p><p>类锁：每一个类都是一个对象，每个对象都拥有一个对象锁。</p><p>静态锁： 在静态方法前面加上synchronized方法表示锁定此类，当多个线程调用这个类中的静态方法时会阻塞。</p><p>实例锁： 在实例方法前面加上synchronized方法表示锁定类的单个实例，当多个线程调用一个类申明的同一个实例的实例方法是会阻塞。</p><p>当多个线程用一个对象锁，各个线程可以达到同步的作用，如果每个线程都用自己的对象锁，那么synchronized就失去了同步的作用，如下代码将不起作用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedExample</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">numberOff</span><span class="hljs-params">(Object lock)</span> &#123;<br><span class="hljs-keyword">synchronized</span> (lock) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>num++;<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + SynchronizedExample.num);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-type">SynchronizedExample</span> <span class="hljs-variable">se</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedExample</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">3</span>; i++) &#123;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>( ()-&gt;  &#123;se.numberOff(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());&#125;, <span class="hljs-string">&quot;队列&quot;</span>+i).start();<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>静态锁是针对静态方法而言，当一个静态方法中有synchronized关键字时，默认的是使用当前类字节码对象作为锁。</p><p>最后理解好哪些调用会互斥：</p><p>1、调用同一个对象中非静态同步方法的线程是互斥的。如果是不同对象，则每个线程有自己的对象的锁，线程间彼此互不干预。</p><p>2、调用同一个类中的静态同步方法的线程将是互斥的，它们都是锁定在相同的Class对象上。</p><p>3、静态同步方法和非静态同步方法将永远不是互斥的，因为静态方法锁定在Class对象上，非静态方法锁定在该类的对象上。</p><p>4、对于同步代码块，要看清楚什么对象已经用于锁定。在同一个对象上进行同步的线程将是互斥的，在不同对象上锁定的线程将永远不会互斥。</p><h3 id="debug过程"><a href="#debug过程" class="headerlink" title="debug过程"></a>debug过程</h3><p>花费最长时间在始终有一个进程无法唤醒，最后发现，最初架构时将电梯Over和调度器Over标志一起设置为true，这就导致了电梯进程结束了而调度器进程还没结束进而导致最后调度器进程无法结束。</p><h3 id="数据生成"><a href="#数据生成" class="headerlink" title="数据生成"></a>数据生成</h3><p>还是采用随机数生成的方法，并采用官方包进行输入输出，然后对输出结果进行如下统计分析：</p><ol><li>是否有人没上电梯</li><li>是否有人没下电梯</li><li>乘客乘坐电梯编号是否正确</li></ol><h3 id="互测"><a href="#互测" class="headerlink" title="互测"></a>互测</h3><p>本次互测通过数据生成hack成功一位TLE的同学。</p><p>和一条hack所有人的数据（当然呢，不合法！！！愚人节图一乐，后续被助教撤回）</p><h2 id="二、第二次作业"><a href="#二、第二次作业" class="headerlink" title="二、第二次作业"></a>二、第二次作业</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>本次作用增加了维修指令，在维修时要将电梯内部人员“赶”下来，同时撤回已分配请求，同时需要输出receive指令，从而要求我们具有一定的分配策略（但是，由于本人技艺不足，没有选择影子电梯，而选择了随机数大法），总的来说本次作业增加代码较少，完成起来较为顺利（可能是假期的原因）。</p><h3 id="UML图架构-1"><a href="#UML图架构-1" class="headerlink" title="UML图架构"></a>UML图架构</h3><p><img src="UML2_2.png" alt="UML2_2"></p><p>本次作业，由于采用的调度方法（随机数法）较为简单，所以相比上次只增加了一个<code>Constant</code>常数类用于维护电梯各项参数，暂时只维护了一些简单参数，从而实现了电梯内部无任何常数，代码的抽象层次更高。</p><h3 id="作业体会-1"><a href="#作业体会-1" class="headerlink" title="作业体会"></a>作业体会</h3><p>本次作业，由于电梯开始reset时，如果内部还存在乘客则将乘客“赶下来”（将targetMap中的乘客重新撤回到等已分配状态的RequestTable），然后已经分配的需求撤回到未分配队列，并清空该电梯的请求表。于是就产生了以下情况：</p><p><img src="Structure.png" alt="Structure"></p><p>即待分配队列有两个输入来源：输入线程和每个电梯，这样，如何让线程正确结束成了我亟待解决的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//调度器Dispatcher的run方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (requestTable.isOver()) &#123;<br>                <span class="hljs-keyword">for</span> (RequestTable requestTable : requestTables) &#123;<br>                    requestTable.setOver(<span class="hljs-literal">true</span>);<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!requestTable.hasNext()) &#123;<br>                requestTable.waitRequest();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                allocate();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (missionComplete()) &#123; <span class="hljs-comment">//任务完成</span><br>                requestTable.setOver(<span class="hljs-literal">true</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>当输入结束时，将输入结束标志变为true，当任务全部完成时（输入结束，且待分配队列和六个已分配队列都为空且不处于reset状态），则将总表的结束标志变为true，当总表的输入标志为true时，则把所有电梯表标为结束，调度器线程结束。</p><h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><h5 id="ConcurrentModifyException问题的解决"><a href="#ConcurrentModifyException问题的解决" class="headerlink" title="ConcurrentModifyException问题的解决"></a><code>ConcurrentModifyException</code>问题的解决</h5><p><code>getPersonRequestMap()</code>方法调用时可能出现ConcurrentModifyException问题（由于上图所展示的循环导致），解决方法：由于getPersonRequestMap()加锁，所以可以通过，将所有涉及元素增减的都通过调用getPersonRequestMap()方法</p>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象OO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA_OS_lab2</title>
    <link href="/2024/03/21/BUAA-OS-lab2/"/>
    <url>/2024/03/21/BUAA-OS-lab2/</url>
    
    <content type="html"><![CDATA[<h1 id="BUAA-OS-lab2学习日记"><a href="#BUAA-OS-lab2学习日记" class="headerlink" title="BUAA_OS_lab2学习日记"></a>BUAA_OS_lab2学习日记</h1><h2 id="一、思考题Thinking"><a href="#一、思考题Thinking" class="headerlink" title="一、思考题Thinking"></a>一、思考题Thinking</h2><h3 id="Thinking-2-1"><a href="#Thinking-2-1" class="headerlink" title="Thinking 2.1"></a>Thinking 2.1</h3><p>问题：在编写的 C 程序中，指针变量中存储的地址 被视为虚拟地址，还是物理地址？MIPS 汇编程序中 lw 和 sw 指令使用的地址被视为虚拟 地址，还是物理地址？</p><p>答：均为虚拟地址，访存、跳转等指令以及用于取指的 PC 寄存器中的访存目标地 址都是虚拟地址。我们编写的 C 程序中也经常通过对指针解引用来进行访存，其中指针的值也 会被视为虚拟地址，经过编译后生成相应的访存指令。也就说编译后指针所存储的地址才会变为物理地址。</p><h3 id="Thinking-2-2"><a href="#Thinking-2-2" class="headerlink" title="Thinking 2.2"></a>Thinking 2.2</h3><p>问题：</p><ul><li>从可重用性的角度，阐述用宏来实现链表的好处。</li><li>查看实验环境中的/usr/include/sys/queue.h，了解其中单向链表与循环链表的实 现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。</li></ul><p>答：</p><ul><li>简化代码量，使用宏定义可以减少代码的服用对函数进行封装，提高了代码的可读性。</li><li>以下是各自特性<ul><li>单向链表：如果要执行删除某一节点的下一个节点和在某一结点后插入可以直接进行，此外，由于每次能访问一个节点的下一个节点，插入节点和删除节点相同，每次必须从头节点遍历找到节点才能找到进行删除和插入操作。</li><li>循环链表如果要执行删除某一节点和在某一结点后插入可以直接进行，此外，由于循环链表也是单向链表，每次也只能访问一个节点的后一个节点，但是每次遍历时不必从头节点开始。</li><li>双向链表可访问某一节点的前后节点，在某一节点前后插入或删除前后节点都可以直接执行，此外查找删除操作对于某些链表还可以使用二分法提高效率。</li></ul></li></ul><h3 id="Thinking-2-3"><a href="#Thinking-2-3" class="headerlink" title="Thinking 2.3"></a>Thinking 2.3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//核心相关代码如下</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">LIST_ENTRY</span><span class="hljs-params">(Page)</span> Page_LIST_entry_t;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_ENTRY(type)                                                               </span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>                                    <br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">type</span> *<span class="hljs-title">le_next</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">type</span> **<span class="hljs-title">le_prev</span>;</span>             <br>    &#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> &#123;</span><br>Page_LIST_entry_t pp_link; <br>u_short pp_ref;<br>&#125;;<br>LIST_HEAD(Page_list, Page);<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_HEAD(name, type)               </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">name</span> &#123;</span>                                                                         <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">type</span> *<span class="hljs-title">lh_first</span>;</span> <br>&#125;<br></code></pre></td></tr></table></figure><p>综上可以选出C</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page_list</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">le_next</span>;</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> **<span class="hljs-title">le_prev</span>;</span><br>        &#125; pp_link;<br>    u_short pp_ref;<br>    &#125;* lh_first;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Thinking-2-4"><a href="#Thinking-2-4" class="headerlink" title="Thinking 2.4"></a>Thinking 2.4</h3><p>问题：</p><ul><li>请阅读上面有关 TLB 的描述，从虚拟内存和多进程操作系统的实现角度，阐述 ASID 的必要性。</li><li>请阅读 MIPS 4Kc 文档《MIPS32® 4K™ Processor Core Family Software User’s Manual》的 Section 3.3.1 与 Section 3.4，结合 ASID 段的位数，说明 4Kc 中可容纳不同的地址空间的最大数量。</li></ul><p>答：</p><ul><li>ASID用于区分不同的地址空间，在多进程操作系统中，由于同一虚拟地址在不同的地址空间中通常映射到不同的物理地址，使用ASID区分不同的地址空间可以保证不用每次切换进程时TLB也要改变。</li><li>ASID有8位，可以区分256个不同的地址空间。</li></ul><h3 id="Thinking-2-5"><a href="#Thinking-2-5" class="headerlink" title="Thinking 2.5"></a>Thinking 2.5</h3><p> 请回答下述三个问题：</p><ul><li>tlb_invalidate 和 tlb_out 的调用关系？</li><li>请用一句话概括 tlb_invalidate 的作用。</li><li>逐行解释 tlb_out 中的汇编代码。</li></ul><p>答：</p><ul><li>```C<br>//由函数声明可以看出tlb_invalidate调用tlb_out<br>void tlb_invalidate(u_int asid, u_long va) {<pre><code class="hljs">tlb_out((va &amp; ~GENMASK(PGSHIFT, 0)) | (asid &amp; (NASID - 1)));</code></pre>}<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><br>- 实现删除特定虚拟地址在 TLB 中的旧表项<br><br>- ```C<br>  <span class="hljs-comment">#include &lt;asm/asm.h&gt;</span><br>  <br>  LEAF(tlb_out)<br>  <span class="hljs-meta">.set</span> <span class="hljs-keyword">noreorder</span><br><span class="hljs-keyword"></span>  <span class="hljs-keyword">mfc0 </span>   <span class="hljs-built_in">t0</span>, CP0_ENTRYHI <br>  <span class="hljs-comment">/*将当前EntryHi寄存器的值赋给t0保存当前的VPN和ASID*/</span><br>  <span class="hljs-keyword">mtc0 </span>   <span class="hljs-built_in">a0</span>, CP0_ENTRYHI<br>  <span class="hljs-comment">/*将调用函数传入的参数即新的VPN和ASID写入EntryHi寄存器*/</span><br>  <span class="hljs-keyword">nop </span><br>  <span class="hljs-comment">/*冒险处理*/</span><br>  <span class="hljs-comment">/* Step 1: Use &#x27;tlbp&#x27; to probe TLB entry */</span><br>  <span class="hljs-comment">/* Exercise 2.8: Your code here. (1/2) */</span><br>  <span class="hljs-keyword">tlbp</span><br>  <span class="hljs-comment">/*根据 EntryHi中的Key查找对应的旧表项，将表项的索引存入CP0_INDEX*/</span><br>  <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span>  <span class="hljs-comment">/* Step 2: Fetch the probe result from CP0.Index */</span><br>  <span class="hljs-keyword">mfc0 </span>   <span class="hljs-built_in">t1</span>, CP0_INDEX<br>      <span class="hljs-comment">/*取出CP0的值*/</span><br>  <span class="hljs-meta">.set</span> reorder<br>  <span class="hljs-keyword">bltz </span>   <span class="hljs-built_in">t1</span>, NO_SUCH_ENTRY<br>      <span class="hljs-comment">/*如果没有查到对应表项*/</span><br>  <span class="hljs-meta">.set</span> <span class="hljs-keyword">noreorder</span><br><span class="hljs-keyword"></span>  <span class="hljs-keyword">mtc0 </span>   <span class="hljs-built_in">zero</span>, CP0_ENTRYHI<br>  <span class="hljs-keyword">mtc0 </span>   <span class="hljs-built_in">zero</span>, CP0_ENTRYLO0<br>  <span class="hljs-keyword">mtc0 </span>   <span class="hljs-built_in">zero</span>, CP0_ENTRYLO1<br>      <span class="hljs-comment">/*将CP0_ENTRYHI、CP0_ENTRYLO0、CP0_ENTRYLO1三个寄存器赋值为0，后续写入实现清零*/</span><br>  <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span>  <span class="hljs-comment">/* Step 3: Use &#x27;tlbwi&#x27; to write CP0.EntryHi/Lo into TLB at CP0.Index  */</span><br>  <span class="hljs-comment">/* Exercise 2.8: Your code here. (2/2) */</span><br>  <span class="hljs-keyword">tlbwi</span><br><span class="hljs-keyword"></span>      <span class="hljs-comment">/*将 EntryHi 和 EntryLo0、EntryLo1 中的值写入索引指定的表项*/</span><br>  <span class="hljs-meta">.set</span> reorder<br><span class="hljs-symbol">  </span><br><span class="hljs-symbol">  NO_SUCH_ENTRY:</span><br>  <span class="hljs-keyword">mtc0 </span>   <span class="hljs-built_in">t0</span>, CP0_ENTRYHI<br>      <span class="hljs-comment">/*将t0的值写回CP0_ENTRYHI*/</span><br>  <span class="hljs-keyword">j </span>      <span class="hljs-built_in">ra</span><br>      <span class="hljs-comment">/*函数返回*/</span><br>  END(tlb_out)<br></code></pre></td></tr></table></figure></li></ul><h3 id="Thinking-2-6"><a href="#Thinking-2-6" class="headerlink" title="Thinking 2.6"></a>Thinking 2.6</h3><p>问题：</p><ul><li>简单了解并叙述 X86 体系结构中的内存管理机制，比较 X86 和 MIPS 在内存管理上的区别。</li><li>简单了解并叙述 RISC-V 中的内存管理机制，比较 RISC-V 与 MIPS 在内存管理上的区别。</li><li>简单了解并叙述 LoongArch 中的内存管理机制，比较 LoongArch 与 MIPS 在内存管理上的区别。</li></ul><p>答：</p><ul><li>在x86架构中内存被分为三种形式，分别是<strong>逻辑地址</strong>（Logical Address），<strong>线性地址</strong>（Linear Address）和<strong>物理地址</strong>（Physical Address）。而mips内存只有两种形式。X86 体系结构中的内存管理机制是基于分段和分页的。分段是将程序的地址空间划分为若干个段，每个段都有自己的基地址和长度，可以独立地进行保护和共享。而X86在TLB不命中时，是由硬件MMU以<code>CR3</code>为当前进程的PGD基址，索引获得PFN后，直接输出PA。同时MMU会填充TLB以加快下次转换的速度。另外转换失败的虚址，MIPS使用<code>BadVAddr</code>寄存器存放，X86使用<code>CR2</code>存放。</li><li>RISC-V提供三种权限模式（MSU），而MIPS只提供内核态和用户态两种权限状态。RISC-V SV39支持39位虚拟内存空间，每一页占用4KB，使用三级页表访存。</li><li>硬件能够支持两级地址翻译，x86到LoongArch+虚地址到物理地址（通过改造内存快表TLB，做到两级虚地址映射以减少映射开销，以及减少指令使用/指令翻译开销，即X86虚地址直接翻译成龙芯物理地址）</li></ul><h3 id="Thinking-A-1"><a href="#Thinking-A-1" class="headerlink" title="Thinking A.1"></a>Thinking A.1</h3><p>问题：在现代的 64 位系统中，提供了 64 位的字长，但实际上不是 64 位页式存储系统。假设在 64 位系统中采用三级页表机制，页面大小 4KB。由于 64 位系统中字长为 8B，且页目录也占用一页，因此页目录中有 512 个页目录项，因此每级页表都需要 9 位。 因此在 64 位系统下，总共需要 3 × 9 + 12 = 39 位就可以实现三级页表机制，并不需要 64 位。现考虑上述 39 位的三级页式存储系统，虚拟地址空间为 512 GB，若三级页表的基地址为 PTbase，请计算：</p><ul><li>三级页表页目录的基地址。</li><li>映射到页目录自身的页目录项（自映射）。</li></ul><p>答：</p><p>分析：页目录通常指一级页表，以二级页表为例：</p><p>页目录的1024 个表项映射到这 1024 个页表。因此只需要 4MB 的空间即可容纳页表和页目录。</p><p><img src="page.png" alt="页目录自映射"></p><p>同理，本题中，三级页表中，页目录的512个二级页表项映射到512个三级页表映射到512个页表。虚拟地址可以化为$2^{39} / 2^{12} = 2 ^ {27}$页，既需要$2^{27}$个页表项接收这么多个页表的映射。</p><p><img src="page3result.png" alt="页目录映射关系"></p><p><img src="page3.png" alt="page3"></p><p>于是页号： <code>PN = PTBase &gt;&gt; 12</code>;</p><p>二级页表的基地址：<code>PTTBase = PTBase + PN* 8 = PTBase + PTBase &gt;&gt; 9</code></p><p>一级页表(页目录)的基地址：<code>PSTBase = PTBase + (PTTBase &gt;&gt; 12)*8</code></p><p>映射到页目录自身的页目录项的地址：<code>PDBase =PTBase + (PSTBase &gt;&gt; 12)*8  = PTBase + PTBase &gt;&gt; 9 + PTBase &gt;&gt; 18 + PTBase &gt;&gt; 27</code></p><h2 id="二、Exercise"><a href="#二、Exercise" class="headerlink" title="二、Exercise"></a>二、Exercise</h2><h3 id="exercise-2-1"><a href="#exercise-2-1" class="headerlink" title="exercise 2.1"></a>exercise 2.1</h3><p><code>mmu.h</code>文件中定义了page的大小根据物理内存/页面大小即可求出页面数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGE_SIZE 4096</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGSHIFT 12</span><br></code></pre></td></tr></table></figure><h3 id="exercise-2-2"><a href="#exercise-2-2" class="headerlink" title="exercise 2.2"></a>exercise 2.2</h3><p>易错点：指向下一个元素的指针 le_next，以及指向前一个元素链表项 le_next 的指针 le_prev（指针的指针）</p><h3 id="exercise-2-3"><a href="#exercise-2-3" class="headerlink" title="exercise 2.3"></a>exercise 2.3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C">LIST_INIT(&amp;page_free_list);<br>freemem = ROUND(freemem,PAGE_SIZE);<br>u_long usedpage = PPN(PADDR(freemem));<br><span class="hljs-keyword">for</span> (u_long i = <span class="hljs-number">0</span>;i &lt; usedpage;i ++) &#123;<br>pages[i].pp_ref = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (u_long i = usedpage;i &lt; npage;i ++) &#123;<br>pages[i].pp_ref = <span class="hljs-number">0</span>;<br>LIST_INSERT_HEAD(&amp;page_free_list,&amp;pages[i],pp_link);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="exercise-2-4"><a href="#exercise-2-4" class="headerlink" title="exercise 2.4"></a>exercise 2.4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//根据题意写出即可</span><br><span class="hljs-keyword">if</span> (LIST_EMPTY(&amp;page_free_list)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-4</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>pp = LIST_FIRST(&amp;page_free_list);<br>&#125;<br>LIST_REMOVE(pp, pp_link);<br><span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span>*)page2kva(pp),<span class="hljs-number">0</span>,PAGE_SIZE);<br></code></pre></td></tr></table></figure><h3 id="exercise-2-5"><a href="#exercise-2-5" class="headerlink" title="exercise 2.5"></a>exercise 2.5</h3><p>调用<code>LIST_INSERT_HEAD</code>即可</p><h3 id="exercise-2-6"><a href="#exercise-2-6" class="headerlink" title="exercise 2.6"></a>exercise 2.6</h3><p>第一级表称为页目录 (Page Directory)，第二级表称为页表 (Page Table)。</p><p>设 pgdir 是一个 Pde * 类型的指针，表示一个一级页表的基地址，那么使用 pgdir + i 即可得到偏移量为 i 的一级页表项（页目录项）地址</p><p><img src="address.png" alt="两级页表结构的地址变换机制"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Step 1: Get the corresponding page directory entry. */</span><br><span class="hljs-comment">/* Exercise 2.6: Your code here. (1/3) */</span><br>pgdir_entryp = pgdir + PDX(va);<br><span class="hljs-comment">/* Step 2: If the corresponding page table is not existent (valid) then:</span><br><span class="hljs-comment"> *   * If parameter `create` is set, create one. Set the permission bits &#x27;PTE_C_CACHEABLE |</span><br><span class="hljs-comment"> *     PTE_V&#x27; for this new page in the page directory. If failed to allocate a new page (out</span><br><span class="hljs-comment"> *     of memory), return the error.</span><br><span class="hljs-comment"> *   * Otherwise, assign NULL to &#x27;*ppte&#x27; and return 0.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/* Exercise 2.6: Your code here. (2/3) */</span><br><span class="hljs-keyword">if</span> (!(*pgdir_entryp &amp; PTE_V)) &#123;<span class="hljs-comment">//如果页面不合法</span><br><span class="hljs-keyword">if</span> (create) &#123;<br><span class="hljs-keyword">if</span> (page_alloc(&amp;pp) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//申请不到空间</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-4</span>;<br>&#125;<br>pp-&gt;pp_ref++; <span class="hljs-comment">//维护pp_ref</span><br>*pgdir_entryp = (PTE_D | PTE_V | page2pa(pp));<span class="hljs-comment">//并设置虚拟地址对应页目录项的内容 *pgdir_entryp = page2pa(pp) | PTE_D | PTE_V，使其与该物理页关联</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>*ppte = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">/* Step 3: Assign the kernel virtual address of the page table entry to &#x27;*ppte&#x27;. */</span><br><span class="hljs-comment">/* Exercise 2.6: Your code here. (3/3) */</span><br><span class="hljs-comment">/*二级页表基地址（指向二级页表的指针）：</span><br><span class="hljs-comment">页目录项-&gt;二级页表的物理地址-&gt;二级页表的虚拟地址-&gt;指向二级页表的指针*/</span><br>Pte *pgtable = (Pte *)KADDR(PTE_ADDR(*pgdir_entryp));<br>*ppte = pgtable + PTX(va);<br></code></pre></td></tr></table></figure><h3 id="exercise-2-7"><a href="#exercise-2-7" class="headerlink" title="exercise 2.7"></a>exercise 2.7</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Step 2: Flush TLB with &#x27;tlb_invalidate&#x27;. */</span><br><span class="hljs-comment">/* Exercise 2.7: Your code here. (1/3) */</span><br>tlb_invalidate(asid, va);<br><span class="hljs-comment">/* Step 3: Re-get or create the page table entry. */</span><br><span class="hljs-comment">/* If failed to create, return the error. */</span><br><span class="hljs-comment">/* Exercise 2.7: Your code here. (2/3) */</span><br><span class="hljs-keyword">if</span> (pgdir_walk(pgdir, va, <span class="hljs-number">1</span>, &amp;pte) == -E_NO_MEM)<br>&#123;<br><span class="hljs-keyword">return</span> -E_NO_MEM;<br>&#125;<br><span class="hljs-comment">/* Step 4: Insert the page to the page table entry with &#x27;perm | PTE_C_CACHEABLE | PTE_V&#x27;</span><br><span class="hljs-comment"> * and increase its &#x27;pp_ref&#x27;. */</span><br><span class="hljs-comment">/* Exercise 2.7: Your code here. (3/3) */</span><br>*pte = page2pa(pp) | perm | PTE_V;<br>pp-&gt;pp_ref ++;<br></code></pre></td></tr></table></figure><h3 id="exercise-2-8"><a href="#exercise-2-8" class="headerlink" title="exercise 2.8"></a>exercise 2.8</h3><p>题目描述的很清楚，指令填入即可，核心在于理解旧表项是如何被无效化的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Step 1: Use &#x27;tlbp&#x27; to probe TLB entry */</span><br><span class="hljs-comment">/* Step 2: Fetch the probe result from CP0.Index */</span><br><span class="hljs-comment">/* Step 3: Use &#x27;tlbwi&#x27; to write CP0.EntryHi/Lo into TLB at CP0.Index  */</span><br></code></pre></td></tr></table></figure><h3 id="exercise-2-9"><a href="#exercise-2-9" class="headerlink" title="exercise 2.9"></a>exercise 2.9</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* Hints:</span><br><span class="hljs-comment"> *  Invoke &#x27;page_lookup&#x27; repeatedly in a loop to find the page table entry &#x27;*ppte&#x27;</span><br><span class="hljs-comment"> * associated with the virtual address &#x27;va&#x27; in the current address space &#x27;cur_pgdir&#x27;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  **While** &#x27;page_lookup&#x27; returns &#x27;NULL&#x27;, indicating that the &#x27;*ppte&#x27; could not be found,</span><br><span class="hljs-comment"> *  allocate a new page using &#x27;passive_alloc&#x27; until &#x27;page_lookup&#x27; succeeds.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/* Exercise 2.9: Your code here. */</span><br><span class="hljs-keyword">while</span> (page_lookup(cur_pgdir,va,&amp;ppte) == <span class="hljs-literal">NULL</span>) &#123;<br>passive_alloc(va,cur_pgdir,asid);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="exercise-2-10"><a href="#exercise-2-10" class="headerlink" title="exercise 2.10"></a>exercise 2.10</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Hint: use &#x27;tlbwr&#x27; to write CP0.EntryHi/Lo into a random tlb entry. */</span><br><span class="hljs-comment">/* Exercise 2.10: Your code here. */</span><br>tlbwr<br></code></pre></td></tr></table></figure><h2 id="三、实验难点及感想"><a href="#三、实验难点及感想" class="headerlink" title="三、实验难点及感想"></a>三、实验难点及感想</h2><h3 id="实验感想"><a href="#实验感想" class="headerlink" title="实验感想"></a>实验感想</h3><p>本次实验几乎花了整个周末，实验总体分为虚拟内存和TLB 重填两大部分，其中TLB重填部分由于提示给的相当足够，完成起来不是特别难，但是理解TLB重填的汇编代码较为困难，虚拟内存部分宏定义和大量指针的存在加大了阅读的难度，总体来说，lab2相比前两次，难度有了质的上升，特别是两级页表部分的实现，需要阅读大量的代码才能读懂。</p><h3 id="核心处理重难点"><a href="#核心处理重难点" class="headerlink" title="核心处理重难点"></a>核心处理重难点</h3><p>实验的核心都在围绕下面这张图进行寻址和地址处理</p><p><img src="ctm.png" alt="CPU-TLB-Memory关系图"></p><p>面对全是宏定义和满天飞的指针，理解各个宏定义的含义尤为重要。</p><h3 id="常见宏的理解"><a href="#常见宏的理解" class="headerlink" title="常见宏的理解"></a>常见宏的理解</h3><ul><li><code>page2kva</code>：将页面转换为虚拟地址</li><li><code>page2pa</code>：将页面转换为物理地址</li><li><code>pa2page</code>: 物理地址到页</li><li><code>KADDR</code>:将物理地址转化虚拟地址</li><li><code>PADDR</code>:将虚拟地址转化为物理地址</li></ul><h3 id="自映射机制"><a href="#自映射机制" class="headerlink" title="自映射机制"></a>自映射机制</h3><p>思考题A.1困扰我良久，下面是我找到到的比较详细的解释：</p><p>一些计算：因为1M个页表项和4G的地址空间是线性映射，因此页目录地址（简称PD）对应的应该是第PT&gt;&gt;12个页表项，也就是第一个页目录项。而一个页目录项32位，4字节，因此该项相对于起始地址的偏移为(PT&gt;&gt;12)&lt;<2 = pt>&gt;10，因此PD = PT | PT&gt;&gt;10。同理，PT&gt;&gt;10是页目录在整个页表上的偏移，对应(PT&gt;&gt;10)&gt;&gt;10是自映射页目录项在页目录这张页表上的偏移。</2></p>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA_OS_lab1</title>
    <link href="/2024/03/16/BUAA-OS-lab1/"/>
    <url>/2024/03/16/BUAA-OS-lab1/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统lab1学习日记"><a href="#操作系统lab1学习日记" class="headerlink" title="操作系统lab1学习日记"></a>操作系统lab1学习日记</h1><h2 id="一、思考题"><a href="#一、思考题" class="headerlink" title="一、思考题"></a>一、思考题</h2><h3 id="Thinking1-1"><a href="#Thinking1-1" class="headerlink" title="Thinking1.1"></a>Thinking1.1</h3><ul><li><code>objdump -DS 要反汇编的目标文件名 &gt; 导出文本文件名</code><ul><li>-D：反汇编所有的section；</li><li>-d：反汇编那些特定指令机器码的section；</li><li>-S ：尽可能反汇编出源代码，尤其当编译的时候指定了-g 这种调试参数时，效果比较明显,隐含了-d参数;</li><li>-s：显示指定section的完整内容。默认所有的非空section都会被显示</li></ul></li></ul><p>printf 的实现是在链接 (Link) 这一步骤中被插入到最终的可执行文件中的。节省了过程中对printf这些频繁使用的程序的编译。</p><p><img src="编译链接图.png" alt="编译链接"></p><h3 id="Thinking1-2"><a href="#Thinking1-2" class="headerlink" title="Thinking1.2"></a>Thinking1.2</h3><p>问题：</p><ul><li>尝试使用我们编写的 readelf 程序，解析之前在 target 目录下生成的内核 ELF 文 件。 </li><li>也许你会发现我们编写的 readelf 程序是不能解析 readelf 文件本身的，而我们刚 才介绍的系统工具 readelf 则可以解析，这是为什么呢？（提示：尝试使用 readelf -h，并阅读 tools/readelf 目录下的 Makefile，观察 readelf 与 hello 的不同）</li></ul><p><code>readelf [option(s)]</code> ，用来解析一个或者多个 ELF 文件的信息，使用readeif可以查看具体用法，我们执行 readelf -S hello 命令后，hello 文件中各个节的详细信息将以列表的形式为我们展示出来。我们可以利用 readelf 工具来验证我们自己写的简易版 readelf 输出的结果是否正确，还可以使用 readelf —help 看到该命令各个选项及其对 ELF 文件的解析方式</p><p>执行./tools/readelf/readelf ./target/mos后输出</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mos</span><br><span class="hljs-attribute">0</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">1</span>:<span class="hljs-number">0</span>x80020000<br><span class="hljs-attribute">2</span>:<span class="hljs-number">0</span>x80022080<br><span class="hljs-attribute">3</span>:<span class="hljs-number">0</span>x80022098<br><span class="hljs-attribute">4</span>:<span class="hljs-number">0</span>x800220b0<br><span class="hljs-attribute">5</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">6</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">7</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">8</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">9</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">10</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">11</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">12</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">13</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">14</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">15</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">16</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">17</span>:<span class="hljs-number">0</span>x0<br></code></pre></td></tr></table></figure><p>执行readelf -h readelf输出如下</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">ELF 头：</span><br><span class="hljs-attribute">  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="hljs-attribute">  类别</span><span class="hljs-punctuation">:</span> <span class="hljs-string">                             ELF64</span><br>  <span class="hljs-attribute">数据</span><span class="hljs-punctuation">:</span> <span class="hljs-string">                             2 补码，小端序 (little endian)</span><br>  <span class="hljs-attribute">Version</span><span class="hljs-punctuation">:</span> <span class="hljs-string">                          1 (current)</span><br>  <span class="hljs-attribute">OS/ABI</span><span class="hljs-punctuation">:</span> <span class="hljs-string">                           UNIX - System V</span><br>  <span class="hljs-attribute">ABI 版本</span><span class="hljs-punctuation">:</span> <span class="hljs-string">                         0</span><br>  <span class="hljs-attribute">类型</span><span class="hljs-punctuation">:</span> <span class="hljs-string">                             DYN (Position-Independent Executable file)</span><br>  <span class="hljs-attribute">系统架构</span><span class="hljs-punctuation">:</span> <span class="hljs-string">                         Advanced Micro Devices X86-64</span><br>  <span class="hljs-attribute">版本</span><span class="hljs-punctuation">:</span> <span class="hljs-string">                             0x1</span><br>  <span class="hljs-attribute">入口点地址：               0x1180</span><br><span class="hljs-attribute">  程序头起点：          64 (bytes into file)</span><br><span class="hljs-attribute">  Start of section headers</span><span class="hljs-punctuation">:</span> <span class="hljs-string">         14488 (bytes into file)</span><br>  <span class="hljs-attribute">标志：             0x0</span><br><span class="hljs-attribute">  Size of this header</span><span class="hljs-punctuation">:</span> <span class="hljs-string">              64 (bytes)</span><br>  <span class="hljs-attribute">Size of program headers</span><span class="hljs-punctuation">:</span> <span class="hljs-string">          56 (bytes)</span><br>  <span class="hljs-attribute">Number of program headers</span><span class="hljs-punctuation">:</span> <span class="hljs-string">        13</span><br>  <span class="hljs-attribute">Size of section headers</span><span class="hljs-punctuation">:</span> <span class="hljs-string">          64 (bytes)</span><br>  <span class="hljs-attribute">Number of section headers</span><span class="hljs-punctuation">:</span> <span class="hljs-string">        31</span><br>  <span class="hljs-attribute">Section header string table index</span><span class="hljs-punctuation">:</span> <span class="hljs-string">30</span><br></code></pre></td></tr></table></figure><p>./readelf readelf无输出，readelf无法解析本身但是readelf命令可以</p><p>下面的图用于辅助理解下面的Makefile</p><p><img src="预定义变量.jpg" alt="Makefile预定义变量"></p><p>readelf 与 hello 的不同在于hello有static修饰是静态的，且hello文件被编译为32位而readelf是64位的</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">readelf: main.o readelf.o</span><br>        <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br> <br><span class="hljs-section">hello: hello.c</span><br><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span> -m32 -static -g<br><span class="hljs-comment">#-g可执行程序包含调试信息，-g为了调试用的，加个-g 是为了gdb 用，不然gdb用不到</span><br></code></pre></td></tr></table></figure><h3 id="Thinking1-3"><a href="#Thinking1-3" class="headerlink" title="Thinking1.3"></a>Thinking1.3</h3><p>问题：</p><p>在理论课上我们了解到，MIPS 体系结构上电时，启动入口地址为 0xBFC00000 （其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但 一定是一个确定的地址），但实验操作系统的内核入口并没有放在上电启动地址，而是按照 内存布局图放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？ （提示：思考实验中启动过程的两阶段分别由谁执行。） </p><p>解答：</p><ul><li>bootloader 将内核可执行文件拷贝到内存中，之后将控制权交给操作系统，只需要启动入口地址为 bootloader 的入口地址。</li><li>Linker Script——控制加载地址，Linker Script 中记录了各个节应该如何映射到段，以及各个段应该被加载到的位置。程序执行的第一条指令的地址称为入口地址（entrypoint），与此同时kernel.lds规定了 ENTRY(_start) ，即把内核入口定为 _start 这个函数。</li><li>通过对 /init/start.S 中 _start 函数的设置，即可以正确的跳转至 mips_init 函数。</li></ul><h2 id="二、测试题Exercise"><a href="#二、测试题Exercise" class="headerlink" title="二、测试题Exercise"></a>二、测试题Exercise</h2><h3 id="exercise-1-1"><a href="#exercise-1-1" class="headerlink" title="exercise 1.1"></a>exercise 1.1</h3><p>核心思路：认识结构体中各个变量的意义计算地址及其他变量即可</p><p>测试结果：</p><p><img src="exercise1.1.png" alt="exercise1.1"></p><h3 id="exercise-1-2"><a href="#exercise-1-2" class="headerlink" title="exercise 1.2"></a>exercise 1.2</h3><p>Linker Script</p><p>.text 保存可执行文件的操作指令。 .data 保存已初始化的全局变量和静态变量。 .bss 保存未初始化的全局变量和静态变量。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">. = 0x8002000; /*load address of test section*/<br>/*。例如“<span class="hljs-string">.bss</span> : &#123;*<span class="hljs-params">(.bss)</span>&#125;”表示将所有输入文件中的 <span class="hljs-string">.bss</span> 节（右边的 <span class="hljs-string">.bss</span>）都放到输出的 <span class="hljs-string">.bss</span> 节（左边的 <span class="hljs-string">.bss</span>）中,请注意代码结尾无;*/<br><span class="hljs-string">.test</span> : &#123;*<span class="hljs-params">(.test)</span>&#125;<br><span class="hljs-string">.data</span> : &#123;*<span class="hljs-params">(.data)</span>&#125;<br><span class="hljs-string">.bss</span> : &#123;*<span class="hljs-params">(.bss)</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="exercise-1-3"><a href="#exercise-1-3" class="headerlink" title="exercise 1.3"></a>exercise 1.3</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment">/* set up the kernel stack */</span><br><span class="hljs-comment">/*注意Kernel Stack是向下增长，即栈顶在低地址*/</span><br>li      <span class="hljs-built_in">sp</span>, <span class="hljs-number">0x80400000</span><br><span class="hljs-keyword">jal </span>    mips_init<br></code></pre></td></tr></table></figure><h3 id="exercise-1-4"><a href="#exercise-1-4" class="headerlink" title="exercise 1.4"></a>exercise 1.4</h3><p>根据格式符<code>%[flags][width][length]</code>补齐即可</p><h2 id="三、难点分析与感想"><a href="#三、难点分析与感想" class="headerlink" title="三、难点分析与感想"></a>三、难点分析与感想</h2><p>lab1实验主要是大致理解printf函数的内部实现，与我们最初印象不同，printf并不是全部在C语言库中全部实现，而是通过一系列编译链接后，在操作系统基础上实现。</p><h4 id="3-1-编译链接部分"><a href="#3-1-编译链接部分" class="headerlink" title="3.1 编译链接部分"></a>3.1 编译链接部分</h4><p>在链接阶段，链接器会将所有的目标文件链接在一起，并填写具体的地址等信息，形成最终的可执行文件。核心在于ELF文件</p><p><img src="ELF.png" alt="ELF文件结构"></p><p>其由五部分构成，ELF头（包含程序基本信息、段头表与节头表的偏移量）、段头表、节头表、段头表中的每一个表项（记录了该段数据载入内存时的目标位置等，记录了用于指导应用 程序加载的各类信息）、节头表（记录了该段数据载入内存时的目标位置等，记录了用于指导应用 程序加载的各类信息）</p><h4 id="3-2-内存布局以及内核被加载到哪里"><a href="#3-2-内存布局以及内核被加载到哪里" class="headerlink" title="3.2 内存布局以及内核被加载到哪里"></a>3.2 内存布局以及内核被加载到哪里</h4><p>附录中给出了对于内存布局，根据Linker Script——控制加载地址，在使用了我们自定义的 Linker Script 以后，生成的程序中，各个节的位置就被 调整到了我们所指定的地址上。段是由节组合而成的，节的地址被调整了，那么最终段的地址也 会相应地被调整，我们的实验就在 kernel.lds 中通过 ENTRY(_start) 来设置程序入口为 _start。</p><h4 id="3-3-Make中是如何构建内核的？"><a href="#3-3-Make中是如何构建内核的？" class="headerlink" title="3.3 Make中是如何构建内核的？"></a>3.3 Make中是如何构建内核的？</h4><p>mos 的构建会在在完成了所有 (modules) 目标的构建后开始。从代码中可以看出，这里执 行了 <code>$(LD) -o $(mos_elf) -N -T $(link_script) $(objects)</code></p><p>$(LD)调用链接器，-o参数后设置输出文件名，-T 文件, —script 文件  读取链接脚本，这条命令作用是使用$(link_script) 将 $(objects) 链接， 输出到$(mos_elf) 位置。</p><h4 id="3-4-start函数怎么设置的？"><a href="#3-4-start函数怎么设置的？" class="headerlink" title="3.4 _start函数怎么设置的？"></a>3.4 _start函数怎么设置的？</h4><p>EXPORT(_start)是一个宏，它将 _start 函数导出为一个符号，使得链接器可以找到它。函数中实现跳转mips_init函数</p><h4 id="3-5-内核是如何输出到控制台的？"><a href="#3-5-内核是如何输出到控制台的？" class="headerlink" title="3.5 内核是如何输出到控制台的？"></a>3.5 内核是如何输出到控制台的？</h4><p>print.c函数实现了格式化输出的主体逻辑，outputk 函数指针传入 vprintfmt 这个函数中，这个函数实际上是用来输出一个字符串的，它实际上调用了一个叫做 printcharc 的函数（调用往 QEMU 的控制台输出字符，其原理为读写某一个特殊的内存地址的函数），想让控制台输出一个字符，实际上是对某一个内存地址写了一个字节。</p><p>总体感想：本次实验相比lab0理解要更难，重在理解 操作系统中mos的启动与构建</p><h2 id="四、附录"><a href="#四、附录" class="headerlink" title="四、附录"></a>四、附录</h2><p>lab1核心——课程内存布局</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs coq">/*<br> o     <span class="hljs-number">4</span>G -----------&gt;  +----------------------------+-----------<span class="hljs-number">-0x100000000</span><br> o                      |       <span class="hljs-type">...                  |  kseg2</span><br> o      KSEG2    -----&gt; +----------------------------+-----------<span class="hljs-number">-0xc000</span> <span class="hljs-number">0000</span><br> o                      |          <span class="hljs-type">Devices</span>           |  <span class="hljs-type">kseg1</span><br> o      KSEG1    -----&gt; +----------------------------+-----------<span class="hljs-number">-0xa000</span> <span class="hljs-number">0000</span><br> o                      |      <span class="hljs-type">Invalid</span> Memory        |   <span class="hljs-type">/|\</span><br><span class="hljs-type"> o</span>                      +----------------------------+----|<span class="hljs-type">-------Physical</span> Memory Max<br> o                      |       <span class="hljs-type">...                  |  kseg0</span><br> o      KSTACKTOP-----&gt; +----------------------------+----|<span class="hljs-type">-------0x8040</span> <span class="hljs-number">0000</span>-------<span class="hljs-keyword">end</span><br> o                      |       <span class="hljs-type">Kernel</span> Stack         |    <span class="hljs-type">| KSTKSIZE</span>            /|<span class="hljs-type">\</span><br><span class="hljs-type"> o</span>                      +----------------------------+----|<span class="hljs-type">------                |</span><br><span class="hljs-type"> o</span>                      |       <span class="hljs-type">Kernel</span> Text          |    <span class="hljs-type">|                    PDMAP</span><br> o      KERNBASE -----&gt; +----------------------------+----|<span class="hljs-type">-------0x8002</span> <span class="hljs-number">0000</span>    |<br> <span class="hljs-type">o</span>                      |      <span class="hljs-type">Exception</span> Entry       |   <span class="hljs-type">\|/                    \|/</span><br><span class="hljs-type"> o</span>      ULIM     -----&gt; +----------------------------+-----------<span class="hljs-number">-0x8000</span> <span class="hljs-number">0000</span>-------<br> o                      |         <span class="hljs-type">User</span> VPT           |     <span class="hljs-type">PDMAP</span>                /|<span class="hljs-type">\</span><br><span class="hljs-type"> o</span>      UVPT     -----&gt; +----------------------------+-----------<span class="hljs-number">-0x7fc0</span> <span class="hljs-number">0000</span>    |<br> <span class="hljs-type">o</span>                      |           <span class="hljs-type">pages</span>            |     <span class="hljs-type">PDMAP</span>                 |<br> <span class="hljs-type">o</span>      UPAGES   -----&gt; +----------------------------+-----------<span class="hljs-number">-0x7f80</span> <span class="hljs-number">0000</span>    |<br> <span class="hljs-type">o</span>                      |           <span class="hljs-type">envs</span>             |     <span class="hljs-type">PDMAP</span>                 |<br> <span class="hljs-type">o</span>  UTOP,UENVS   -----&gt; +----------------------------+-----------<span class="hljs-number">-0x7f40</span> <span class="hljs-number">0000</span>    |<br> <span class="hljs-type">o</span>  UXSTACKTOP -/       |     <span class="hljs-type">user</span> exception stack   |     <span class="hljs-type">PTMAP</span>                 |<br> <span class="hljs-type">o</span>                      +----------------------------+-----------<span class="hljs-number">-0x7f3f</span> f000    |<br> <span class="hljs-type">o</span>                      |                            <span class="hljs-type">|     PTMAP</span>                 |<br> <span class="hljs-type">o</span>      USTACKTOP ----&gt; +----------------------------+-----------<span class="hljs-number">-0x7f3f</span> e000    |<br> <span class="hljs-type">o</span>                      |     <span class="hljs-type">normal</span> user stack      |     <span class="hljs-type">PTMAP</span>                 |<br> <span class="hljs-type">o</span>                      +----------------------------+-----------<span class="hljs-number">-0x7f3f</span> d000    |<br> <span class="hljs-type">a</span>                      |                            <span class="hljs-type">|                           |</span><br><span class="hljs-type"> a</span>                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                           |<br> <span class="hljs-type">a</span>                      .                            .                           |<br> <span class="hljs-type">a</span>                      .                            .                         kuseg<br> a                      .                            .                           |<br> <span class="hljs-type">a</span>                      |<span class="hljs-type">~~~~~~~~~~~~~~~~~~~~~~~~~~~~|                           |</span><br><span class="hljs-type"> a</span>                      |                            <span class="hljs-type">|                           |</span><br><span class="hljs-type"> o</span>       UTEXT   -----&gt; +----------------------------+-----------<span class="hljs-number">-0x0040</span> <span class="hljs-number">0000</span>    |<br> <span class="hljs-type">o</span>                      |      <span class="hljs-type">reserved</span> <span class="hljs-keyword">for</span> COW      |     <span class="hljs-type">PTMAP</span>                 |<br> <span class="hljs-type">o</span>       UCOW    -----&gt; +----------------------------+-----------<span class="hljs-number">-0x003f</span> f000    |<br> <span class="hljs-type">o</span>                      |   <span class="hljs-type">reversed</span> <span class="hljs-keyword">for</span> temporary   |     <span class="hljs-type">PTMAP</span>                 |<br> <span class="hljs-type">o</span>       UTEMP   -----&gt; +----------------------------+-----------<span class="hljs-number">-0x003f</span> e000    |<br> <span class="hljs-type">o</span>                      |       <span class="hljs-type">invalid</span> memory       |                          <span class="hljs-type">\|/</span><br><span class="hljs-type"> a</span>     <span class="hljs-number">0</span> ------------&gt;  +----------------------------+ ----------------------------<br> o<br>*/<br>/* <span class="hljs-keyword">End</span> of Key Code <span class="hljs-string">&quot;load-kernel&quot;</span> */<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA_OS_lab0</title>
    <link href="/2024/03/06/BUAA-OS-lab0/"/>
    <url>/2024/03/06/BUAA-OS-lab0/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统lab0学习日记"><a href="#操作系统lab0学习日记" class="headerlink" title="操作系统lab0学习日记"></a>操作系统lab0学习日记</h1><h3 id="1-学习阶段的难点分析与体会"><a href="#1-学习阶段的难点分析与体会" class="headerlink" title="1 学习阶段的难点分析与体会"></a>1 学习阶段的难点分析与体会</h3><h4 id="1-1-基础命令和快捷键"><a href="#1-1-基础命令和快捷键" class="headerlink" title="1.1 基础命令和快捷键"></a>1.1 基础命令和快捷键</h4><ul><li>Ctrl+C 终止当前程序的执行</li><li>Ctrl+Z 挂起当前程序 </li><li>Ctrl+D 终止输入（若正在使用 shell，则退出当前 shell）</li><li>Ctrl+L 清屏</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">语法:gcc [选项]... [参数]... <br>选项（常用）：<br>-o 指定生成的输出文件 <br>-S 将 C 代码转换为汇编代码 <br>-Wall 显示一些警告信息 <br>-c 仅执行编译操作，不进行链接操作<br>-M 列出依赖<br>-I 编译时指定头文件目录，使用标准库时不需要指定目录，-I 参数可以用相对 ,→ 路径，比如头文件在当前目录，可以用-I. 来指定<br></code></pre></td></tr></table></figure><h4 id="1-2-ctags"><a href="#1-2-ctags" class="headerlink" title="1.2 ctags"></a>1.2 ctags</h4><p>回到命令行界面，执行命令<code>ctags -R *</code>，会发现在该目录下出现了新的文 件 tags，接下来就可以使用一些 ctags 的功能了：</p><p>按下 Ctrl+ ]，便可以跳转到函数定义处；再按下 Ctrl+T 或 Ctrl+O（有 些浏览器 Ctrl+T 是新建页面，会出现热键冲突），便可以回到跳转前的位置。</p><h4 id="1-3-git"><a href="#1-3-git" class="headerlink" title="1.3 git"></a>1.3 git</h4><p>git四种状态：</p><p><img src="git.png" alt="Git"></p><p><img src="gitPrinciple.png" alt></p><p>详见指导书p22，图中我们可以看出此时 HEAD 实际是指向 master 分支的一个“指针”。所以图示 的命令中出现 HEAD 的地方可以用 master 来替换。</p><p>当执行 <code>git rm --cached&lt;file&gt;</code>命令时，会直接从暂存区删除文件，工作区则 不做出改变，实现从暂存区删去不想继续跟踪的文件</p><p><code>git checkout -- &lt;file&gt;</code>如果在工作区中对多个文件经过多次修改后，发现编译 无法通过了。如果尚未执行 <code>git add</code>，则可使用本命令将工作区恢复成原来的样子。作用和<code>git restore</code>类似</p><p><code>git reset HEAD &lt;file&gt;</code>上一条命令是在未执行 <code>git add</code>命令便修改文件生效并 放入暂存区，可使用<code>git checkout</code> 命令。那么如果不慎已经执行了<code>git add</code>，则 可使用本命令。再对需要恢复的文件使用上一条命令即可。</p><p><code>git reset --hard</code>进行版本回退，使用这条命令可以进行版本回退或者切换到任何一个版本。它有两种用法：第一 种是使用<code>HEAD</code>类似形式，如果想退回上个版本就用<code>HEAD^</code>，上上个版本的话就用<code>HEAD^^</code>，要是回退到前 50 个版本则可使用<code>HEAD~50</code>来代替；第二种就是使用<code>hash</code>值，使用<code>hash</code>值可以在不同版本之间任意切换，足见<code>hash</code>值的强大。但是，它强制覆盖了工作目录中的文件。若该文件还未提交，Git 会覆盖它从 而导致无法恢复。</p><p><code>git branch</code>,</p><p>选项：</p><p><code>-D</code>  强制删除一个指定分支</p><p><code>-a</code>   查看所有的原地和本地分支</p><p><img src="gitBranch.png" alt="git branch"></p><h4 id="1-4-linux进阶"><a href="#1-4-linux进阶" class="headerlink" title="1.4 linux进阶"></a>1.4 linux进阶</h4><p><code>find</code>:使用 find 命令并加上 -name 选项可以在当前目录下递归地查找符合参数所示文件 名的文件，并将文件的路径输出至屏幕上。</p><p><code>grep</code>:grep 命令可以从文件中查找包含 pattern 部分字符串的行，并将 该文件的路径和该行输出至屏幕</p><p><code>chmod</code>:+ 表示增加权限、- 表示取消权限、= 表示唯一设定权 限。r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者 该文件已经被设定过为可执行。</p><p><code>diff</code>:比较文件差异，-b 不检查空白字符的不同，-B不检查空行，-q仅显示有无差异不显示详细信息</p><p><code>sed</code>:</p><p>选项（常用）：</p><ul><li>-n 安静模式，只显示经过 sed 处理的内容。否则显示输入文本的所有内容。</li><li>-i 直接修改读取的档案内容，而不是输出到屏幕。否则，只输出不编辑。</li><li><code>-e</code>允许在同一行类执行多条命令</li></ul><p>命令（常用）：</p><ul><li>[行号]a[内容] 新增，在行号后新增一行相应内容。行号可以是“数字”，在这一行之后新增，不写行号时，在每一行之后新增。使用 $ 表示最后一行。后面的命令同理。</li><li>[行号]c[内容] 取代。用内容取代相应行的文本。</li><li>[行号]i[内容] 插入。在当前行的上面插入一行文本。</li><li>[行号]d 删除当前行的内容。</li><li>[行号]p 输出选择的内容。通常与选项-n 一起使用。</li><li>s/re/string 将 re（正则表达式）匹配的内容替换为 string。</li></ul><p><code>awk</code>:awk ‘pattern action’ file，pattern 为条件，action 为命 令，file 为文件。</p><h4 id="1-5-shell"><a href="#1-5-shell" class="headerlink" title="1.5 shell"></a>1.5 shell</h4><p><code>$n</code>就表示第几个参数，<code>$#</code>表示传递参数的个数，<code>$*</code>表示传递的全部参数</p><h3 id="2-Thinking"><a href="#2-Thinking" class="headerlink" title="2 Thinking"></a>2 Thinking</h3><h4 id="Thinking-0-1"><a href="#Thinking-0-1" class="headerlink" title="Thinking 0.1"></a>Thinking 0.1</h4><p>问题：思考下列有关 Git 的问题：</p><ul><li>在前述已初始化的 ~/learnGit 目录下，创建一个名为 README.txt 的文件。执 行命令 git status &gt; Untracked.txt（其中的 &gt; 为输出重定向，我们将在 0.6.3 中 详细介绍）。 </li><li>在 README.txt 文件中添加任意文件内容，然后使用 add 命令，再执行命令 git status &gt; Stage.txt。 </li><li>提交 README.txt，并在提交说明里写入自己的学号。</li><li>执行命令 cat Untracked.txt 和 cat Stage.txt，对比两次运行的结果，体会 README.txt 两次所处位置的不同。</li><li>修改 README.txt 文件，再执行命令 git status &gt; Modified.txt。</li><li>执行命令 cat Modified.txt，观察其结果和第一次执行 add 命令之前的 status 是 否一样，并思考原因。</li></ul><p>解答：新建<code>README.txt</code>文件后，文件处于Untracked状态，文件中添加部分内容，git add后会处于staged状态。先git commit文件接下来再修改文件，文件会处于Modified状态</p><h4 id="Thinking-0-2"><a href="#Thinking-0-2" class="headerlink" title="Thinking 0.2"></a>Thinking 0.2</h4><p>问题：上图中思考一下箭头中的 add the file 、stage the file 和 commit 分别对应的是 Git 里的哪些命令呢？ </p><p>解答：</p><ul><li><code>git add</code></li><li><code>git add</code></li><li><code>git commit</code></li></ul><h4 id="Thinking-0-3"><a href="#Thinking-0-3" class="headerlink" title="Thinking 0.3"></a>Thinking 0.3</h4><p>问题：</p><ol><li>代码文件 print.c 被错误删除时，应当使用什么命令将其恢复？ </li><li>代码文件 print.c 被错误删除后，执行了 git rm print.c 命令，此时应当 使用什么命令将其恢复？</li><li>无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区</li></ol><p>解答：</p><ul><li><code>git checkout --print.c</code></li><li><code>git reset HEAD print.c &amp;&amp; git checkout --print.c</code></li><li><code>git rm -- chched print.c</code></li></ul><h4 id="Thinking-0-4"><a href="#Thinking-0-4" class="headerlink" title="Thinking 0.4"></a>Thinking 0.4</h4><p>版本回退中，<code>git reset --hard</code>后面添加<code>HEAD^</code>可以回到上一版本，<code>HEAD~32</code>这样最多支持回到上五十个版本，此外也使用 hash 值可以在不同版本之间任意切换。</p><h4 id="Thinking-0-5"><a href="#Thinking-0-5" class="headerlink" title="Thinking 0.5"></a>Thinking 0.5</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">执行如下命令, 并查看结果<br>• echo first #输出first<br>• echo second &gt; output.txt #将second输出到output.txt<br>• echo third &gt; output.txt<br><span class="hljs-meta prompt_">#</span><span class="language-bash">将third输出到output.txt并覆盖</span><br>• echo forth &gt;&gt; output.txt<br><span class="hljs-meta prompt_">#</span><span class="language-bash">将forth输出到output.txt但不覆盖</span><br><br></code></pre></td></tr></table></figure><h4 id="Thinking-0-6"><a href="#Thinking-0-6" class="headerlink" title="Thinking 0.6"></a>Thinking 0.6</h4><p>echo echo Shell Start 直接把“echo Shell Start” 作为字符串输出；</p><p>echo (反顿号)echo Shell Start(反顿号)是将 “echo Shell Start” 的输出作为 外层echo 的输入，故会输出 Shell Start；</p><p>echo (单引号)echo Shell Start(单引号)直接把“echo Shell Start” 作为字符串输出</p><h3 id="3-lab0作业debug阶段的易错点"><a href="#3-lab0作业debug阶段的易错点" class="headerlink" title="3 lab0作业debug阶段的易错点"></a>3 lab0作业debug阶段的易错点</h3><h4 id="3-1-脚本执行参数不能丢"><a href="#3-1-脚本执行参数不能丢" class="headerlink" title="3.1 脚本执行参数不能丢"></a>3.1 脚本执行参数不能丢</h4><p>在./search.sh 时未输入一下参数会爆出重定向有歧义（只是其中之一）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -n <span class="hljs-string">&quot;<span class="hljs-variable">$2</span>&quot;</span> <span class="hljs-variable">$1</span> | awk -F <span class="hljs-string">&#x27;:&#x27;</span> <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span> &gt; <span class="hljs-variable">$3</span><br></code></pre></td></tr></table></figure><h4 id="3-2-Makefile中的问题"><a href="#3-2-Makefile中的问题" class="headerlink" title="3.2 Makefile中的问题"></a>3.2 Makefile中的问题</h4><ol><li><code>.PHONY</code>后面跟的目标都被称为伪目标，也就是说我们 make 命令后面跟的参数如果出现在.PHONY 定义的伪目标中，那就直接在Makefile中就执行伪目标的依赖和命令。不管Makefile同级目录下是否有该伪目标同名的文件，即使有也不会产生冲突。另一个就是提高执行makefile时的效率。</li><li>如下,如果执行all会同时执行fibo和clean对应命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">all :fibo clean<br><br>clean:<br><span class="hljs-built_in">rm</span> -rf $(TARGET)<br>fibo: fibo.c<br>gcc -o fibo fibo.c<br></code></pre></td></tr></table></figure><h4 id="3-3-gcc"><a href="#3-3-gcc" class="headerlink" title="3.3 gcc"></a>3.3 gcc</h4><p><code>-I</code>参数是用来指定头文件目录</p><p><code>-l</code>参数就是用来指定程序要链接的库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc ./code/fibo.o ./code/main.o -o fibo <br></code></pre></td></tr></table></figure><p>这段代码作用:</p><p>这段代码使用了gcc编译器将两个目标文件（fibo.o和main.o）链接在一起，生成一个名为fibo的可执行文件。通常，这种编译方式适用于将程序分成多个源文件编写，然后分别编译成目标文件，最后将它们链接在一起以生成最终的可执行文件。</p><h3 id="4-Exercice总结"><a href="#4-Exercice总结" class="headerlink" title="4 Exercice总结"></a>4 Exercice总结</h3><h4 id="4-1-Exercise-0-1"><a href="#4-1-Exercise-0-1" class="headerlink" title="4.1 Exercise 0.1"></a>4.1 Exercise 0.1</h4><ol><li><p>palindrome.c代码补全，实现回文数判断，核心思路：将数字n的各位上的数字存到数组中进行比对</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> main &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span> (<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>        a[i++] = n % <span class="hljs-number">10</span>;<br>        n /= <span class="hljs-number">10</span>;<br>    &#125;<br>    j = i - <span class="hljs-number">1</span>;<br>    i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">if</span> (a[i] != a[j]) &#123;<br>            flag = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        i ++;<br>        j --;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flag) &#123;<br>        print(<span class="hljs-string">&quot;Y\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>print(<span class="hljs-string">&quot;N\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ol><li><p>```shell<br>gcc -o palindrome palindrome.c</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><br><span class="hljs-number">3.</span> sed指令的使用<br><br>   ```shell<br>   <span class="hljs-meta">#实现通过命令 bash hello_os.sh AAA BBB，在 hello_os.sh 所处的目录新建一个名为 BBB 的文件，内容是AAA 文件的第 8、32、128、512、1024 行的内容提取</span><br>   sed -n <span class="hljs-string">&#x27;8p;32p;128p;512p;1024p&#x27;</span> $1 &gt; $2<br>   <span class="hljs-meta">#-n 表示在安静模式下进行</span><br></code></pre></td></tr></table></figure></li><li><p>文件复制,co指令的使用</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cp -r src<span class="hljs-regexp">/* dst/</span><br>re dst<span class="hljs-regexp">/sh_test/</span>hello_os.sh<br></code></pre></td></tr></table></figure></li></ol><h4 id="4-2-Exercise-0-2"><a href="#4-2-Exercise-0-2" class="headerlink" title="4.2 Exercise 0.2"></a>4.2 Exercise 0.2</h4><ol><li><p>删除和重命名的使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -r &quot;file$a&quot; #删除file4(若$a == 4)<br>mv ./&quot;file$a&quot; ./&quot;newfile$a&quot;<br>let a=a+1 #使得a递增，注意不要加些空格<br></code></pre></td></tr></table></figure></li></ol><h4 id="4-3-Exercise-0-3"><a href="#4-3-Exercise-0-3" class="headerlink" title="4.3 Exercise 0.3"></a>4.3 Exercise 0.3</h4><p>​    <code>grep</code>与<code>awk</code>的使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -n $2 $1 | awk -F &#x27;:&#x27; &#x27;&#123;print $1&#125;&#x27; &gt; $3<br></code></pre></td></tr></table></figure><h4 id="4-4-Exercise-0-4"><a href="#4-4-Exercise-0-4" class="headerlink" title="4.4 Exercise 0.4"></a>4.4 Exercise 0.4</h4><ol><li><p><code>sed</code>使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#将$1文件中的$s2替换为$s3</span><br>sed -i <span class="hljs-string">&quot;s/<span class="hljs-variable">$2</span>/<span class="hljs-variable">$3</span>/g&quot;</span> <span class="hljs-variable">$1</span><br></code></pre></td></tr></table></figure></li><li><p><code>Makefile</code>编写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"> 内部Makefile<br>  1 all: fibo main<br>  2 <br>  3 fibo: fibo.c<br>  4         gcc -I ../include -c fibo.c<br>  5 <br>  6 main: main.c fibo.o<br>  7         gcc -I ../include -c main.c<br>  8 <br>  9 clean:<br> 10         rm *.o<br>外部<br>  1 all: fibo<br>  2 <br>  3 fibo: <br>  4         cd code &amp;&amp; make <br>  5         gcc ./code/fibo.o ./code/main.o -o fibo<br>  6 <br>  7 clean: <br>  8         rm ./code/fibo.o<br>  9         rm ./code/main.o<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA_OO_Unit1</title>
    <link href="/2024/03/01/BUAA-OO-Unit1/"/>
    <url>/2024/03/01/BUAA-OO-Unit1/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="BUAA-OO-Unit1总结"><a href="#BUAA-OO-Unit1总结" class="headerlink" title="BUAA_OO_Unit1总结"></a>BUAA_OO_Unit1总结</h1><h2 id="一、第一次作业hw1"><a href="#一、第一次作业hw1" class="headerlink" title="一、第一次作业hw1"></a>一、第一次作业hw1</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>耗时数天完成了代码书写及代码调试，感悟良多，归功于Training中的内容，我在本次作业中也选择了对应的递归下降的思路构造语法树，同时在根据语法树利用逆向思路将解析完的表达式转化为多项式形式，最后多项式存入TreeMap中按要求降序输出结果。此外UML图中单箭头为本人添加，代表核心的依赖关系。</p><h3 id="1-代码UML框架"><a href="#1-代码UML框架" class="headerlink" title="1.代码UML框架"></a>1.代码UML框架</h3><p><img src="uml.png" alt="UML框架"></p><p><code>NumFactor,VarFactor,ExprFactor</code>继承Factor父类，既可以调用父类<code>exponet</code>的相关方法，又有各自<code>toPoly</code>的方法，<code>Monomial</code>单项式类用于处理单项式，<code>Poly</code>用于处理多项式，<code>PolynomialAnswer</code>用于最终化简输出</p><h3 id="2-代码架构分析"><a href="#2-代码架构分析" class="headerlink" title="2.代码架构分析"></a>2.代码架构分析</h3><h4 id="2-1-预处理"><a href="#2-1-预处理" class="headerlink" title="2.1 预处理"></a>2.1 预处理</h4><p><img src="image-20240301204258960.png" alt="形式化表述"></p><p>根据表达式的形式化表达我们可以得到以下结论：</p><ol><li>表达式中最多三个连续的<code>+</code>或者<code>-</code></li><li>常数因子可以有前导0</li><li>指数符号后只可能是<code>token.ADD</code>或者<code>token.NUM</code></li><li>表达式中可能存在大量 <code>space</code>和<code>\t</code></li><li>表达式或<code>(</code>后可能存在符号</li></ol><p>于是为了简化后续操作我选择进行的以下操作</p><ol><li>若读到<code>+</code>且前面存在其他符号或位于开头则去掉加号</li><li>若读到<code>-</code>且前面存在<code>(</code>或者位于开头则在前面加上0，若减号连续则将其换为一个<code>+</code></li><li>去掉所有空格</li></ol><h4 id="2-2-词法分析与解析部分"><a href="#2-2-词法分析与解析部分" class="headerlink" title="2.2 词法分析与解析部分"></a>2.2 词法分析与解析部分</h4><h5 id="2-2-1-Lexer部分"><a href="#2-2-1-Lexer部分" class="headerlink" title="2.2.1 Lexer部分"></a>2.2.1 Lexer部分</h5><ol><li>在读取到<code>token.NUM</code>时去除前缀0（但是谨记保证数不会被全部去掉）</li><li>在读取到未知符号时我们选择抛出异常（强烈建议此方法，后续可以快速定位bug）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Invalid token&quot;</span>);<br></code></pre></td></tr></table></figure><h5 id="2-2-2-Parse"><a href="#2-2-2-Parse" class="headerlink" title="2.2.2 Parse"></a>2.2.2 Parse</h5><p>该部分是代码词法解析的核心部分</p><ol><li><p>我完成了<code>parseExpr()、parseTerm()、parseFactor()</code>的书写并采用递归下降的方法调用</p></li><li><p>由于预处理我们可以只对Term加上正负属性并且在这里完成项的正负号的确定</p></li><li><p>在解析项时去掉指数符号，将其全部转化为因子形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">Factor</span> <span class="hljs-variable">factor</span> <span class="hljs-operator">=</span> parseFactor();<br>        <span class="hljs-keyword">if</span> (factor.getExponent() == <span class="hljs-number">0</span>) &#123;<br>            term.addFactor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NumFactor</span>(BigInteger.ONE));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; factor.getExponent(); i++) &#123;<br>            term.addFactor(factor);<br>        &#125;<br></code></pre></td></tr></table></figure></li></ol><ol><li><p>同上在解析未知符号是我们选择抛出异常便于debug</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Invalid token&quot;</span>);<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-3-根据解析结果转化为多项式"><a href="#2-3-根据解析结果转化为多项式" class="headerlink" title="2.3 根据解析结果转化为多项式"></a>2.3 根据解析结果转化为多项式</h4><p>该部分核心思路还是递归思路</p><p>Expr -&gt; Term -&gt; Factor</p><p>然后多项式中存入<code>TreeMap&lt;Integer,BigInteger&gt; polynomial</code></p><p>最后，我们要得到形如：$Expr =  \sum\limits_ { i = 0 } a_i * x ^ { b_i }$</p><p>好处：保证有序性和便于得到$a_i$和$b_i$，在此基础上得到一个字符串即可</p><h3 id="3-测试思路"><a href="#3-测试思路" class="headerlink" title="3.测试思路"></a>3.测试思路</h3><h4 id="3-1-自动化测试"><a href="#3-1-自动化测试" class="headerlink" title="3.1.自动化测试"></a>3.1.自动化测试</h4><h5 id="3-11-数据生成"><a href="#3-11-数据生成" class="headerlink" title="3.11 数据生成"></a>3.11 数据生成</h5><p>思路还是和解答程序程序相似,按照generate_factor  —&gt; generate_term —&gt; generate_expr —&gt;generate_testcase</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_factor</span>(<span class="hljs-params">floor</span>):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_term</span>(<span class="hljs-params">floor</span>):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_expr</span>(<span class="hljs-params">floor</span>):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_testcase</span>(<span class="hljs-params">Limit,floor</span>):<br></code></pre></td></tr></table></figure><p>最后随机在生成式之间添加空格</p><h5 id="3-12-测试比对"><a href="#3-12-测试比对" class="headerlink" title="3.12 测试比对"></a>3.12 测试比对</h5><p>依赖于sympy自带的化简功能实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">execute_java</span> (stdin, <span class="hljs-built_in">str</span>):<br>    cmd = [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-built_in">str</span> + <span class="hljs-string">&quot;.jar&quot;</span>]  <span class="hljs-comment"># 更改为自己的.jar包名</span><br>    proc = subprocess.Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=STDOUT)<br>    stdout, stderr = proc.communicate(stdin.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>    <span class="hljs-keyword">return</span> stdout.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>).strip()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">isEqual</span>(<span class="hljs-params">javaInput,javaOutput</span>):<br>    javaInput = sp.simplify(javaInput)<br>    javaOutput = sp.simplify(javaOutput)<br>    <span class="hljs-keyword">return</span> javaInput.equals(javaOutput)<br></code></pre></td></tr></table></figure><h2 id="二、第二次作业hw2"><a href="#二、第二次作业hw2" class="headerlink" title="二、第二次作业hw2"></a>二、第二次作业hw2</h2><h4 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h4><p>本次作业花费大多时间在构思解决最后的化简上，同时在debug时也遇到了不少问题，但最终一一解决，虽代码相比第一次变化不小，但总体思路大致相同</p><h4 id="1-代码UML框架-1"><a href="#1-代码UML框架-1" class="headerlink" title="1.代码UML框架"></a>1.代码UML框架</h4><p><img src="UML_Unit1.2.png" alt="UML"></p><p>相比上次增加了自定义函数类、自定义函数集合、自定义函数因子类用于处理自定义函数以及其替换，迭代中发现<code>PolynomailAnswer</code>类作为最终输出由于增加了<code>ExpFuncFactor</code>指数函数类的原因，反而不能起到化简的作用，于是删去了，相关输出在<code>Poly</code>类中实现。</p><h4 id="2-作业体会"><a href="#2-作业体会" class="headerlink" title="2.作业体会"></a>2.作业体会</h4><ol><li>关于使用替换进行函数展开，要注意不要引入新的形参。例如f(y, x)=y+x，展开f(x, x^2)时，若不加任何修改直接用x替换形参y，f就会变为x+x， 再直接用x^2替换所有形参x，就会变为x^2+x^2的错误结果。因此，可以先将所有形参变为其他形式， 如f(v,u) = v+u，再替换形参v和u就不会发生上述错误。对于<code>exp(x)</code>,由于<code>exp</code>中包含x，可能会影响我们后续对于x的替换，所以在一开始我们可以选择将<code>exp</code>替换为<code>e</code></li><li>深拷贝与浅拷贝学习，由于JAVA默认一般是浅拷贝，如下我们正常写法应该是<code>return this.defineFunctions</code>,但是函数的参数替换时可能会涉及多次形参的替换，如果不采用深拷贝的话，会导致第一遍替换后会影响我们到后续的替换。        </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ArrayList&lt;DefineFunction&gt; <span class="hljs-title function_">getDefineFunctions</span><span class="hljs-params">()</span> &#123;<br>    ArrayList&lt;DefineFunction&gt; dfs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (DefineFunction defineFunction : <span class="hljs-built_in">this</span>.defineFunctions) &#123;<br>        dfs.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefineFunction</span>(defineFunction.getName(), defineFunction.getBody()));<br>        dfs.get(dfs.size() - <span class="hljs-number">1</span>).setParameters(defineFunction.getParameters());<br>    &#125;<br>    <span class="hljs-keyword">return</span> dfs;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现深拷贝也有很多种方法，对于String 类型的我们可以new一个String类型对象后赋值，对于某一个自定义对象，我们可以通过以下方法实现：</p><ul><li><p>重写<code>clone（）</code>方法，但是这种方法某一类有多少个引用类型，我们就要重写多少次，如果存在很多引用类型，那么代码量显然会很大，所以这种方法不太合适。</p></li><li><p>利用序列化序，列化是将对象写到流中便于传输，而反序列化则是把对象从流中读取出来。这里写到流中的对象则是原始对象的一个拷贝，因为原始对象还存在 JVM 中，所以我们可以利用对象的序列化产生克隆对象，然后通过反序列化获取这个对象。 注意每个需要序列化的类都要实现 Serializable 接口，如果有某个属性不需要序列化，可以将其声明为 transient，即将其排除在克隆属性之外。下面是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.Serial;<br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-comment">//Serializable的作用是为了实现对象的序列化，只有实现了Serializable接口的类才能被序列化</span><br>    <span class="hljs-meta">@Serial</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> age; <span class="hljs-comment">//transient关键字修饰的变量不会被序列化</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">deepClone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//序列化</span><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>(); <span class="hljs-comment">//创建字节数组输出流</span><br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bos);<br>        oos.writeObject(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-comment">//反序列化</span><br>        <span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bos.toByteArray());<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(bis);<br>        <span class="hljs-keyword">return</span> ois.readObject();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h4 id="3-代码架构分析"><a href="#3-代码架构分析" class="headerlink" title="3.代码架构分析"></a>3.代码架构分析</h4><p>本次迭代继承了上次大部分的思路，增加了DefineFunction，FunctionList两个类用于读取和储存自定义函数，同时根据提示题意增加了需要的DefineFunctionFactor、ExpFuncFactor类适应新的需求</p><h5 id="3-1-自定义函数的替换"><a href="#3-1-自定义函数的替换" class="headerlink" title="3.1 自定义函数的替换"></a>3.1 自定义函数的替换</h5><p>由于在于处理中一直没有好的思路实现替换，于是我决定牺牲部分运行的时间，先解析一遍表达式，再将Expr通过递归思路转化为String形式，在这个过程中在DefineFunctionFactor下的toString()方法实现替换，但在这里要注意调用我们储存好的FunctionList的内容时要实现深拷贝</p><h5 id="3-2-多项式的化简"><a href="#3-2-多项式的化简" class="headerlink" title="3.2 多项式的化简"></a>3.2 多项式的化简</h5><p>本次单项式相比上次多了Poly类对象对应exp（）内部的多项式，多项式类采用以下储存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> ArrayList&lt;Monomial&gt; monomials;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TreeMap&lt;BigInteger, HashMap&lt;Poly, BigInteger&gt;&gt; polyMap;<br></code></pre></td></tr></table></figure><p>最开始先不断在monomials中添加单项式，后再往polyMap中添加实现化简，注意由于HashMap的key是自定义类，我们需要重写equals（）方法和hashcode()方法</p><h3 id><a href="#" class="headerlink" title=" "></a> </h3><h3 id="4-debug"><a href="#4-debug" class="headerlink" title="4. debug"></a>4. debug</h3><h4 id="CPU超时以及超内存应对"><a href="#CPU超时以及超内存应对" class="headerlink" title="CPU超时以及超内存应对"></a>CPU超时以及超内存应对</h4><ul><li><strong>慎用异常</strong></li></ul><p>异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace()的本地同步方法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。</p><p>本次bug是由于递归深度过深导致的下面这条数据超内存且超时，尝试了很多提高性能的方法均不奏效，于是被迫更改递归思路</p><p><code>0(((((((((((x^8)^8)^8)^8)^8)^8)^8)^8)^8)^8)^8)^8</code></p><p>原思路如下，没读到一个因子就根据其次数向项中加入对应数量的因子，后续会导致递归不断深入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">for</span> (<span class="hljs-type">BigInteger</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> BigInteger.ZERO; i.compareTo(factor.getExponent()) &lt; <span class="hljs-number">0</span>;<br>     i = i.add(BigInteger.ONE)) &#123;<br>    term.addFactor(factor);<br>&#125;<br></code></pre></td></tr></table></figure><p>更改后，在转换为多项式时根据次数乘上对应因子，极大简化了对应的递归深度。</p><p>至于Main中的更改，原因在于我采用的是解析<code>String</code>类型字符串再<code>ToString</code>实现替换的功能，当没有需要替换的的函数时就只需要解析一次。综上实现了超内存和超时的问题。</p><p>综上，递归解决问题中，如何保证递归的深度不会太深是我们必须需要思考的问题。</p><h3 id="5-hack经历"><a href="#5-hack经历" class="headerlink" title="5. hack经历"></a>5. hack经历</h3><p>hack时主要还是通过评测机进行初查，但由于python的<code>sympy</code>包无法检测作业中的格式问题，最终主要还是人力排查格式问题，本次通过exp((-x))格式错误hack成功一次。</p><h2 id="三、第三次作业"><a href="#三、第三次作业" class="headerlink" title="三、第三次作业"></a>三、第三次作业</h2><h4 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h4><p>本次作业相比前两次代码量上有所减少，作业核心求导方面还是第一单元的核心思路递归下降解决。但是由于作业难度的加大以及迭代导致本次在debug方面耗费了大量的时间。</p><h4 id="1-代码UML框架-2"><a href="#1-代码UML框架-2" class="headerlink" title="1.代码UML框架"></a>1.代码UML框架</h4><p><img src="UML1.3.png" alt="UML1.3"></p><p>增加了求导函数因子，求导过程主要是转化为<code>String</code>类型递归实现。但是注意指数函数（<del>血的教训</del>）的求导如下：</p><p>$dx(exp((expr))^n) = n<em>dx(expr)</em>(exp((expr))^n)$</p><h4 id="2-作业体会-1"><a href="#2-作业体会-1" class="headerlink" title="2. 作业体会"></a>2. 作业体会</h4><p><code>derivation()</code>求导函数和<code>toString()</code>类似返回String类型，采用递归下降思路，此外无较大改动。</p><h4 id="3-hack经历"><a href="#3-hack经历" class="headerlink" title="3. hack经历"></a>3. hack经历</h4><p>本次hack过程，有了上次自己超时的经验，卡着代价函数通过下面数据卡了性能成功一次</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-number">0</span><br><span class="hljs-function"><span class="hljs-title">dx</span>(<span class="hljs-title">exp</span>(<span class="hljs-title">exp</span>(<span class="hljs-title">exp</span>(<span class="hljs-title">exp</span>(<span class="hljs-title">exp</span>(<span class="hljs-title">exp</span>(<span class="hljs-title">exp</span>(<span class="hljs-title">exp</span>(<span class="hljs-variable">x</span>^<span class="hljs-number">2</span>)))))))))</span><br></code></pre></td></tr></table></figure><h4 id="4-输出优化"><a href="#4-输出优化" class="headerlink" title="4. 输出优化"></a>4. 输出优化</h4><p>关于输出优化我没做特别的提出exp内部的最小公因数和因式分解操作，但是通过<code>TreeMap&lt;BigInteger, HashMap&lt;Poly, BigInteger&gt;&gt; polyMap</code>的多项式储存方式，通过讨论指数和系数的值通过打表的方式，对于无指数函数多项式的优化几乎是最简形式。</p><h2 id="Unit1总结"><a href="#Unit1总结" class="headerlink" title="Unit1总结"></a>Unit1总结</h2><p>第一单元的核心是解析表达式，总体处理思路是递归下降构建语法树，总体代码规模如下，为了便于理解，我将Factor抽象为父类，里面实现一些因子类的通用方法，并将所有的因子都对应创建的一个子类从而实现不同的<code>toString(),derivation(),toPoly</code>方法。</p><h4 id="1-代码规模以及复杂度"><a href="#1-代码规模以及复杂度" class="headerlink" title="1.代码规模以及复杂度"></a>1.代码规模以及复杂度</h4><p><img src="codeNum.png" alt="codeNum"></p><p>通过与他人对比，发现个人的代码规模还是比较庞大的，主要在于部分类的抽象程度还是不够高，将对应因子以及各类处理都写成了对应的类——因此可以提高抽象程度，例如Expr作为Factor接口下的实例。优点：理解起来较为容易，更改增加新功能较为容易。缺点：随着代码的迭代，增添的代码量相比会更加多。</p><p>复杂度如下：</p><ul><li><strong>OCavg</strong> : 每个类中所有非抽象方法的平均圈复杂度(继承的方法不计算在内)。</li><li><strong>OCmax</strong> : 每个类中非抽象方法的最大圈复杂度(继承的方法不计算在内)。</li><li><strong>WMC</strong> : 每个类中方法的总圈复杂度.</li></ul><div class="table-container"><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>MainClass</td><td>2</td><td>2</td><td>2</td></tr><tr><td>analysis.Lexer</td><td>4</td><td>16</td><td>36</td></tr><tr><td>analysis.Parser</td><td>2.75</td><td>7</td><td>33</td></tr><tr><td>analysis.Token</td><td>1</td><td>1</td><td>4</td></tr><tr><td>analysis.Token.Type</td><td>n/a</td><td>n/a</td><td>0</td></tr><tr><td>definefunction.DefineFunction</td><td>1</td><td>1</td><td>7</td></tr><tr><td>definefunction.FunctionList</td><td>2.8</td><td>8</td><td>14</td></tr><tr><td>expression.DefineFuncFactor</td><td>2.33</td><td>5</td><td>7</td></tr><tr><td>expression.DerivationFactor</td><td>1</td><td>1</td><td>4</td></tr><tr><td>expression.ExpFuncFactor</td><td>1.75</td><td>2</td><td>7</td></tr><tr><td>expression.Expr</td><td>2</td><td>3</td><td>10</td></tr><tr><td>expression.ExprFactor</td><td>2</td><td>3</td><td>8</td></tr><tr><td>expression.Factor</td><td>1</td><td>1</td><td>6</td></tr><tr><td>expression.NumFactor</td><td>1</td><td>1</td><td>4</td></tr><tr><td>expression.Term</td><td>2.86</td><td>8</td><td>20</td></tr><tr><td>expression.VarFactor</td><td>1.5</td><td>2</td><td>6</td></tr><tr><td>gather.Monomial</td><td>1.43</td><td>3</td><td>10</td></tr><tr><td>gather.Poly</td><td>4.13</td><td>14</td><td>62</td></tr><tr><td>pre.Treatment</td><td>2</td><td>5</td><td>12</td></tr></tbody></table></div><h4 id="2-调试闹鬼现象的分析"><a href="#2-调试闹鬼现象的分析" class="headerlink" title="2.调试闹鬼现象的分析"></a>2.调试闹鬼现象的分析</h4><p>通过讨论区即自己学习，后续作业中可以选择遵循Command与Query分离原则，即命令型方法无返回值，查询型方法不修改字段，不对形参进行副作用操作。</p><h4 id="3-作业感想"><a href="#3-作业感想" class="headerlink" title="3.作业感想"></a>3.作业感想</h4><p>关于第一次作业，开学第一天就被狠狠上强度，被迫开始速通OO，第二次作业中由于自己测试时没有充分考虑运行时间，所以强测寄了一个点，后续大改后，加上第三次作业较为简单，没出啥问题。</p><p>最后，未来建议互测小房间可不可以及时给出被hack的点（出现超时问题需要重构好及时构想，待到下一次作业布置两手抓真的不知道咋办）。</p>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象OO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA_CO_P7设计文稿</title>
    <link href="/2024/01/01/BUAA-CO-P7%E8%AE%BE%E8%AE%A1%E6%96%87%E7%A8%BF/"/>
    <url>/2024/01/01/BUAA-CO-P7%E8%AE%BE%E8%AE%A1%E6%96%87%E7%A8%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="P7CPU设计文稿"><a href="#P7CPU设计文稿" class="headerlink" title="P7CPU设计文稿"></a>P7CPU设计文稿</h1><h2 id="1-总体架构"><a href="#1-总体架构" class="headerlink" title="1.总体架构"></a>1.总体架构</h2><p><img src="Structure.png" alt="Structure"></p><p><strong>任务清单</strong></p><p>新增指令：<strong>mfc0,</strong> <strong>mtc0,</strong> <strong>eret,</strong> <strong>syscall</strong></p><p>P7 与之前的 project 相比，涉及的内容较多，所以在实现的时候很容易手忙脚乱，这里列出完成 P7 需要的事宜：</p><div class="table-container"><table><thead><tr><th style="text-align:left">任务</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">计时器</td><td style="text-align:left">课程组提供实现代码，只需要结合代码和文档理解应用即可。</td></tr><tr><td style="text-align:left">系统桥</td><td style="text-align:left">为 CPU 提供统一的访问外设的接口，需要按规格自行实现。</td></tr><tr><td style="text-align:left">协处理器 CP0</td><td style="text-align:left">设置 CPU 的异常处理功能，反馈 CPU 的异常信息，需要按规格自行实现。</td></tr><tr><td style="text-align:left">内部异常检测与流水</td><td style="text-align:left">CPU 需要具有可以检测内部指令执行错误的能力。</td></tr><tr><td style="text-align:left">外部中断响应</td><td style="text-align:left">CPU 需要具有初步响应外部中断信号的能力。</td></tr><tr><td style="text-align:left">异常处理指令</td><td style="text-align:left">在异常处理程序中，会有一些特殊的指令需要实现。</td></tr><tr><td style="text-align:left">单周期 CPU 的封装</td><td style="text-align:left">让 CPU 从外部看上去是一个单周期 CPU。</td></tr><tr><td style="text-align:left">异常处理程序</td><td style="text-align:left">利用 MARS 编写简单的异常处理程序用于测试。</td></tr></tbody></table></div><p><img src="p6cpu.jpg" alt="p6CPU"></p><h2 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2.具体实现"></a>2.具体实现</h2><h3 id="1-CP0"><a href="#1-CP0" class="headerlink" title="1.CP0"></a>1.CP0</h3><p>将CP0置于M级，故宏观PC为M级对于PC</p><p> CP0 的端口声明如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">端口</th><th style="text-align:left">方向</th><th style="text-align:left">位数</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">clk</td><td style="text-align:left">I</td><td style="text-align:left">1</td><td style="text-align:left">时钟信号。</td></tr><tr><td style="text-align:left">reset</td><td style="text-align:left">I</td><td style="text-align:left">1</td><td style="text-align:left">复位信号。</td></tr><tr><td style="text-align:left">en</td><td style="text-align:left">I</td><td style="text-align:left">1</td><td style="text-align:left">写使能信号。</td></tr><tr><td style="text-align:left">CP0Addr</td><td style="text-align:left">I</td><td style="text-align:left">5</td><td style="text-align:left">寄存器地址。</td></tr><tr><td style="text-align:left">CP0In</td><td style="text-align:left">I</td><td style="text-align:left">32</td><td style="text-align:left">CP0 写入数据。</td></tr><tr><td style="text-align:left">CP0Out</td><td style="text-align:left">O</td><td style="text-align:left">32</td><td style="text-align:left">CP0 读出数据。</td></tr><tr><td style="text-align:left">VPC</td><td style="text-align:left">I</td><td style="text-align:left">32</td><td style="text-align:left">受害 PC。</td></tr><tr><td style="text-align:left">BDIn</td><td style="text-align:left">I</td><td style="text-align:left">1</td><td style="text-align:left">是否是延迟槽指令。</td></tr><tr><td style="text-align:left">ExcCodeIn</td><td style="text-align:left">I</td><td style="text-align:left">5</td><td style="text-align:left">记录异常类型。</td></tr><tr><td style="text-align:left">HWInt</td><td style="text-align:left">I</td><td style="text-align:left">6</td><td style="text-align:left">输入中断信号。</td></tr><tr><td style="text-align:left">EXLClr</td><td style="text-align:left">I</td><td style="text-align:left">1</td><td style="text-align:left">用来复位 EXL。</td></tr><tr><td style="text-align:left">EPCOut</td><td style="text-align:left">O</td><td style="text-align:left">32</td><td style="text-align:left">EPC 的值。</td></tr><tr><td style="text-align:left">Req</td><td style="text-align:left">O</td><td style="text-align:left">1</td><td style="text-align:left">进入处理程序请求。</td></tr></tbody></table></div><p>CP0位置确定</p><h3 id="2-约定"><a href="#2-约定" class="headerlink" title="2.约定"></a>2.约定</h3><ol><li>如果发生异常的指令是延迟槽指令，那么返回程序时仍然返回这条指令所属的跳转指令。也就是说“异常延迟槽回到跳转”。</li><li>如果发生异常的指令是跳转指令，那么我们要求执行完延迟槽。</li><li>如果发生异常的指令是乘除指令的下一条，乘除指令不被撤回。也就是对于 M错误指令，W乘除指令 的情况，此时乘除槽正在计算，本来在异常处理时可能会覆盖乘除槽的结果，但是我们约定不会这么做。但是注意，如果是 E乘除指令，M错误指令，你要保证乘除指令不执行。</li></ol><p><strong>范围约定</strong></p><p><img src="strict.png" alt="strict"></p><h3 id="3-中断异常"><a href="#3-中断异常" class="headerlink" title="3.中断异常"></a>3.中断异常</h3><p><strong>中断异常约束</strong></p><ul><li><p>异常入口：《SMRL》的表 5.1 中定义了 MIPS 的异常入口，但考虑到简化设计以及与 MARS 保持一致，我们只支持 0x4180 一个入口地址，所有异常与中断都将从这里进入。</p></li><li><p>嵌套中断异常：本实验不要求支持中断异常嵌套的情况。</p></li><li><p>优先级：中断优先级高于异常优先级，即当有异常提交至 CP0 寄存器时，若有中断发生，则硬件应先响应中断，并重新执行受害指令及其后续指令；若没有中断发生，则处理异常。</p></li><li><p>精确异常：</p><ul><li><p>除下面的情况外，对所有中断异常的处理都应遵循精确异常的处理规则。</p></li><li><p>在进入中断或异常状态时，如果受害指令及其后续指令</p><p>已经改变</p><p>了 MDU 的状态，则无需恢复。假设 CP0 在 M 级，MDU 在 E 级，考虑以下情况：</p><ul><li><code>mult</code> 在 E 级启动了乘法运算，流水到 M 级时产生了中断，此时无需停止乘法计算，其它乘除法指令同理。</li><li><code>mthi</code> 在 E 级修改了 HI 寄存器，流水到 M 级时产生了中断，此时无需恢复 HI 寄存器的值，<code>mtlo</code> 同理。</li><li><code>mult</code> 在 E 级，受害指令在 M 级，此时还未改变 MDU 状态，不应开始乘法计算，其它乘除法指令同理。</li><li><code>mthi</code> 在 E 级，受害指令在 M 级，此时还未改变 MDU 状态，不应修改 HI 寄存器的值，<code>mtlo</code> 同理。</li></ul></li></ul></li><li><p>中断规范：</p><ul><li>Timer0 输出的中断信号接入 HWInt[0] (最低中断位)，Timer1 输出的中断信号接入 HWInt[1]，来自中断发生器的中断信号接入 HWInt[2]。</li><li>规定中断产生时的受害指令为宏观 PC 对应的指令，此时应将宏观 PC 写入 EPC。</li></ul></li><li><p>MIPS 微系统需要支持的异常：</p><p>| ExcCode | 助记符  | 描述                                             |<br>| :——— | :——— | :———————————————————————- |<br>| 0       | Int     | 中断。                                           |<br>| 4       | AdEL    | 取数或取指时地址错误。                           |<br>| 5       | AdES    | 存数时地址错误。                                 |<br>| 8       | Syscall | 系统调用。                                       |<br>| 10      | RI      | 不认识的（或者非法的）指令码。                   |<br>| 12      | Ov      | 自陷形式的整数算术指令（例如 <code>add</code>）导致的溢出。 |</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">异常与中断码</th><th style="text-align:left">助记符与名称</th><th style="text-align:left">指令与指令类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left"><code>Int</code> （外部中断）</td><td style="text-align:left">所有指令</td><td style="text-align:left">中断请求，来源于计时器与外部中断。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><code>AdEL</code> （取指异常）</td><td style="text-align:left">所有指令</td><td style="text-align:left">PC 地址未字对齐。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">PC 地址超过 <code>0x3000 ~ 0x6ffc</code>。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>AdEL</code> （取数异常）</td><td style="text-align:left"><code>lw</code></td><td style="text-align:left">取数地址未与 4 字节对齐。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"><code>lh</code></td><td style="text-align:left">取数地址未与 2 字节对齐。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"><code>lh</code>, <code>lb</code></td><td style="text-align:left">取 Timer 寄存器的值。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">load 型指令</td><td style="text-align:left">计算地址时加法溢出。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">load 型指令</td><td style="text-align:left">取数地址超出 DM、Timer0、Timer1、中断发生器的范围。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><code>AdES</code> （存数异常）</td><td style="text-align:left"><code>sw</code></td><td style="text-align:left">存数地址未 4 字节对齐。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"><code>sh</code></td><td style="text-align:left">存数地址未 2 字节对齐。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"><code>sh</code>, <code>sb</code></td><td style="text-align:left">存 Timer 寄存器的值。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">store 型指令</td><td style="text-align:left">计算地址加法溢出。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">store 型指令</td><td style="text-align:left">向计时器的 Count 寄存器存值。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">store 型指令</td><td style="text-align:left">存数地址超出 DM、Timer0、Timer1、中断发生器的范围。</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><code>Syscall</code> （系统调用）</td><td style="text-align:left"><code>syscall</code></td><td style="text-align:left">系统调用。</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><code>RI</code>（未知指令）</td><td style="text-align:left"></td><td style="text-align:left">未知的指令码。</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><code>Ov</code>（溢出异常）</td><td style="text-align:left"><code>add</code>, <code>addi</code>, <code>sub</code></td><td style="text-align:left">算术溢出。</td></tr></tbody></table></div><h3 id="4-eret指令"><a href="#4-eret指令" class="headerlink" title="4.eret指令"></a>4.eret指令</h3><p>eret 将保存在 CP0 的 EPC 寄存器中的现场(被中断指令的下一条地址)写入 PC，从而实现从中断、 异常或指令执行错误的处理程序中返回</p><h2 id="3-思考题"><a href="#3-思考题" class="headerlink" title="3.思考题"></a>3.思考题</h2><h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h3><p>1、请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？</p><p>2、请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）</p><p>3、为何与外设通信需要 Bridge？</p><p>4、请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。</p><p>5、倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？</p><p>6、为什么 <code>jalr</code> 指令为什么不能写成 <code>jalr $31, $31</code>？</p><h3 id="2-答案"><a href="#2-答案" class="headerlink" title="2.答案"></a>2.答案</h3><ol><li><p>鼠标和键盘的输入信号是通过它们的接口（例如 USB）发送给计算机的主板。主板上的输入/输出控制器会将这些信号转换成数字信号，然后发送给中央处理器（CPU）。CPU会解析这些信号并根据用户的操作来执行相应的指令。IO设备的输入输出有好几种方式，键盘、鼠标这类的低速设备是通过中断请求的方式进行IO操作的。即当键盘上按下一个按键的时候，键盘会发出一个中断信号，中断信号经过中断控制器传到CPU，然后CPU根据不同的中断号执行不同的中断响应程序，然后进行相应的IO操作，把按下的按键编码读到寄存器（或者鼠标的操作），最后放入内存中。</p></li><li><p>保证设计的统一性，即通过协议保证接口更加兼容。用户使用自定义处理可能出现不兼容的问题</p></li><li><p>正如教程所说，系统桥是连接 CPU 和外设的功能设备，它会给 CPU 提供一种接口，使得 CPU 可以像读写普通存储器一样（即按地址读写）来读写复杂多变的外设，不用管数据是从哪来，怎么来，只用发挥CPU本身功能就可以。系统桥统一且简化了 CPU 的对外接口，CPU 不必为每种外设单独提供接口，符合高内聚，低耦合的设计思想。</p></li><li><p>模式0通常用于产生定时中断  ,当计数器倒计数为 0 后，计数器停止计数，Ctrl 寄存器的计数使能自动变为 0，并且中断信号始终保持有效，直到屏蔽中断或重新开始计数。</p><p><img src="mode0.jpg" alt="mode0"></p><p>模式1当计数器倒计数为 0 后， 初值寄存器值被自动加载至计数器， 计数器继续倒计数。模式 1 通常用于产生周期性脉冲</p><p><img src="mode1.jpg" alt="mode1"></p></li><li><p>会导致宏观PC突然为0或者为x。在清空流水线的时候，应该保留PC信息。</p></li><li><p>PC &lt;- GPR[rs]和GPR[rd] &lt;- PC + 4的进行顺序未知，存在二义</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成CO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA_CO_P5和P6CPU设计文稿</title>
    <link href="/2024/01/01/BUAA-CO-P5%E5%92%8CP6CPU%E8%AE%BE%E8%AE%A1%E6%96%87%E7%A8%BF/"/>
    <url>/2024/01/01/BUAA-CO-P5%E5%92%8CP6CPU%E8%AE%BE%E8%AE%A1%E6%96%87%E7%A8%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="P5——CPU设计文稿"><a href="#P5——CPU设计文稿" class="headerlink" title="P5——CPU设计文稿"></a>P5——CPU设计文稿</h1><h2 id="1-总示意图"><a href="#1-总示意图" class="headerlink" title="1.总示意图"></a>1.总示意图</h2><p><img src="p5cpu.jpg" alt="p5CPU"></p><h2 id="2-命名规范"><a href="#2-命名规范" class="headerlink" title="2.命名规范"></a>2.命名规范</h2><p>1.模块以及接口加上各级前缀</p><p>2.属于某模块在级后面在加模块名</p><h2 id="3-模块定义"><a href="#3-模块定义" class="headerlink" title="3.模块定义"></a>3.模块定义</h2><h3 id="1）Datapath"><a href="#1）Datapath" class="headerlink" title="1）Datapath"></a>1）Datapath</h3><h4 id="1、E-ALU模块"><a href="#1、E-ALU模块" class="headerlink" title="1、E_ALU模块"></a>1、E_ALU模块</h4><p>同指导书，改为case来操作</p><div class="table-container"><table><thead><tr><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">E_ALU_A [31 : 0]</td><td style="text-align:center">I</td><td style="text-align:left">32位输入信号</td></tr><tr><td style="text-align:center">E_ALU_B [31 : 0]</td><td style="text-align:center">I</td><td style="text-align:left">32位输入信号</td></tr><tr><td style="text-align:center">E_ALU_Shamt [4 : 0]</td><td style="text-align:center">I</td><td style="text-align:left">五位输入信号</td></tr><tr><td style="text-align:center">E_ALUop [2 : 0]</td><td style="text-align:center">I</td><td style="text-align:left">操作选择控制    <br>E_ALUop == 3’b000 A +B；<br>E_ALUop == 3’b001 A - B;<br>E_ALUop == 3’b010 A \</td><td>B; <br>E_ALUop == 3’b011 A &amp; B;<br>E_ALUop == 3’b100 B左移Shamt位<br>E_ALUop == 3’b101 B加载到高位</td></tr><tr><td style="text-align:center">E_ALU_Result [31 : 0]</td><td style="text-align:center">O</td><td style="text-align:left">32位输出信号</td></tr></tbody></table></div><h4 id="2、D-CMP模块"><a href="#2、D-CMP模块" class="headerlink" title="2、D_CMP模块"></a>2、D_CMP模块</h4><p>从原来的ALU模块分离出来到译码阶段</p><div class="table-container"><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>D_CMP_A [31: 0]</td><td>I</td><td>32位输入</td></tr><tr><td>D_CMP_B [31: 0]</td><td>I</td><td>32位输入</td></tr><tr><td>D_CMP_Equal</td><td>O</td><td>相等 ？ 1  ：0</td></tr><tr><td>D_CMP_Less</td><td>O</td><td>小于 ？ 1  ：0</td></tr><tr><td>D_CMP_Greater</td><td>O</td><td>大于 ？ 1 ： 0</td></tr></tbody></table></div><h4 id="3、E-EXT模块"><a href="#3、E-EXT模块" class="headerlink" title="3、E_EXT模块"></a>3、E_EXT模块</h4><div class="table-container"><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>D_EXT_Imm [15: 0 ]</td><td>I</td><td>16位待扩展立即数</td></tr><tr><td>D_EXTop [1:0]</td><td>I</td><td>扩展选择<br>D_EXTop == 2’b00 符号扩展<br>D_EXTop == 2’b01 无符号扩展</td></tr><tr><td>D_EXT_Result [31:0]</td><td>O</td><td>扩展结果</td></tr></tbody></table></div><h4 id="4、F-PC模块"><a href="#4、F-PC模块" class="headerlink" title="4、F_PC模块"></a>4、F_PC模块</h4><div class="table-container"><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>F_PC_clk</td><td>I</td><td>时钟信号</td></tr><tr><td>F_PC_reset</td><td>I</td><td>复位信号</td></tr><tr><td>F_PC_en</td><td>I</td><td>使能信号</td></tr><tr><td>F_PC_ NPC [31:0]</td><td>I</td><td>32位输入信号</td></tr><tr><td>F_PC_PC [31:0]</td><td>O</td><td>输出信号</td></tr></tbody></table></div><h4 id="5、F-IM模块"><a href="#5、F-IM模块" class="headerlink" title="5、F_IM模块"></a>5、F_IM模块</h4><div class="table-container"><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>F_IM_PC [31:0]</td><td>I</td><td>32位取址信号</td></tr><tr><td>F_IM_Instr [31 :0]</td><td>O</td><td>32位结果</td></tr></tbody></table></div><h4 id="6、D-NPC模块"><a href="#6、D-NPC模块" class="headerlink" title="6、D_NPC模块"></a>6、D_NPC模块</h4><div class="table-container"><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>D_NPC_PC[31:0]</td><td>I</td><td>32位PC信号</td></tr><tr><td>D_NPC_Imm[26:0]</td><td>I</td><td>26位立即数地址</td></tr><tr><td>D_NPC_RA[31:0]</td><td>I</td><td>$RA</td></tr><tr><td>D_NPC_Branch[2 :0]</td><td>I</td><td>对应不同Branch<br>3’b000表示不是Branch<br>若为3’b001对应beq</td></tr><tr><td>D_NPC_J</td><td>I</td><td>对应J跳转指令</td></tr><tr><td>D_NPC_JR</td><td>I</td><td>对应Jr跳转指令</td></tr><tr><td>D_NPC_Equal</td><td>I</td><td>比较结果</td></tr><tr><td>D_NPC_Great</td><td>I</td><td>比较结果</td></tr><tr><td>D_NPC_Less</td><td>I</td><td>比较结果</td></tr><tr><td>D_NPC_NPC[31:0]</td><td>O</td><td></td></tr><tr><td>D_Jump</td><td>O</td><td>判断地址是否跳转</td></tr></tbody></table></div><h4 id="7、D-GRF模块"><a href="#7、D-GRF模块" class="headerlink" title="7、D_GRF模块"></a>7、D_GRF模块</h4><div class="table-container"><table><thead><tr><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">D_GRF_A1 [4:0]</td><td style="text-align:center">I</td><td style="text-align:left">5位地址输入信号，输入rs指定的寄存器并将其结果读出到RD1</td></tr><tr><td style="text-align:center">D_GRF_A2 [4:0]</td><td style="text-align:center">I</td><td style="text-align:left">5位地址输入信号，输入rt指定的寄存器并将其结果读出到RD2</td></tr><tr><td style="text-align:center">D_GRF_A3 [4:0]</td><td style="text-align:center">I</td><td style="text-align:left">5位地址输入信号，输入rd指定的寄存器并将WD写入</td></tr><tr><td style="text-align:center">D_GRF_WD [31:0]</td><td style="text-align:center">I</td><td style="text-align:left">32位输入信号</td></tr><tr><td style="text-align:center">D_GRF_clk</td><td style="text-align:center">I</td><td style="text-align:left">时钟信号</td></tr><tr><td style="text-align:center">D_GRF_reset</td><td style="text-align:center">I</td><td style="text-align:left">异步复位信号</td></tr><tr><td style="text-align:center">D_GRF_WE</td><td style="text-align:center">I</td><td style="text-align:left">使能信号</td></tr><tr><td style="text-align:center">D_GRF_RD1 [31:0]</td><td style="text-align:center">O</td><td style="text-align:left">输出A1指定寄存器的32位数据</td></tr><tr><td style="text-align:center">D_GRF_RD2 [31:0]</td><td style="text-align:center">O</td><td style="text-align:left">输出A2指定寄存器的32位数据</td></tr></tbody></table></div><h4 id="8、M-DM模块"><a href="#8、M-DM模块" class="headerlink" title="8、M_DM模块"></a>8、M_DM模块</h4><div class="table-container"><table><thead><tr><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">M_DM_clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">M_DM_reset</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">M_Mem_Write</td><td style="text-align:center">I</td><td style="text-align:center">写信号</td></tr><tr><td style="text-align:center">M_signed</td><td style="text-align:center">I</td><td style="text-align:center">输出是否符号位扩展信号</td></tr><tr><td style="text-align:center">Size</td><td style="text-align:center">I</td><td style="text-align:center">决定是字、半字、字节</td></tr><tr><td style="text-align:center">M_ALU_Result[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">储存地址</td></tr><tr><td style="text-align:center">M_WriteData[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">储存数据</td></tr><tr><td style="text-align:center">M_PC[31:0]]</td><td style="text-align:center">I</td><td style="text-align:center">PC</td></tr><tr><td style="text-align:center">M_Read_Data</td><td style="text-align:center">O</td><td style="text-align:center">load结果</td></tr></tbody></table></div><h4 id="9、Controller"><a href="#9、Controller" class="headerlink" title="9、Controller"></a>9、Controller</h4><p>根据名称要求更改，采取重构</p><div class="table-container"><table><thead><tr><th style="text-align:center">信号名</th><th style="text-align:center">方向</th></tr></thead><tbody><tr><td style="text-align:center">opcode[5:0]</td><td style="text-align:center">I</td></tr><tr><td style="text-align:center">funct[5:0]</td><td style="text-align:center">I</td></tr><tr><td style="text-align:center">D_EXTop [1:0]</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">D_NPC_Branch [2:0]</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">D_NPC_J</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">D_NPC_JR</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">E_Reg_Dst [1:0]</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">E_ALU_Src [1:0]</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">E_ALUop [2:0]</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">M_Mem_Write</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">M_DM_Size[1:0]</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">M_Signed</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">W_MemtoReg [1:0]</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">W_RegWrite</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">D_Rs_Tuse</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">D_Rt_Tuse</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">D_Tnew</td><td style="text-align:center">O</td></tr></tbody></table></div><p>其真值表对应如下，同时改为case结构，代码长度显著增加，但便于debug</p><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th>D_EXTop[1:0]</th><th>D_NPC_Branch[2:0]</th><th>D_NPC_J</th><th>D_NPC_JR</th><th>D_Reg_Dst[1:0]</th><th>E_ALU_Src[1:0]</th><th>E_ALUop[2:0]</th><th>M_Mem_Write</th><th>M_DM_Size[1:0]</th><th>M_signed</th><th>W_MemtoReg[1:0]</th><th>W_RegWrite</th></tr></thead><tbody><tr><td style="text-align:center">Add</td><td>00</td><td>000</td><td>0</td><td>0</td><td>01</td><td>00</td><td>000</td><td>0</td><td>00</td><td>0</td><td>01</td><td>1</td></tr><tr><td style="text-align:center">Sub</td><td>00</td><td>000</td><td>0</td><td>0</td><td>01</td><td>00</td><td>001</td><td>0</td><td>00</td><td>0</td><td>01</td><td>1</td></tr><tr><td style="text-align:center">Jr</td><td>00</td><td>000</td><td>0</td><td>1</td><td>00</td><td>00</td><td>000</td><td>0</td><td>00</td><td>0</td><td>00</td><td>0</td></tr><tr><td style="text-align:center">Ori</td><td>01</td><td>000</td><td>0</td><td>0</td><td>00</td><td>01</td><td>010</td><td>0</td><td>00</td><td>0</td><td>01</td><td>1</td></tr><tr><td style="text-align:center">Lw</td><td>00</td><td>000</td><td>0</td><td>0</td><td>00</td><td>01</td><td>000</td><td>0</td><td>00</td><td>0</td><td>00</td><td>1</td></tr><tr><td style="text-align:center">Sw</td><td>00</td><td>000</td><td>0</td><td>0</td><td>00</td><td>01</td><td>000</td><td>1</td><td>00</td><td>0</td><td>00</td><td>0</td></tr><tr><td style="text-align:center">Beq</td><td>00</td><td>001</td><td>0</td><td>0</td><td>00</td><td>00</td><td>000</td><td>0</td><td>00</td><td>0</td><td>00</td><td>0</td></tr><tr><td style="text-align:center">Lui</td><td>00</td><td>000</td><td>0</td><td>0</td><td>00</td><td>01</td><td>101</td><td>0</td><td>00</td><td>0</td><td>01</td><td>1</td></tr><tr><td style="text-align:center">J</td><td>00</td><td>000</td><td>1</td><td>0</td><td>00</td><td>00</td><td>00</td><td>0</td><td>00</td><td>0</td><td>00</td><td>0</td></tr><tr><td style="text-align:center">Jal</td><td>00</td><td>000</td><td>1</td><td>0</td><td>10</td><td>01</td><td>000</td><td>0</td><td>00</td><td>0</td><td>10</td><td>1</td></tr></tbody></table></div><h3 id="2）RiskUnit-冒险处理"><a href="#2）RiskUnit-冒险处理" class="headerlink" title="2）RiskUnit 冒险处理"></a>2）RiskUnit 冒险处理</h3><p>D_Tuse与D_Tnew表格，每次走过一个寄存器，T_new都会减一</p><p>Tuse&lt;Tnew 暂停</p><p>对不需要使用寄存器的Tuse置最大值。</p><p>注意：不转发0</p><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">D_Rs_Tuse</th><th style="text-align:center">D_Rt_Tuse</th><th style="text-align:center">D_Tnew</th></tr></thead><tbody><tr><td style="text-align:center">Add</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Sub</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Jr</td><td style="text-align:center">0</td><td style="text-align:center">M</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Ori</td><td style="text-align:center">1</td><td style="text-align:center">M</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Lw</td><td style="text-align:center">1</td><td style="text-align:center">M</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">Sw</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Beq</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Lui</td><td style="text-align:center">M</td><td style="text-align:center">M</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">J</td><td style="text-align:center">M</td><td style="text-align:center">M</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Jal</td><td style="text-align:center">M</td><td style="text-align:center">M</td><td style="text-align:center">2</td></tr></tbody></table></div><h2 id="4-测试数据"><a href="#4-测试数据" class="headerlink" title="4.测试数据"></a>4.测试数据</h2><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-string">`0x0000000000000000:  34 1C 00 00    ori <span class="hljs-variable">$gp</span>, <span class="hljs-variable">$zero</span>, 0`</span> <br><br><span class="hljs-string">`0x0000000000000004:  34 1D 00 00    ori <span class="hljs-variable">$sp</span>, <span class="hljs-variable">$zero</span>, 0`</span> <br><br><span class="hljs-string">`0x0000000000000008:  34 01 10 10    ori <span class="hljs-variable">$at</span>, <span class="hljs-variable">$zero</span>, 0x1010`</span> <br><br><span class="hljs-string">`0x000000000000000c:  3C 02 87 23    lui <span class="hljs-variable">$v0</span>, 0x8723`</span> <br><br><span class="hljs-string">`0x0000000000000010:  34 03 78 56    ori <span class="hljs-variable">$v1</span>, <span class="hljs-variable">$zero</span>, 0x7856`</span> <br><br><span class="hljs-string">`0x0000000000000014:  3C 04 85 FF    lui <span class="hljs-variable">$a0</span>, 0x85ff`</span> <br><br><span class="hljs-string">`0x0000000000000018:  34 05 00 01    ori <span class="hljs-variable">$a1</span>, <span class="hljs-variable">$zero</span>, 1`</span> <br><br><span class="hljs-string">`0x000000000000001c:  3C 06 FF FF    lui <span class="hljs-variable">$a2</span>, 0xffff`</span> <br><br><span class="hljs-string">`0x0000000000000020:  34 07 FF FF    ori <span class="hljs-variable">$a3</span>, <span class="hljs-variable">$zero</span>, 0xffff`</span> <br><br><span class="hljs-string">`0x0000000000000024:  00 22 08 20    add <span class="hljs-variable">$at</span>, <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v0</span>`</span> <br><br><span class="hljs-string">`0x0000000000000028:  00 23 48 20    add <span class="hljs-variable">$t1</span>, <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v1</span>`</span> <br><br><span class="hljs-string">`0x000000000000002c:  00 22 40 22    sub <span class="hljs-variable">$t0</span>, <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v0</span>`</span> <br><br><span class="hljs-string">`0x0000000000000030:  00 E0 00 22    sub <span class="hljs-variable">$zero</span>, <span class="hljs-variable">$a3</span>, <span class="hljs-variable">$zero</span>`</span> <br><br><span class="hljs-string">`0x0000000000000034:  13 91 00 03    beq <span class="hljs-variable">$gp</span>, <span class="hljs-variable">$s1</span>, 0x44`</span> <br><br><span class="hljs-string">`0x0000000000000038:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x000000000000003c:  10 00 00 15    b   0x94`</span> <br><br><span class="hljs-string">`0x0000000000000040:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x0000000000000044:  10 22 00 13    beq <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v0</span>, 0x94`</span> <br><br><span class="hljs-string">`0x0000000000000048:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x000000000000004c:  34 02 00 0C    ori <span class="hljs-variable">$v0</span>, <span class="hljs-variable">$zero</span>, 0xc`</span> <br><br><span class="hljs-string">`0x0000000000000050:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x0000000000000054:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x0000000000000058:  00 00 00 00    nop`</span> <br><br><span class="hljs-string">`0x000000000000005c:  0C 00 0C 1B    jal 0x306c`</span> <br><br><span class="hljs-string">`0x0000000000000060:  AC 41 00 00    sw  <span class="hljs-variable">$at</span>, (<span class="hljs-variable">$v0</span>)`</span> <br><br><span class="hljs-string">`0x0000000000000064:  10 00 00 0B    b   0x94`</span> <br><br><span class="hljs-string">`0x0000000000000068:  00 22 08 20    add <span class="hljs-variable">$at</span>, <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v0</span>`</span> <br><br><span class="hljs-string">`0x000000000000006c:  00 22 08 20    add <span class="hljs-variable">$at</span>, <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v0</span>`</span> <br><br><span class="hljs-string">`0x0000000000000070:  00 22 08 20    add <span class="hljs-variable">$at</span>, <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v0</span>`</span><br><br> <span class="hljs-string">`0x0000000000000074:  00 22 08 20    add <span class="hljs-variable">$at</span>, <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v0</span>`</span> <br><br><span class="hljs-string">`0x0000000000000078:  AC 5F 00 00    sw  <span class="hljs-variable">$ra</span>, (<span class="hljs-variable">$v0</span>)`</span> <br><br><span class="hljs-string">`0x000000000000007c:  8C 41 00 00    lw  <span class="hljs-variable">$at</span>, (<span class="hljs-variable">$v0</span>)`</span> <br><br><span class="hljs-string">`0x0000000000000080:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x0000000000000084:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x0000000000000088:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x000000000000008c:  00 20 00 08    jr  <span class="hljs-variable">$at</span>`</span> <br><br><span class="hljs-string">`0x0000000000000090:  AC 5F 00 00    sw  <span class="hljs-variable">$ra</span>, (<span class="hljs-variable">$v0</span>)`</span> <br><br><span class="hljs-string">`0x0000000000000094:  10 00 FF FF    b   0x94`</span> <br><br><span class="hljs-string">`0x0000000000000098:  00 00 00 00    nop`</span> <br></code></pre></td></tr></table></figure><h2 id="5-思考题"><a href="#5-思考题" class="headerlink" title="5.思考题"></a>5.思考题</h2><p>1.在D级就直接就直接计算出是否需要跳转，若需要发生跳转，由于NPC是组合逻辑，下一条指令的地址直接传出到PC模块，这样只会多读跳转指令下一条的指令，即使将分支判断提到 D 级，发生跳转的时候，F 级指令依然是需要作废的。但是我们如果约定 F 级指令不作废呢？也就是说，不论判断结果如何，我们都将执行分支或跳转指令的下一条指令。这也就是所谓的“<strong>延迟槽</strong>”。那么指令执行的效率就提高了。</p><p>2.Jal需要将jal下一条指令的位置写入$ra寄存器，由于延迟槽的地址是PC+4，所以实际应该写回PC +8了。</p><p>3.流水线中的各个阶段需要在特定的时钟周期内完成其任务。如果数据来自功能部件，可能会增加流水线的复杂性，导致更难以保持稳定的时序。通过限制数据转发只能来自寄存器，可以简化流水线的设计，提高稳定性。</p><p>4.当前 GPR 被写入的值会即时反馈到读取端上。具体的说，当读寄存器时的地址与同周期写寄存器的地址相同时，我们将读取的内容改为写寄存器的内容，而不是该地址可以索引到的寄存器文件中的值。这也就对应着图中的两个四选一多路选择器。利用冲突单元生成选择信号即可</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">assign</span> D_ForwardA = <br>    (D_Rs == M_Write_Reg &amp;&amp; M_MemtoReg == <span class="hljs-number">2&#x27;b01</span> &amp;&amp; M_Reg_Write == <span class="hljs-number">1&#x27;b1</span> &amp;&amp; M_Write_Reg != <span class="hljs-number">5&#x27;b00000</span>) ? `M_Data_ALU :<br>    (D_Rs == M_Write_Reg &amp;&amp; M_MemtoReg == <span class="hljs-number">2&#x27;b10</span> &amp;&amp; M_Reg_Write == <span class="hljs-number">1&#x27;b1</span> &amp;&amp; M_Write_Reg != <span class="hljs-number">5&#x27;b00000</span>) ? `M_Data_PC8 :<br>    (D_Rs == W_Write_Reg &amp;&amp; W_Reg_Write == <span class="hljs-number">1&#x27;b1</span>  &amp;&amp; W_Write_Reg != <span class="hljs-number">5&#x27;b00000</span>) ? `W_Data :<br>                                                `D_Data ;<br></code></pre></td></tr></table></figure><p>5.需求者：D级：CMP，E级：ALU</p><p>​    提供者：M级：ALU_Result,PC8</p><p>​                    W级：因为已经被选择过，过Writeback_Data就已经可以满足需求</p><p>6.大致可将指令分为三类</p><p>​    1）计算指令，主要对ALU模块进行增加操作，如Add指令</p><p>​    2）跳转指令，可能需要调整ALU模块或者NPC，由于这里是流水线，ALU模块的输出不能直接和单周期一样课上直接连在NPC模块，可能需要考虑在增加D级就增加符合跳转的运算</p><p>​    3）访存指令，DM中已经支持字、半字、字节的存取，根据题意做ALU，NPC等对应的增添即可</p><p>7.采取分散式译码</p><p>译码结果较易观察，且不容易产生bug，不同指令之间完全分离，缺点就是代码冗长。</p><p>选做2，采取交叉式出现</p><h1 id="P6——CPU"><a href="#P6——CPU" class="headerlink" title="P6——CPU"></a>P6——CPU</h1><p>支持指令：<strong>add,</strong> <strong>sub,</strong> <strong>and,</strong> <strong>or,</strong> <strong>slt,</strong> <strong>sltu,</strong> <strong>lui</strong> <strong>addi,</strong> <strong>andi,</strong> <strong>ori</strong> <strong>lb,</strong> <strong>lh,</strong> <strong>lw,</strong> <strong>sb,</strong> <strong>sh,</strong> <strong>sw</strong> <strong>mult,</strong> <strong>multu,</strong> <strong>div,</strong> <strong>divu,</strong> <strong>mfhi,</strong> <strong>mflo,</strong> <strong>mthi,</strong> <strong>mtlo</strong> <strong>beq,</strong> <strong>bne,</strong> <strong>jal,</strong> <strong>jr</strong></p><h2 id="1-模块定义"><a href="#1-模块定义" class="headerlink" title="1.模块定义"></a>1.模块定义</h2><p>增加E_MUDI乘除模块与M_DE模块，删除看F_IM与M_DM模块</p><h4 id="1、M-BE"><a href="#1、M-BE" class="headerlink" title="1、M_BE"></a>1、M_BE</h4><div class="table-container"><table><thead><tr><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">M_BE_A[1:0]</td><td style="text-align:center">I</td><td style="text-align:left">最低两位的地址</td></tr><tr><td style="text-align:center">M_BE_Din[31:0]</td><td style="text-align:center">I</td><td style="text-align:left">输入的 32 位数据</td></tr><tr><td style="text-align:center">M_BE_Op[2:0]</td><td style="text-align:center">I</td><td style="text-align:left">数据扩展控制码 000：<br>无扩展 001：无符号字节数据扩展 <br>010：符号字节数据扩展 <br>011：无符号半字数据扩展 <br>100：符号半字数据扩展</td></tr><tr><td style="text-align:center">M_BE_Dout[31:0]</td><td style="text-align:center">O</td><td style="text-align:left">扩展后的 32 位数据</td></tr></tbody></table></div><h4 id="2、E-MUDI"><a href="#2、E-MUDI" class="headerlink" title="2、E_MUDI"></a>2、E_MUDI</h4><div class="table-container"><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>E_MUDI_clk</td><td>I</td><td>时钟信号</td></tr><tr><td>E_MUDI_reset</td><td>I</td><td>复位信号</td></tr><tr><td>E_MUDI_A [31:0]</td><td>I</td><td>运算数据A</td></tr><tr><td>E_MUDI_B [31:0]</td><td>I</td><td>运算数据B</td></tr><tr><td>E_MUDI_Start</td><td>I</td><td>开始计算信号</td></tr><tr><td>E_MUDI_op [2:0]</td><td>I</td><td>运算选择信号</td></tr><tr><td>E_HI_Write</td><td>I</td><td>高位写信号</td></tr><tr><td>E_LO_Write</td><td>I</td><td>地位写信号</td></tr><tr><td>E_HI [31:0]</td><td>O</td><td>高位寄存器输出结果</td></tr><tr><td>E_LO[31:0]</td><td>O</td><td>低位寄存器输出结果</td></tr><tr><td>E_MUDI_Busy</td><td>O</td><td>计算中信号</td></tr></tbody></table></div><h2 id="2-总示意图"><a href="#2-总示意图" class="headerlink" title="2.总示意图"></a>2.总示意图</h2><p><img src="p6cpu.jpg" alt="p6CPU"></p><h2 id="3-思考题"><a href="#3-思考题" class="headerlink" title="3.思考题"></a>3.思考题</h2><p>1.乘除法运算效率远低于ALU内的各个计算，需要耗费大量时间，放在一起会大大拖慢效率，独立的HI、LO也是为了高效率，因为只有乘除法会用到高位寄存器，低位寄存器，与其他不一致，分开便于控制。</p><p>2.真实的流水线 CPU 使用乘法和除法指令来实现乘除法运算。在执行乘法和除法指令时，CPU会将操作数加载到寄存器中，然后通过一系列的算术逻辑单元(ALU)来进行乘法或除法计算。这些计算通常会在多个时钟周期内完成，因为乘法和除法是比较复杂的运算。乘法：乘法可以通过一系列的加法和移位来实现。处理器中的乘法单元通常包括：部分积生成器（Partial Product Generator）：将两个乘数的每一位相乘，生成部分积。部分积累加器（Partial Product Accumulator）： 将所有部分积相加，得到最终的乘积。这个过程可能需要多个时钟周期，因此在流水线中可能会有多个阶段用于处理不同的部分。除法：除法通常比乘法更为复杂，可能涉及到迭代的过程。处理器中的除法单元通常包括：部分商生成器（Partial Quotient Generator）： 生成每一位的部分商。部分商累加器（Partial Quotient Accumulator）： 将所有部分商相加，得到最终的商。这个过程同样可能需要多个时钟周期，并且可能需要进行多轮迭代来得到最终的结果。</p><p>在流水线中，这些乘法和除法的阶段可能被划分为多个子阶段，以便在每个时钟周期内执行一些部分操作。流水线的设计需要考虑到数据相关性、控制信号的传递以及流水线暂停和刷新等问题，以确保正确且高效地执行指令。</p><p>3.当且仅当Busy且指令为乘除有关的那八条指令时阻塞</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">assign</span> MUDI_Stall = (E_MUDI_Busy == <span class="hljs-number">1&#x27;b1</span>  || E_MUDI_Start == <span class="hljs-number">1&#x27;b1</span>) &amp;&amp; (D_MD_MT_MF == <span class="hljs-number">1&#x27;b1</span>) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br></code></pre></td></tr></table></figure><p>4.清晰性：每个字节的写分开，互不干扰，统一性：各个字节的控制信号仍然来自m_data_byteen[3:0]</p><p>5.不是，如果只实现按字使能，就不得不先读取值再进行更改，这样数据通路就延长了，导致效率下降。</p><p>6.对于选择信号以及条件尽可能实现宏定义来实现，避免出现6‘b100000这种无缘无故的常数，方便查找bug</p><p>7.连续的乘除有关的那八条指令，同3进行阻塞或者转发实现，测试数据</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t1</span> $<span class="hljs-built_in">t1</span> <span class="hljs-number">0x1234</span><br><span class="hljs-keyword">mult </span>$<span class="hljs-built_in">t0</span> $<span class="hljs-built_in">t1</span><br><span class="hljs-keyword">mfhi </span>$<span class="hljs-built_in">s0</span><br></code></pre></td></tr></table></figure><p>8.多增加连续的乘除有关的那八条指令，其余同P5构造</p><p><strong>{</strong>temp_hi<strong>,</strong> temp_lo<strong>}</strong> <strong>&lt;=</strong> <strong>{</strong>hi<strong>,</strong> lo<strong>}</strong> <strong>+</strong> $signed<strong>(</strong>$signed<strong>(64’d0</strong>) <strong>+</strong> $signed<strong>(</strong>rs<strong>)</strong> <strong>*</strong> $signed<strong>(</strong>rt<strong>));</strong></p>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成CO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FirstTest</title>
    <link href="/2023/12/15/FirstTest/"/>
    <url>/2023/12/15/FirstTest/</url>
    
    <content type="html"><![CDATA[<hr><p>这是我的第一篇博客，用于记录自己的学习过程。</p><p>下面是我创建过程中的一些tips</p><h6 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo n -p post <span class="hljs-built_in">dir</span>/post1<br></code></pre></td></tr></table></figure><p>通过这个指令会在<code>source/_post/dir</code>目录下创建<code>post1.md</code></p><h6 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h6><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure><p>这个指令启动本地服务器</p><h6 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h6><ul><li><p>删除已有静态文件：<code>hexo clean</code>（为了避免可能的错误）</p></li><li><p>重新生成静态文件：<code>hexo g</code></p></li><li><p>重新部署：<code>hexo d</code>，稍等一段时间后刷新网页，发现主题生效</p><p></p><p align="right">By Fantasylee</p><p></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Test</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
