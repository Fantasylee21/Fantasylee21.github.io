<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>OS理论学习</title>
    <link href="/2024/04/17/OS%E7%90%86%E8%AE%BA/"/>
    <url>/2024/04/17/OS%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="期中复习"><a href="#期中复习" class="headerlink" title="期中复习"></a>期中复习</h1><blockquote><p>这是什么样的微风，我找不到准确的表述语句，只找到一连串的不是，不是杜甫“细草微风岸”的风，不是高骈“水晶帘动微风起”的风，冯延巳的“吹皱一池春水”是因为“风乍起”，过于突然，也不是，更不是“风萧萧兮易水寒”里的风，山谷微风不是壮志凌云之风，不会去送别荆轲，它知道自已普通微小，所以低调，其低调有点像我少年时期在炎热夏天里寻找的穿堂风。</p></blockquote><h3 id="概述与启动"><a href="#概述与启动" class="headerlink" title="概述与启动"></a>概述与启动</h3><p><strong>分布式系统</strong></p><p>在整个系统中有一个全局的操作系统</p><p>有网络作为底层支持</p><p>特性</p><ul><li>模块性</li><li>并行性</li><li>自治性</li><li>通信性</li></ul><p>操作系统作用：管理资源，提供硬件访问的统一接口</p><p>操作系统的发展：</p><ul><li>单任务串行 - 多任务并发</li><li>单处理器 - 多处理器 - 分布式网络化</li></ul><p>多任务操作系统基本原理</p><p>分时——多个用户/任务互不干扰地使用资源</p><p>分时的基本方式（隔离手段）</p><p>虚拟：隔离所有资源</p><p>抽象：进程（隔离处理器、储存器）</p><p>TRAP指令：目态 - 管态 （用户 - 内核态）</p><p>异常：陷阱和中断</p><ul><li>中断主要由I/O设备、处理器时钟或定时器等硬件产生，可以被启用和禁用</li><li>陷阱/陷入是用户进程中某一特定指令执行的结果，在相同条件下，异常可以重现。例如内存访问错误、调试指 令以及被零除</li><li>系统调用是同步异常</li><li>陷阱帧：完整的线程描述表的自己，用于陷阱保护</li><li>陷阱处理程序处理少量事件，多数转交给其他的内核或 执行体模块处理</li></ul><p><img src="exception.png" alt="异常"></p><p>操作系统特征</p><ul><li>并发</li><li>共享（互斥共享（打印机、变量），同时访问（宏观））</li><li>虚拟</li><li>异步性</li></ul><p>OS功能</p><ul><li>处理机管理——分配CPU时间</li><li>储存器管理——管理缓存、主存、磁盘等所 形成的多级存储架构，为多道程序的并 发提供良好的环境</li><li>设备管理——管理输入/输出设备，屏蔽差 异性，提供并发访问</li><li>文件系统——将磁盘变成一个很容易使用的 存储媒介提供给用户使用</li><li>作业控制——作业调度</li></ul><p><strong>操作系统的基本类型</strong></p><ul><li>工作方式：批处理系统、分时系统、实时系统、混合型</li><li>架构：微内核、宏内核、外内核</li></ul><p>微内核</p><p>内核中只包括中断处理、进程通信（IPC）、 基本调度等</p><p>优点：内核易于实现、可靠性高、可移植性好、配置灵活、 适应分布式环境</p><p>缺点：速度慢</p><p>引导加载程序是系统加电后运行的第一段程序，称为Bootloader</p><p><strong>Bios</strong></p><p>bios设置程序是被固化到电脑主板上的ROM芯片中的一组程序（断电后不会丢失的只读程序）</p><ul><li>硬件自检</li><li>读取启动顺序</li></ul><p>例题：在传统x86体系结构下，计算机引导过程中以下哪项不是 BIOS负责的任务？</p><ul><li>读取MBR并装载到内存特定地址（Bootloader）</li><li>自检系统，当有设备故障时暂停启动过程并告警（Bios）</li><li>选择引导磁盘（Bios）</li><li>装载打印机驱动（没必要）</li><li>启动显示器（Bios）</li><li>解压缩操作系统Kernel（Bootloader）</li></ul><p><strong>系统引导</strong></p><p>MBR（Master Boot Record）：磁盘的第0磁头第0磁道的第一个扇区</p><p>Bootloader：操作系统内核运行前执行的一小段程序</p><p><strong>BootLoader</strong></p><p>操作系统内核运行前的一小段程序</p><h3 id="储存与管理"><a href="#储存与管理" class="headerlink" title="储存与管理"></a>储存与管理</h3><p>储存管理至少要解决分配与回收</p><ul><li>地址空间：逻辑地址的集合</li><li>储存空间：逻辑地址的集合</li></ul><p><strong>单道程序的内存管理</strong></p><p>内存中只有两个程序——用户程序和操作系统</p><p>用户程序的地址再运行之前可以运算</p><p>优点：简单</p><p>缺点：比物理内存大的程序无法加载、小程序会造成空间浪费</p><p><strong>多道程序设计</strong></p><p>空间的分配：分区式分配，把内存分为一些大小相等或者不等的分区</p><ul><li>固定式分区分配（静态）：程序适应分区</li><li>可变式分区分配（动态）：分区适应程序</li></ul><p><strong>固定式分区</strong></p><p>系统初始化时，把储存空间划分为若干个任意大小的区域，然后将这些区域分配个每个用户作业。</p><ul><li>分区大小相等：只适用于多个相同程序的并发执行（处理多个类型相同的对象）</li><li>分区大小不等：多个小分区、适量的中等分区、少量 的大分区。根据程序的大小，分配当前空闲的、适当 大小的分区</li></ul><p>优点：易于实现，开销小</p><p>缺点：内碎片造成浪费，分区总数固定，限制并发执行的程序数量</p><ul><li>单一队列的分配方式</li></ul><p>多个用户程序排在一个 共同的队列里面等待分区</p><ul><li>对队列分配方式</li></ul><p>每个分区一个 队列，程序按照大小排在相应的队列里，避免给小程序分配大空间</p><p><strong>可变式分区</strong></p><p>分区的边界可以移动，即分区大小可变</p><p>优点：没有内碎片，缺点：有外碎片</p><p><strong>碎片</strong></p><p>内存中无法被利用的储存空间</p><ul><li>内碎片</li></ul><p>分配给作业的储存空间中未被利用的部分，已分配只是未被使用，完成后会得到释放</p><ul><li>外碎片</li></ul><p>分区与分区之间存在的碎片。外部碎片是造成内存系统性能下降的主要原因，外部碎片可以被整理后消除（消除外部碎片的方法：紧凑技术）</p><p><strong>闲置空间的管理</strong></p><ul><li>位图表示法</li></ul><p>字位取值为0表示闲置，为1表示占用</p><p>空间成本固定，时间成本低，没有容错</p><ul><li>链表表示法</li></ul><p>将分配单元链接起来</p><p>空间成本取决于程序的数量，时间成本扫描速度较慢，有一点容错能力</p><p><strong>分配算法</strong></p><ul><li>首次适应（First Fit）</li></ul><p>从空白区域链的始端开始查找，选择第一个满足情况的空白快</p><p>低地址肯留下难以利用的小空间</p><ul><li>下次适应算法（Next Fit）</li></ul><p>从上次查找结束的地方开始，找到一个足够大的空白区将它划分后分配出去</p><p>利用更均衡，可能导致缺乏大空间</p><ul><li>最佳适应算法（Best Fit）</li></ul><p>大小最合适的储存区域</p><p>使得剩下的空闲区非常小，从而留下许多难以利用的碎片</p><ul><li>最坏适应算法（Worst Fit）</li></ul><p>总是寻找最大空白区</p><p>后续可能不能应对大空闲区</p><ul><li><p>索引搜索分配</p></li><li><p>快速适应分配（分类搜索）</p></li></ul><p>按空闲分区的大小进行分类，经常用到长度的空闲区设立单独的空闲区链表。系统为多个空闲链表设立 一张管理索引表。</p><p>优点：查找效率高，不会对任何分区产生分割，能保留大的分区，也不会产生内存碎片</p><p>缺点：算法复杂，分配分区时以进程为单位，一个分区只属于一个进程，造成浪费。</p><p><strong>伙伴系统</strong></p><p>伙伴系统是介于固定分区与可变分区的动态分区技术</p><p>规定：大小均为2的k次幂</p><p>内存释放首先将被释放块与其伙伴合并为一个大的空闲块，直到不能合并。</p><p>注意：如果两个储存快大小相等且地址相邻但不是由一个大块分裂出来的，则不可以被合并起来。</p><p>即会产生内碎片又会产生外碎片</p><p><strong>可重定位分区分配</strong></p><p>定时的或内存紧张时，移动某些已分配区中的信息，把储存空间中所有的空白区合并为一个大的连续区。</p><p>缺点：性能开销大，依赖DMA，间接寻址</p><p><strong>程序处理流程</strong></p><p>编译 - 链接 - 装入</p><p><strong>程序的链接</strong></p><ul><li>静态链接</li></ul><p>用户一个工程中所需的多个程序采用静态链接的方式链接在一起。当我们希望共享库的函数代码直接链接入程序代码中，也采用静态链接方式</p><ul><li>动态链接</li></ul><p>用于链接共享库代码。当程序运行中需要某些目标模块时，才对它们进行链接，具有高效且节省内存空间的优点。但相比静态链接， 使用动态链接库的程序相对慢</p><p><strong>程序装入</strong></p><p>未来保证程序地址可以改变，程序运行时才把相对地址转化为绝对地址</p><p>多重分区分配：一个作业往往由相对独立 的程序段和数据段组成，将这些片断分别 装入到存储空间中不同的区域内的分配方式。</p><ul><li>bss段 存放未初始化的全局变量</li><li>data段 存放已经初始化的全局变量</li><li>text段 代码段</li></ul><p><strong>程序链接</strong></p><p>将.o文件链接在一起，形成最终的可执行文件，链接时会扫描各个文件，将之前未填写的地址田神，形成一个可执行的文件。</p><p><strong>程序的装载与运行</strong></p><ul><li>shell调用fork系统调用</li><li>创建出一个子进程</li><li>子进程调用execve（）加载program</li></ul><p>一个segment在文件中的大小小于等于在内存中的大小</p><p><strong>程序装载过程</strong></p><ul><li>读取ELF头部的魔数确认是ELF文件</li><li>找到段表项</li><li>对于每个段表项解析出各个段应对被加载到虚拟地址、在文件中的偏移，以及在内存中的大小和在文件中的大小（段在文件中的大小小于等于内存中的大小）</li></ul><p><strong>程序、进程和作业</strong></p><ul><li>程序：静止的，存放在磁盘上的可执行文件（静态概念）</li><li>进程：包括程序和程序处理对象，是程序对某个数据集的执行过程，是分配资源的基本单位。进程是竞争计算机系统有限资源的基本单位。 进程更能真实地描述并发，而程序不能。每一个进程由进程控制块PCB、程序和数据集合组成。<ul><li>完成操作系统功能的进程是系统进程</li><li>完成用户功能的是用户进程</li></ul></li><li>作业时计算机所做工作的集合。作业时任务实体，进程是执行实体</li></ul><p>一个程序可以作为多个进程的运行程序，一个进程也可以运行多个程序</p><h4 id="页式储存管理"><a href="#页式储存管理" class="headerlink" title="页式储存管理"></a>页式储存管理</h4><ul><li>页：把每个作业的地址空间分为一些大小相等的片成为页面或页</li><li>储存块：把主存的存储空间也分成与页面相同大小的片，这些片称为存储块，或称为页框。</li></ul><p><strong>纯分页系统</strong></p><p>不具备页面置换功能，必须把它的所有页一次装到主存的页框内；如果当时页框数不足，则该作业必须等待，系统再调度另外作业。</p><p>没有外碎片，每个内碎片不超过页大小</p><p>程序不必连续存放，便于改变程序占用空间大小</p><p><strong>页面大小分析</strong></p><ul><li>大<ul><li>优点：页面数减少，页表长度减少，内存减少，I/O减少</li><li>缺点：内碎片增大，不利于提高内存利用率</li></ul></li><li>小<ul><li>优点：减少页内碎片和总的内存碎片，有利于提高内存利用率</li><li>缺点：页面数增大，页表长度增加，内存增大，I/O增大</li></ul></li></ul><p>逻辑上相邻，物理上不一定相邻</p><ul><li>进程页表，每个进程都有的一个页表，描述进程占用的物理空间和逻辑排列顺序</li><li>物理页面表，整个系统有一个物理页面表，描述物理内存空间的的分配使用情况</li><li>请求表，整个系统有一个请求表描述系统内进程表的位置和大小</li></ul><p> 假定进程平均占用s个字节，页面大小是p个字节，一个页表项约占e字节 </p><ul><li>分页的开销为：se/p+p/2</li></ul><p><strong>页表机制</strong></p><p>分级越多，内存空间确实使用少了，但访问时间大大增加。于是引入了MMU，组成如下</p><ul><li>页表Cache（TLB）</li><li>页表查找单元</li></ul><p><img src="tlb.png" alt="tlb"></p><p>某些TLB还包括地址空间标识码（ASID）</p><p>哈希页表、反置页表</p><p>反置页表介绍（解决消耗大量物理内存的问题）</p><ul><li>按照物理页号排序，表项的内容是逻辑页号 P 及隶属进程标志符 pid</li><li>大小只与物理内存的大小相关</li></ul><p><img src="reversepage.png" alt="反置页表"></p><p><strong>页保护</strong></p><ul><li>地址越界保护</li><li>设置保护位（只读等）</li></ul><p><strong>页共享</strong></p><p>分段储存管理</p><h4 id="段式储存管理"><a href="#段式储存管理" class="headerlink" title="段式储存管理"></a>段式储存管理</h4><p>页式储存信息的物理单元，段是信息的逻辑单位</p><p><strong>信息保护</strong></p><ul><li>页式管理中，一个页面中可能装有 2 个不同的子程序段的指令代码，不能通过页面共享实现共享一个逻辑上完整的子程序或数据块</li><li>段式管理中，可以以信息的逻辑单位进行保护。</li></ul><p>逻辑地址结构：段号 + 位移量W ，但不一定是32位</p><p><img src="segement.png" alt="segement"></p><p><strong>可重入代码</strong></p><p>可重入代码(Reentrant Code) 又称为“纯代码”(Pure Code)，是一种允许多个进程同时访问的代码。为使各个进程所执行的代码完全相同， 绝对不允许可重入代码在执行中有任何改变。因此，可重入代码是一 种不允许任何进程对它进行修改的代码。</p><p>优点：分段系统已于实现段的共享，对段的保护也十分简单</p><p>缺点：地址转换耗时，空间问题</p><h4 id="段页式储存管理"><a href="#段页式储存管理" class="headerlink" title="段页式储存管理"></a>段页式储存管理</h4><p>分段和分页结合</p><p>先把用户程序分为若干个段，再把每个段分为若干页</p><p>格式：段号 - 段内页号 - 页内地址</p><p><strong>X86的段页式地址映射</strong></p><p>段映射机制，将逻辑地址映射到线性地址</p><p>页映射机制，将线性地址映射到物理地址</p><p><strong>X86的控制寄存器</strong></p><ul><li>CR0中含有控制处理器操作模式和状态的系统 控制标志；</li><li>CR1保留不用</li><li>CR2含有导致页错误的线性地址</li><li>CR3中含有页目录表物理内存基地址（PDBR）</li></ul><p><strong>虚拟内存管理</strong></p><ul><li>覆盖（时间，时间上扩展）</li></ul><p>把程序执行时并不要求同时装入主存的覆盖组成一组，称其为覆盖段，这个覆盖段被分配到同一个存储区域。这个存储区域称之为覆盖区，它与覆盖段一一对应。</p><ul><li>交换（借用，空间上扩展）</li></ul><p>是把暂时不用的某个（或某些）程序及其数据的部分或全部从主存 移到辅存中去，以便腾出必要的存储空间</p><p><strong>局部性原理</strong></p><ul><li>时间局部性</li></ul><p>一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在 一个较短时期内</p><ul><li>空间局部性</li></ul><p>即当前指令和邻近的几条指令， 当前访问的数据和邻近的数据都集中在一个较小区域内</p><p><strong>虚拟内存</strong></p><ul><li>按需装入</li><li>缺页装入</li><li>不用调出</li></ul><p>特征</p><ul><li>离散性</li><li>多次性</li><li>对换性</li><li>虚拟</li></ul><p>虚拟性以多次性和对换性为基础， 多次性和对换性必须以离散分配为基础</p><p>优点：</p><ul><li>较小的内存中执行较大的用户程序</li><li>容纳更多程序并发执行</li></ul><p>代价：牺牲CPU</p><p>限制：虚拟内存的最大容量有计算机的地址结构决定（32位-4G）</p><p><strong>实存与虚存</strong></p><p>实存</p><ul><li>分区</li><li>分页</li><li>分段</li><li>段页式</li></ul><p>虚存</p><ul><li>请求分页</li><li>请求分段</li><li>请求段页式</li></ul><p><strong>请求式分页</strong></p><p>虚拟存储系统：控制自动页面交换而用户页面意识不到的那个机构</p><p>进程的虚拟地址空间为进程在内存中存放的逻辑视图，因此一个进程的虚拟地址空间的大小和该进程的虚拟储存空间相同。（从0开始的编址的虚拟储存空间又称虚拟内存空间）</p><p>调入问题</p><ul><li><p>什么程序和数据调入</p><ul><li>OS的核心部分的程序和数据</li><li>正在运行的用户程序相关的程序和数据</li></ul></li><li><p>何时调入</p><ul><li><p>OS系统启动时调入</p></li><li><p>用户程序调用取决与策略</p><ul><li>预调页（pre-paging）</li></ul><p>预调页同时 将所需要的所有页一起调入内存，从而阻止 了大量的页错误</p><ul><li>按需调页</li></ul><p>当且仅当需要某页时才将该页调入内存的技术称为按需调页，使用懒惰交换（lazy swapper），按需调页需要使用备份存储，保存不在内存中的 页，通常为快速磁盘，用于和内存交换页的部分空间称为交换空间</p></li></ul></li><li><p>如何调入</p><ul><li>缺页错误处理机制</li></ul></li></ul><p><strong>缺页错误处理机制</strong></p><p><img src="pageFault.png" alt="pageFault"></p><p>处理过程</p><ul><li>陷入内核，保护现场</li><li>查找页面</li><li>权限检查，发生保护错误则杀死进程</li><li>查找空闲页框，如果没有则需要通过页面置换算法找到一个需要换出的页框</li><li>如果找到页框被修改了，则需要将修改的内容保护到磁盘上</li><li>页面干净后，操作系统将保存在磁盘上的页面内容复制到该页框</li><li>当磁盘中的页面内容全部装入页框后，向操作系统发送一个中断。操作系统更新内存中的页表项，将虚拟页面映射的页框号更新为写入的页框，并将页框标记为正常状态。（更新页表）</li><li>恢复进程</li><li>继续执行</li></ul><p><strong>页面置换策略</strong></p><ul><li>最优置换（OPT算法）</li></ul><p>置换未来最久不被使用的，最完美但是不现实</p><ul><li>先进先出（FIFO）</li></ul><p>性能较差，会出现Belady现象</p><p>FIFO算法的置换特征与进程访问内存的动态特征是矛盾的</p><ul><li>改进FIFO（Second Chance）</li></ul><p>每个页面增加一个访问位，A是FIFO队列中最旧的页面，且其放入队列后没有被再次访问，则A被立刻淘汰否则如果放入队列后被访问过，则将A移到FIFO队列头，并且将访问标志位清除。如果所有的页面都被访问过，则经过一次循环后就会按照FIFO的原则淘汰。</p><ul><li>改进FIFO（Clock），最近未使用算法</li></ul><p>使用环形队列</p><p>产生缺页错误时，当前指针指向C，如果C被访问过，则清除C的访问标志，并将指针指向D；如果C没有被访问过，则将新页面放入到C的位置，置访问标志， 并将指针指向D</p><ul><li>最近最少使用（LRU）</li></ul><p>性能接近最优算法，设置一个特殊的栈，保存当前使用的各个页面的页面号。每当进程访问某页面时，便将该页面的页面号从栈中移出，将它压入栈顶。栈底始终是最近最久未使用页面的页面号</p><ul><li>老化算法（AGING）</li></ul><p>为每个页面设置一个移位寄存器，并设置一位访问位R， 每隔一段时间，所有寄存器右移1位，并将R值从左移入。</p><p><strong>Belady现象</strong></p><p>分配的页面增多，缺页率反而提高的现象</p><p>进程的工作集：当前正在使用的页面集合</p><p>进程的驻留集：虚拟存储系统中，每个进程驻留在内存的页面集合或进程分到的物理页框集合</p><p><strong>抖动</strong></p><p>随着驻留内存的进程数目增加，或者说进程并发水平的上升，处理器利用率先是上升，然后下降。(常驻集减少，缺页率增加，频繁调页)</p><p><strong>写时复制（copy-on-write）</strong></p><p>资源的复制只有在需要写入的时候才进行。</p><p><strong>自映射</strong>！！！</p><p>详见作业3类似于不动点</p><h3 id="进程与并发程序"><a href="#进程与并发程序" class="headerlink" title="进程与并发程序"></a>进程与并发程序</h3><p><strong>并发与并行</strong></p><p>并发：直要都在各自起点与重点之间就是并发执行，程序的并发执行是指若干个程序（或程序段） 同时在系统中运行，这些程序（或程序段）的 执行在时间上是重叠的。</p><p>并行：两程序在同一时间量度下同时运行在不同的处理机上，则称这两个程序是并行执行的</p><p>并发可能是伪并行</p><p>顺序执行</p><ul><li>顺序性</li><li>封闭性</li><li>可再现性</li></ul><p>并发执行</p><ul><li>间断性</li><li>非封闭性</li><li>不可再现性</li></ul><p><strong>Bernstein条件</strong></p><p>以下条件同时成立时，S1与S2可并发</p><ul><li>$R(S1) \cap W(S2) = \emptyset$</li><li>$W(S1) \cap R(S2) = \emptyset$</li><li>$W(S1) \cap W(S2) = \emptyset$</li></ul><p><strong>进程</strong></p><p>进程是程序的一次执行</p><ul><li>动态性</li><li>并发性</li><li>独立性</li><li>异步性（进程之间相互制约）</li></ul><p>结构特征：程序段、数据段、进程控制块（PCB）</p><p><strong>进程控制</strong></p><p>主要任务：创建和撤销进程，实现进程的状态转化（内核实现）</p><p>进程控制实现：原语（由若干条指令所组成的指令序列，来 实现某个特定的操作功能）</p><ul><li>指令序列执行是连续的不可分割</li><li>操作系统核心组成部分</li><li>必须在管态执行，且常驻内存</li></ul><p><strong>Fork（）函数</strong></p><p>在fork函数执行完毕后，如果创建新进程成功，则出 现两个进程，一个是子进程，一个是父进程。在子进 程中，fork函数返回0，在父进程中，fork返回新创建 子进程的进程ID。我们可以通过fork返回的值来判断 当前进程是子进程还是父进程。</p><p>fork被调用一次，但返回两次</p><p><strong>进程的状态</strong></p><ul><li>就绪：等待分配处理机资源</li><li>执行：占用处理机资源</li><li>阻塞：放弃处理机处于暂停状态</li></ul><p><img src="stateChange.png" alt="stateChange"></p><p>运行 $\rightarrow$ 就绪</p><ul><li>运行进程用完时间片</li><li>运行进程被中断，因为一高优先级进程处于就绪状态</li></ul><p>运行 $\rightarrow$ 阻塞</p><ul><li>进程所需资源必须等待</li><li>OS尚未完成服务</li><li>对一资源访问不能进行</li><li>初始化I/O必须等待</li><li>等待某一进程提供输出</li></ul><p><strong>线程</strong></p><p>进程包括了两个概念：资源拥有者和可执行单元</p><p>资源拥有者为进程，可执行单元为线程</p><p>线程：将资源与计算分离，提高并发效率</p><ul><li>减小线程切换开销</li><li>提高进程内的并发程度</li><li>共享资源</li></ul><p>线程是进程中的一个实体，是一个CPU调度和分配的单元</p><p>容易创建和撤销</p><p>一个进程可以拥有多个线程，而一个线程同时只能被一 个进程所拥有</p><p>进程是资源分配的基本单位，线程是处理机调度的基本单位</p><p><strong>线程安全</strong></p><p>多个线程调用同一个对象的行为都可以获得正确的结果</p><p>可重入不一定线程安全，线程安全不一定可重入</p><p><strong>Linux下的线程创建</strong></p><p>fork用于创建普通进程，clone可用于创建线程</p><p>fork和clone都调用do_fork函数执行创建进程的操作</p><p><strong>用户级线程</strong></p><ul><li>线程切换与内核无关，易优化，例子：java threads，但是易阻塞</li></ul><p><strong>内核级线程</strong></p><ul><li>内核级线程就是kernel有 好几个分身,一个分身可 以处理一件事</li><li>内核可以在多个处理器上调度一个进程的多个线程实现同步并执行，但切换过程会降低效率</li></ul><p><strong>线程模型</strong></p><ul><li>Many-to-One </li></ul><p>将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。线程管理在用户空间进行，效率较高，但某个线程在使用内核服务被阻塞时i，整个进程都会被阻塞</p><ul><li>One-to-One</li></ul><p>将每个用户级线程映射到一个内核级线程。并发能力抢，但创建线程开销大，没创建一个内核级线程都需要创建一个内核级线程与其对应</p><ul><li>Many-to-Many</li></ul><p>将 n 个用户级线程映射到 m 个内核级线程上，要求 m &lt;= n。</p><p><strong>临界资源与临界区</strong></p><p>临界资源：一次仅允许一个线程访问的资源称为临界资源</p><p>临界区：每个进程中访问临界资源的那段代码</p><p><strong>互斥与同步</strong></p><ul><li>进程互斥，间接制约关系，访问是无序访问，两个或两个以上的进程，不能同时进入关于同一组共享变量的临界区域</li><li>进程同步，直接制约关系，通过机制实现有序访问</li></ul><p><strong>互斥区管理条件</strong></p><ul><li>没有进程在临界区是，想进入临界区的进程可以进入</li><li>任何两个进程不能同时进入临界区</li><li>当一个进程在它的临界区外面外面时，不能妨碍其他进程进入临界区</li><li>任何一个进程进入临界区的要求应该在有限的时间内得到满足</li></ul><p><strong>设计原则</strong></p><ul><li>空闲让进</li><li>忙则等待</li><li>有限等待</li><li>让权等待</li></ul><p><strong>面包店算法</strong></p><p>设置一个发号器，按由小到大的次序发放号码。进程进入临界区前先抓取一个号码，然后按号码从小到大的次序依次进入临界区。若多个进程抓到相同的号码则按进程编号依次进入</p><p><strong>硬件方案</strong></p><ul><li>中断屏蔽</li></ul><p>使用“开关中断”，简单但不适用于多CPU系统，可能会造成很大的性能损失</p><ul><li>test and set指令</li></ul><p>在多进程可同时 存取内存的情况下，如果一个进程正在执行检查并设置， 在它执行完成前，其它的进程不可以执行检查并设置</p><ul><li>swap指令</li></ul><p>和ts类似会循环交换两个变量</p><p><strong>以上软硬件方案共性问题</strong></p><ul><li>忙等待：浪费CPU</li><li>优先级反转：低优先级进程先进入临界区，高优先级进程一直忙等</li></ul>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA_OS_lab3</title>
    <link href="/2024/04/05/BUAA-OS-lab3/"/>
    <url>/2024/04/05/BUAA-OS-lab3/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="d046017936ba71f7eeb11839b6a403f8ef2aaeade81ad859eded2428079b7d36">c506fc8126dc0e57c40d5bd9695fa14fd57cbee718e0c1b939a1df744d418dfd241b5d03ad08ee0e3cc663f296270d849962d22c1a0dd53a071fd8455f00e1466e7d0862a2ded21a141adaf7843294a8ef450105de550a731b73ec77bb17b5cc0f1c0b7d7c520380940b5a716f8b2bc4626a5895308d350ef3b691ac01028aa3ee119f7a5db85fd1dc228f6d9818b3fb341bb3276be3184bb5605b10df4e69d9fc083bce31884898fe3cc93e2d1aed0cf1b5826157198db155d50a6b04dbdd8f73d0954be28d300b2e06c68075b3dd71735b2f79b451337be4ade21ee80392334ccba268e26164ee2a33155681971d688138967994d7fe531a3978b9affe0071dc93ad4bffec63bdb1618fabcf254f7ad0cf5f11791c85247f6a9494b64a9f1f5a3b00483a2175373bd30168e9f22ecf4751dd6d6660cda07b7d0abf5a355484dfdefdc033691db0aa861ed5d39e41e55c408c8bfddae86bab70526c02646945729f3e2c670d2fa27d6c70e958e5bd498a4a58c09ee812e8098586b177c3874603d5696340e1488922164328f1f541dbb257c0a4522447e14be9eb680430473567aca253878c24be63ea14b0f025599b3f2d690e5e0e1900b7d4ea6832a5a72726ea67c6edb5e27ce9cf45a8d5c8d127b1555608bdb465ec944a1964a4dbce9342e8be776772cd43e34ba0e2e76243d5713e52324606e17d025032755173050ea1b4bbec034ed5dc2de1f713cf0592a08550e1dcc276ee4bc1762033254233a5f26ba1a6b221644070615502030b995069141709343830ad69961ba3621d5d51b3c886239f98ad993335df1ace7098a2a955a8db5da6d2315f05cb3421eb866c5bcdab0390ca5edafa6a0bb7adb61d643774ada8f078d31dbe1d49d7d8ae3bbf2bef425708971d315b015f0c14eff939c4d35d4d9b585f671dfaeb3d4efcda76f60c1b4f7ef34d694a3594facd12246cbcafaa1284002eff4572850ab26eb3e77d7e842f92cb0695e9443f486d1d8146fb83572d7cb0b9c61f5bd9bbc8b101db1fb497a15dd7b80b363874486ad37e8e540bdb9d9c4caa5c7b74877af8b64c68330dad039393fa73473efc3fdac49cad756824055658dcb6f8067e51d9dcfeb3a1ae39b529dcd81ae1e012d1fd7644a634314111b773d4f7c8403c604bc2bb660b11f9548efb68ccc5dcf4905d19a65a1e03c3b203341251cf9cd19c07213621c9ca23e9494282b1ea23c2fb2f6221ad1884834128fa0ab0989d48a2900fa763c78671821e1fd02b4f280d47f6349637b80749140f08afb142970cbb2a3ab005e61bde4cdc128c4b84c47d75bedbcb7bae711ece3285057f3b062062fe27b0571e4ecf60b264b1ffb8ab9877638fa4565eb0ac0c10dbb801dee1dc5e55c91d86299b18ae19a257c5985070f764b9e062290a9d0257305d84b8b41d04bd7a0a5d9d7a2c1bb39d597c3d633d12e4b43615d24143122b150ac5bc71dd1a8510e2c7a6f90179bf2364a37860a360f5545f281b24799d99c44089cb2546377eb5a53c4f7ab7872d75a195756c7f6f0785d6c0e0827caa8714ee432c7b036f61af1b3a1a239e31fae705cb827a9bb2fc03ee4d7a6439f66cde1eaeb1b51efd34e4a627f873b3c2cb05d713e97b0bb8d3d7b19b87a2861fe8110ee3ae875e8e76e073cabfbab1e094cbf3a425f91cdaf61d4755775918166642ea79f8dd0f7190381ae58adb41cef1d4b837031f3f38256ac9c275c61824284c2c29de2863fa742e613b49f06ea2c7317b56144e4e4009a63752969dd71ff9f99e0568071fc49167360054649d066e2b0fe2b0613653a623e7cf5a4dc413356e680d134a8a6c788f7b3584712397b25b4701e175817d18982225815ae006a2274a36ad85c3d35a913991444dfd102f84c967f32c50556cbd0517d9177d8c482926b544e267fab85e2018ced84a031bdbe17f5b4f5cbbd59548f228ee527b1d95be7eff26421f452ddfedeae0846f182a2f8445a9d184f233e020531f1f9a58955312be736bca5e5fd0a5d8b66e6660f005b7b3c0ec16077142c1fef5b9a2abb6362ce3bc0dfa7d42123082a7383b0bba975f5a15f5ca3bd62ac1610e9eb5a8c5e2fbaf877a4bea8cd7c75a3177a521229feb137c1058ccdf9bc57076d61f1e5f49a7d5f3aac19219c3e0dd90af6e85d20a0a43b0044b0b8a33d877387e752e8eb081026fb74cf29b462a6f8c6de7962249b61c5c6cd9c33e26af7d625a438f7e39c10b04a2e5135b2d4f904189450a65b6fcc8f4f646c6ba138a2190224e9d05055bd0b2ca2d8381e1a0b134047e246c4dc855a67038bc9dfdc8e42e6c6f5ce02006897a51f5a25086e5a87f52ed00d97382a40b0d184f797b2635a8e53bfc8655364667bbf1392fa300b9cc193af4dc9082d056a90eba0e1fb8d9f64117295785f0745e7cbb0e07de2c525093d64280efad301d4ad1809319f8cd7fe050cf5a4cb668749fb1f93fb3abdce9abf553ad773c6e6912be4e8033afa0496cd3187f4a6bc256882394d198c6cd159be2fd2336daa8eebc14ae7d4c3a6d41835908686c2fa48861dd18c29f06d4fe5895370f683e3e8b9740fcedddae08bcd90b35c64bcb65e0e3799cc51c64be2a402b1fed0766f4dc115dedb213806ae87c7299223a34943c8e7b05fa4e619d52b29034254037b4cea7a48556ca8226e62d24897de04df7e5ef154c294ae2c2e5cf81981847357d70b0622f0edcd4f1589057d4bf0e1ab2af741f5bf8a00f46ab19e5a55ca4fb0365e85a75f3167ceb0a7d328ae9aac8180a9cfdd3241157b78e2017a15c974e5fabf08ae5c0f4621b0db322d7bac9012ffa15c28c415de644fc26240708cb451a754cbd079666d8edbe45f93f96fa9a3fc5223211cdf1f5ed56dac36ac28e098e8acf6ca6ca1504129b245e88ff3688328ea5c8fe42fa284abe256f108a49244a6207cba1684199b6aa43bf637a35216957daa6965638ca7979aff54e04a213920a3ed992d649cbd81c82bbb502cd982fe740e8fca0af330e63ede01b708b0f72fe1cf901177c79742debf8cc341770ad65a9da4f54f6bd8239e208d7179a6a675b9f6f23092a002783a3daeb6e4849fd52db635416cd2383bb15a3b56814dd9ae3dae23a3e002b31cf0521aa77e255c5d612fd0bee5b1db839ca55cf992f03be7b82f0f3f38b8643d28e12b50c829a8905ef1919fdfcddda7a842ddfe756b98ad0f4ef490394a0a40957a5a6f3753ff877a6de87fc4f9cafa4d3eb099c8d91764ac6a92614b97b361c9349b5bb82666aea3cd6bfdca7ebab46b9aefd5be5c6dd53f53368014c90365a4dae3f9d8f488ea73d1cbeb1f9451eca90d84df3bfa90a7b6dec3a925694f56d0d68bc27428fd30338cdda717a9cdf54f4dc080544fee7414aa28db24d839d5f23201d45eb5eaadd848f7f57d91062403512fd3f2500170551395270fc59323b2903e0e42cc89d8e58bfceb2775b97cc46b2789c5970934e8489c863d48539a450348e59388567adef4e7d0a764e08c923c16e9426c60a5a9a6d771dded4f1bfee9524253d3e476ea3d8a5cab347c93bc5b81739f0e99a00f63c1395420758575bcf0268329a46507e0f31fdc0af2b436375daa10b85afe4873e27ca8f6c78772a0e7501d17df9b608d181fc25935052c620d7528500f651d317aa7a5431b81914daed1ef456f509853c1dbb5c1fe8d284a2a2b1d90dd5dea5a87a22a864cf46fd7dce2cddac265d9cb58fc22d2e81506fe423bf352933477c0ca9f0fac83431e714203c36e3ff20e854c9d2dc6fb9d898dfb4607c45da43e06514a6b68e7fd1d0d106169041e492e6122383136119cd8ec08a4867cf2f279c35ece06e0033b2d87ff718cce82a25670d0a45e07ff2dc1020ab8feb38e565a212d5d636d3132ed4513cf5ba111d998114de858eb63d3af6c3acf7d9a671ef16ddbaac5c4c084f0ba083ee3111189e4309e9df090c16bf80f9d311a050ed97f33e18bd55be26b08cb9cf0eb6a5940a47c52c0579c27c1f33bbeb25b080b0c2dc2166a0d34987aabc3469c431d76b5a60e773bbf9f01e027f6e10b17f7b904b85a3b096679ff87e9c5dbb8007acef7b0cdad78beba1594e383d15e2dee7e380b71613223101168a1a3cfbe886120a28ede0d3fd2f55b204e26a51a24732e60d63fe9a3ff4affbb3f4eedf275f483ee61b50377183fc95ec4d194dcc9a0140edd885217458cc8c2abc5c05d3651a0a728fc5a045cfd81faa1b8e5df284ac88c48bf7ef7cf36102f92192e511a840e10e9eeb2b593ddd38aca82fcf06dd17d7c55bd17a5014aa1ba78648cb5f51e91eb04bdac7f369ea12761ed8bc8a8aed81f0e279f3a1d9b1d7a681919f8863ba04bd435852a2c37d328846b01b37b2bef1a917c3282fb4b0956bc7ee3ca8860c30c140183f49b1d2c468fc535340ff9fa9c68a33160668a6accda797331bad8872c72c05a8a431ff6498caacdadce8292c33dd308458c1f44168e24c6f5df1f9258957a897273f4d3b894cd8e3dedf5ce6753c6aa403018c19b420ef5b8c5a39117391c9580a7267b4cd1d9d33dde429385e5d173cbef9190494468b1ef7fdf7278915ffd1059db416a7ec4b7dd519b351a8108051cdbed65cc88e6acb12c8d1df1866f21cbe864cfeeb859ab075ba4bb3623262f0a76c86413911688331e2189977d09f8376e41fa234a7cdb02782ead3d0481f44869eeb838d9856daf65b0e098cbf50f6a58d55eaa9e29fa17f0927f78d1329737665884bc70ead2f8ea1fe0037fc68abd8da85370a33e923104282f22f26290b7e80fcd9cf167d8d5e88942a79b6980e68e44f99fc0c14cf0f48ee31fbc7059904c76a8f39856428cfbe0d2a4473e99f6d2f8c3617615d924f8b42c1ff8a57ce7ed0443961dc98e5c15640a619711e088dfd266202584e843e62dcfa3796b3436a9207a283f73f025e07ff75ea71bfdf49775199e21c3bef4f371aba1976fa8ac9335a5a3b2d9a62da3841fe69364b8ffe532ad107eaf83935355155f9c2382f17b1816075342116455ea5ac276001d5b54b1eeb9c2d4270c2b84ee33ea4c81eaa82e34964143880033c79dd3bfc17e70dd30665ed23b1e5daff649448322166abb37bd7d56c0f6fded63f0e5e7961df51c879f3d8a71dda0babe70b507233927a4ad9d9910e1f82f42cec3e77bf2db44db510304fec631ed80b59bce35ed46099f0ee6128721b858c480320f8d5ddc11d7b6cafc1ec4a94f0e889604659c5376f918acc427709b41e93da33e35de72d10bac90ee75848a894c76b7ef77da27a6df11814f962a1e943d463f5fe289ac827482bf1e0eb3d5df63faa1a65f6b2fd8f433df04dfe0194405f2a0944d9599a77f1b66638314d25215e6b6cf1d36b75b870255d9203733f2cbfd4bb5c88c377aeb85b01800020a20cf2ed8dbc818ab170d4155c2a37778302c737dfacd9a5441a9e94acd58a445f49142f2be2eb0d9561b76a35497e6e7250609528e8f8b45e0e6cfe5d17b4a38be024ba0e7ef512ba789f80db3e524227c96d18a848172e30a19d3fd3a98afe644864506dcb1e50216f49f24a1679f34367f340c19a1f48d3bc6eb676316fe3b9349356128bbdae6331921af357966c0fd09f4a26c6ab83a4ce7c7e0d39c71eb6063839aefed6c64091c2930c6d49d8207ea220b0a2bd6f8bfd41c3862ddc68d53ce0e00db6d984326d8e556aa79a97db8cc34ea73362a3d7fe0b394142e24865673ddc77abde4fef149bb95794d7764cf35d5608d89746a0ba54c785208beb92e6455bca76b0988edcd27870cf64b3eec806dc2475992dcb19e8e520b92bdb9389a3e98cb144aaaeaae6ae64eea41aa2a75a8d685ce8f922660ab2c25be69d16500a7a2b22b38300bdd507bcc2827a11d9e75402426f7f0e5bc1f69f439f27e2c8124c873fcbc7905d656dab083c18f5ba3ff4cc8d9d0f6555e98ad19e14ab350548190db6d23c531d542e6a7d5d2ce4fa131804f19710168649abe8b36fa1eb2e7e2a210a6b17ecb2ce6ced0476edcecfdfa21a3939e45a4da74c365fa9c10d1ed4ad300095d920395c6493655dad32ff05aef3e57ec7e002ab4bf091d4852aea9e91239b124fb46ca6f10d05a4e0911df3223986149c263a2a66b3eea6db23e27af7a39e7148c77f5ed4f5a1d6cc9d63197090e936e38531c4b76ce7358e7b9db06c7b7a40083e5526ae39c62b7e9dc85301a71d54a9df56ec79f731253dd8cde7515326f48e49537fc496e41cccad621fba245e01c165f37e1f50dd750131d79814f29fc2701437d04f48fb4411bf54ebaaf252a4b49f0530524ada07af14aa264b443cf46715cdaef44608edd8bed36190dffe7169299613529bdb3471fcf989728573daf1b3773f4936b57e19ca15b61ade8c5205c1e81363734646ffec97218260e3b478732b1e182beb35fa6c3a1bf056cdec33108983eb99c711718067c45350c6560a85c2c1a84daba12f286bf2b3c3c5acda6ae6bef37376ed574059a6bd535c946ed0de7bef8c6e8ab424815c7729e5afe87e675a5b8a889e87eb282ec084dd8ae6227cf653cb94732b6cb7792aa0f907ed540849a902ca7239b66d4568988d8d38a8001cdbe175ac908b10d3e1674552fbab992a37dee34b9cce82e904a0ecf8abf46bac0c297cd50088be218c39e00ae2c62ddee3e5212d143a467910bde6c32593a1b43b98e5bdf66168db9e7d021e08885454da42b1fef10fc22abf4ef686bbd5c72f27f73259c2755b733d693499b72a741b474365a520633de9207af34474d8e652cc37db2e34bb761c0f153d51498d5ccd6ed0d2de28a2dc07ed992c437801537dfcfb28257ac401a01bf8aa0ccf19b7c594469003a32db703bfa9d57a4ca4ff26c00d60b5490ac215d8d9adcef76e98bb4d4b1aa269fe2875a362abda2a793036874e7688e5a4fcc4c729ef7a4ff42493f56f5d18c14a93d4a20d986837ebdd38e02b7f37137cab97ac52fede910d72aadcc7699f6f8a16f6d73405e4d9f8d29ec32df33c3db8a4ab0169c9ff504bf6817b07f667ab604137928746a1cc0679e508a7826499272c1ca3158909c39ddf003b7351866aa4bfa8bd20060939cbbebc952f1154d9d0d63c91c3f091824de5a0be6f0aac8d2d60dd5f387bb324066c650e83921e939cf39bf4c671e10f66f3e50ff7edffc71b8fb46602b922e1f79c78192324cb5fe87d2bbf228a498690cdeaedaff19ebf472f8cfc2c1c274c3843607666edee0fefb9c3fc0c2a8e9e8dc20f71153aea8b7098d9c1224a36e09fffb1dece038398e16e9e1d8e1b2d8c24ec202f0188f0a3a97cdc2749e48f4bb80c262e703b9fe524149619722325ef0e082488fe732e3d3028358ca4aeb87d874b14a3ac2fbfb7509428877ed61c1f41c4c1d26d68c90008760870a85fd49326c191c73dabda6d069a31266105aaade09d5aadee424b592bdb15d5f6459b462f322857ec42d318cf000356973bb256d6df05a1a4e916e89b443f06672df75828406059256e7c062b647e410a5dfd1abdd066c271a4230f210765479e119c0f271ef2b841a1d5489a43a6e8d840c0abf12ebc24c6d02141940abdf49d12c667693558241400b7f1f445a4a444f81a8be015d7a58f5f4ee850a321101abb73dad304da22645b83a408a3821f6517aa8efbc43c4f1590c5c350beed821044c9a50431a1d0c3051b21d9e1482c3f957081a4e24c46b8a81e578948d9caec1790be2bd990b067039b8fa43da8ec71c887e82156c83ed1e3c3d8eeef565a32cf5d43efefe02912e4e66f7f98c49cc7de1c8709a978c0ac609420a026a0acb30c2857a52ba9cad6ee4406909c065f395bdbc0740427295dd6d076c9f2123cc35e2b728e13c27996d223a842fe73a34c2d00f088b9ea1cacfffed511f090fe69446c16578d54985de64cbc331f6a78455e41200d09b9b28386e1fea90941a215eee980507935492f2774706a516281a37afe44ee7707b529da49f0dba2afb28cd2557aebc88c07d415a3611825fb0b4d255670932f70e58026c59f841a36c65cc544ab8e7d1f531012a27035c830d92aa9949008225d45e987e424630c771552c39d08a24d0a05e5c04a44c1ce83112caf2fd137bb1687405a34c14af7151c037b95bb0a123542afd98b7fce3382da573e3f880af1415c0c2f18c21ea4cf34431bfe671492916e75f4be701ed9c22a52ecf6defd627a476703cb404d23c27eb9671e6196e24eab624b5aebfde67256df58043154965ba090dbfb7418087658ac458f3941656375e4fee8f6253373a5cbeee6eda4cffd2f375ed13d8def1ac635b5bf0a94193b67f4a115c7f6bf8742d4f9bb4ae93157f4782fde3aad5869e3130a6e7715e4f8b28ca2d36e6bf427ef857f31e9f70ee4f3ae068e9b1d2cdb79f3ec541c08b16a51a081a2d1371163f1cf04b2537ee136045882f0ffd2e5261d9feeefeb8b3f2aa6eaec8f45cd2f613e4c381d2c008adcffa8aa38eb90e8cea1f41b059dde5c4daa935b01fdb4acca23f195e5545af1cf81b03a682bb388a6798502fd24b0d5676e387e46340808690029c58d41adcd0ec75dfcbd94cf40f479ecadc6d05cb06c4f129a573872439e11645d614a9b568b1b71aa49048edef7ada84877d258afd06fa1ba6f318e3abf5c97bd6ee47e086cbab5e6d19129ec047f3bd730bb90dcdf8762b2dead31b38d84caa2a50c47028ce73d007c94b66dea5412500f18a72be27859f5ffe074d6c4b42654881ef36d3827a051817ab3d779ef13666bcb90f04f42e04b41f41af3c524cb9f5c63e98fe3dfa4baf94d5343486b537fa98bbe0b6b34bf68edf3b69273d0d46a27ff4eb44d45284ec0a78237db9e4a3000dbfff58b66294ed193490367a7f1b9be984f3364a8a6c18c2e4c9bdf78cffa8ddf17a8e442e54a904fc9483bb9df23f9d9d8ae2bfae07cf17ad0d187953f22d0a9cb22cecb4d8398f53156bf00e0a2dea5e8aedbe85f70bede4e9d6cf1fee38c60ab2d05ceca3f5f1d7975e67134bff9d0bcbc39a4274d3a7effd45c5da8a716655f0914afcd904a68dea7d275e4629eee514e71dd68501d1b0fb399cc6315121b4dd75c8ba0d02e4739f67c34ec6f6fa4f14bea750b06319e81c1cb7bf82f7d29c2f34b8be43d8a030a37f0a197c964f34353decb9a3437405d7e3cf97702672d270633f93d7af43d335b40bda08c04891182bf1d761f77ab7f8172e9d13d00e058e1a73b2e10d6acfc85f4f9dc97467356f0138b38c1b8ce85b4c09f01f42b54e5682a89011be9214d9644045f4537ccbccf413fa2d6e782ba2ba7842aa429ec02216c21537cc548ed8078ace77ddbd8c4d4e243ef398e7f18bb91bd2d895026eea2ba5db3f6d3ca1cc260ddcaeee8de87ace3316a2045c53cb750ace2ac5a0dc1bbbf9792963f32ea7331df093d1d88b656750f074d13c554e207408e893ec8028e61bc099202c4ad2d1dd67c9e21b70076605c8852b759b1881ae86fb89e9616c77bbe18907cc0d4d4e7647ab0d18b6599ccd314ab93e3d1c863c7a3679434fbc9240dd8d7ec5c73e9ceba4eba624c8a55b7dded2b0addde01a1f6eb0b836d745e32774831e9576042193313e8d63499629485982363e74f4061dd379a0cea4f278fa984b54c18ee92325932e44215acc780cdb0eddb133419c61bd7b9bee4fda4ef3cd368f61f9412c3d850699aab31db6000812cc6d314aeb73a9757d93c5e72b6e142353890bcf30ee138710e309bd946bbf3c45891886c17f870e9f9e0cfc478b37dfb30982cda10af5aaf10a3bb9bdbd2ef1dddd678e86d891bd98cc9d32f805660c4fd5de381a75c9042d60655b196ecffd00493a1acfa37772e88d04b8d65c82d94008b2490984ecb43ce012437c6a21beea3812ebb1f6cdf0749bed56e3b587bf2bf5afd3ae1a2aecd65078dde32271e6ff4a2818cacd18c9fa9e0ea55f16d66dfb88d4517c3bcbbbcb0b2c5916a657fac971ab9fabcdc7456db5a6967d580a7dc97aa71fcbde5da9ea20738807ec8c24f681be33e4c2abae080f1e47a8a02d62820f907c5240028b939047ef7eb863d6bb0a99e504d9a62737f81b63238d9a7af417499af347bc4086c64181300c5e6258b416f3e41cdb59499d50cec65332457a3da3cbb24f5bfd1e06dfc41251a3a0f8da6cafa99c7739bfb2e57f8cbffb92a37661b7e2189cb428f562a134f0fbcd601d784761f7e76bcb1982c3aefacc8708dfc5d1df08b03d0b9556807893f28f45724268055014e28eab9b9377d8af171ebe21999757cb40908d428f7129f17633405131b1c57c74d2ee0a2cf09b2375dab4a11206cb74ccf27943412c59abd229851fe8e80d14ab558efdf38ae65716508a8d8fe2dc252690e274ff43988e7cd78a193a79ac8e013580f9fc917020a60fed31afd89e8bc3bf436ba039b63b2203bf3d9c3c82f6b46db3ce18abc22e0e1971fe64968d5d0db9f84d7cafa28b140190d4091ba6639e1c858076060bccbf06a6c71fa023825f4a8327c54faec0880c414abe509f32ed94aa3b0cb7488543070a341ba33336e848075f4b96d875975611acf0d530851eeee822e14acd38fe31575ad4210bb2f090902c9f2c48dfec7e22b71f4684713529bf98531ea9a2f684c21281a1db3e520c7f91932e842b00259e2d595bf5d92ac5190a355c9357f0eea6858038a33eecad0669cd849bd9555edc08ef28f6d670b9a2df300862d1b1e32aecabc08e93c02a14f0b4cbb490b86ff46a8902b31a3c53c6a0aa1b334ed8278bc6a5aed059713f6823165a4e1928ea02f04e4da3ba966b622758d8853c7397ef7b4a2838995f9c9109a8392987b7c7a08c248b59da87552f8d4b336dc2b3ed8e0dddd699e7f45c0e182c98709b6162e893f7e991a4b3161c98431cad7e28defc30fe09303e8e4f14afa1807e2270359aa8876f58f72326d7029765b704280e95e65a1868a3abd885f838ff4cd1072967ecd2b0f370a606cbad89c94b3e7e52aec30eaa6b4324e2e7a0c5f323361bc772da7411dfaa16f2d021665a4d71c324c0766d61b30d0f08b510d45438b9dc245efb2992084e1dacf1d0efb006bc2af554060d12ffc31a3817e1ee2d24b369579067a720a9bc8a4a63715b622f562fd7b0745c8f88fd754722f9ab48db1868ce93eee106557f1c9cf4ae98fa39e2f4e2d89cfacc78e854aa6a91ca463543b055a8fbb4086e69f806c6e455ad08c2bc71e5ce58c1b35cc8ab99947b22081e2f4d1e950402e83ba121fc289e5ca77b55f6e0accfb8b8c8a783d938cbf5e1ebb234ec56b7ad8f93741302936af21c6746af569321e25cf7020190abc4a622e5eabdea9b665d3ab7f6696e4e3874549153c52b0ba22663ae3449c27934c0c4153c5b2014c0b0c2d342bb70e3ae91182ef737369d66a34a9a2c9c023aaf98e9cb041af169103091c3721e6f7bc58cacd9f1345a1393585fb1e8a3c6e6ce87e27966a97990c3133c29c85c7b14bc7dbb79e946f37af785a1128819afae6d9fb9fa67e373ea9cb2aeec10257110b5ad178d673814c27f6d9da59c249d9a3612ddfe750eba2d3a2eecdf719beec95cab0dbd16bc2ee15dd5655cc99c2b2db6ad1280af4faeaf4c8f8bff36079c9a8f9a3714601d79090b57db603d78c66de4b1cd3e0fe65e3304c66099d8d46cc7359003d7c7a4d529446cf848354cbdb6ea84a50f4e28c227254fc7483f7232ca3feb94fca3b425dd39ae960fece2e7c52e7f9826fb9604572c20c850b57adbf70e59d1eeccaff24a73b9b51c48760ffc5038aff299f7d35a74ff2a542cac77c742bcbf8a0d09ff8c28504ac5e0dff95444c163cbfc37c0a7fd7d0f7ed63629f627b4c166bf89d98451a8ddf9b3c15fd2460267b873a2d90ae804108174ec7427c627fe25123c213b48d1fe1615e39f7874394b46fdeadf180dfad7f57f2443189fd981d3f6ef1deb33fc2b6ad2da525a88ab2fb19afe45181b79a8576adb676ef8a45260760f287361eb111a9053ae221c3c9a435059427f4c78563cf1d47d3ae55926a47246b6015a1cacb37dd1066e1f6b9d61a7816203cf18c16ae23fff044a1412028f02b0312ce12cceb08cc7a1cee37ceb5dcb4677ee5d972c83d1dde253ca23c138551720e67fdbca36e0b7643684a4273214b742bbc96fb62b9deb53626a4afd604acf8075e7d9b61f7b690b607aa4bdc3b27ae2f492fe929054985638b2e54916ced14b947c931a46f6b36e043433ceced403ef9361cbf10732251e5100515144b36a81c1bd709da76b6e0df366995207f49175a6f09d604f8c4b88f4e421fc308f45ddad9411c1f6bc35e96e1bef7bfd8e7d16707076b411fb1574fe9a8156734ed70bd3aecb51d19e413da510abd6f4e0c22ff97c659773d0800a3e235b68185182ff14a5f99f75ebf644eedac7de33737c377e385372f054733a7d0ee01aad00d213d86d0683f7e79681392a30515986c43c9dc0f60fd8d1df50caffc0a7d52f2aa292ceb9b0f2db3903c73613a4bca57bd8be9224ce350b9977abf1247d62b750fe20042eca8f202850a6c9dd9f235fb79294f67e52026c24c2bdfbc7a84ab6cbfa519080bce230cab41ebfdb19f4f2f45e6905933024397533706b79bb47c7d130b68b61875b98c7a3aa1fe7bac21a120eda71f83ddbe2f3b9a2ebc9a1b04f31e3aa0513bd2e3e6d1cb340e0fe91de8aded7be815bc821c41bbe9a55f31f34eeee5a6458c2156b62e1e8a21be0df94de6c9640227cdf95b916bdba863ee310b45c558a813a6f9d55828d75c1ee85cf1e325d2fe0f8d24a53162d05b6d9bae4f8e3c3827417dfd55f05920caf9703cf573befb980bc24548f476b8634203ed12baa1dc236ef13ca1b5e456ed3436585eb73ccb1f8b3ab60be702fb70d92a92d55bd7445c93b40cac010017f5267da6f3a3132c41f8e9cb3a7a02415a883bb86bc3cba6ce927c9b968e0273e062c3f1bd03fe1a1c29c523c8b77d433264ebfaa01777111f00655df16d097992d83964b5aa379ad4e921077e47b353c9c090d62db95827018a3ff901a93de2d12c07c55e8362c7f0a4ddc04bdac23b6042085e561e6f3a32aed48f6b2a590f3b426fd9deeba31327910db4688958ce73e444f8c2e8ef0317d5387f43bbdd2aeff23ec26c160394fae005e0050b873ca0c795c77902c1dca2d26aed885373ed74da1063d912db59baa0a575b30fced980af7a472a2a3ad8a7dc2c6e6d8c91156e454389979af77d79386b0ad28f67f0eec0d7bd19d79edfd939694e1044566b97641b540d4f39201927b428d6f950856ff47b06928b001805bebcfb1d262c1105c101eccf3df691994242512d0d88926b3c2cc00b85e2adc1dbce4d9312c205f5c5d3592920571b24cf57c636a927afa5f1d0ca07ac871f75d5830b3ba52e18bccd1c6381f22dd2f81d7f2b910296d2db4e7eb2a228c6c20f56e9b8cf6f4b92dd57b3a2e1405cbd9f8bc571396df85698c7ca54888f19ca24bc1b86c03ebd68cec240b75a35121319225143925bd700c0b3b50b65db54a54137f7ac38e7c0df0b378ae6a2cc52365b5a99404ea5483e2e7b1fb56d895df133043b5a284a9c478ea94a029ad71b9730647f4dc99c11ef0a43e882a778bd44698e880f98e9951b1b02961037306f04e0d1ba8b81830e2b0a5b0e393a457a653f6be6f600f266d029d3fa98d4a3a5a2560961dbd8d8cd7a6835643b5f0dd92b893223ef45c8add993486bc68be553b88f7a01556166980978f06449f2bdf65447de69f845be78ee7e50eb44521e527ad6b598db8ed962020a66d5f956536466b81ce5112124787f20ba28c6a3a39f843d2770171eea937794892646c330be6e4f18acf673f991c2759bfa109244d9634e8cfc194df0b0c0c2cfd4348a652d7a764c41e1dda18516f4bde65316ca5f6479e2e92616c434f7984beb773f4a9af331398f1140f836391fc8e6880d020fccc6160689940030d067f11967d4ece34eac5ac9c310fe3054591147341d400357c0dcc3b3336b2570a314d645937c604e4eabd8e687047880aaebaf74ddad12a7fc3dc7e06235afd9092ab93b8c82deb369ff09b7f1a79cbfd4288a9a9860aa74e92befabc060dfc78f35833dd4657afbb45cb08a6f176a6fff458175c76785fbea9d2233fabb44224dd654777495b72a31a835d16a98050df3791f1d5597487006eb412ade47d7e3f1501e510ab1a07b297562cd8fb3af7d5ee73101ba9516dfc89b8adedae76d2dc2b7ec1270352147cbe9dfbe933b7b5fa134134acdf6c5048a40b68d9d741b54b998a4122d3c471d8a7ec038c6c54954267dd12bf3480663a5d44baa74f711169921070c8a857114573231dd512fe7f6310f1c5a35798625a3286bd3e646989e2daca535825a48766ce24c3b3852a225d3f33b13cb9fd6c927562256deca7258b18443fd625cf81abfc9c53aec3e3a38fa18c43e4edb1fd7fee670a6af604296b806b984e7ed43ed5a1494aeb27fa1c50be4299215d043da442d55ac801ed1bd860fc16ca0ac3804805e92c93923f9918da31854aa23353b50c72e318b0c2f82c7dbb80e8a1a17257fab42727291d004ba766773b30ff62ed735801bff10ed72e49b14420cf10153b5e27daf621797cc9afa4aee897e6d221d41dc640a47072c0c356a1a47371e620ff7bcc6f2524ddc1be80d6c135d5d0a0a1de8189fab397139b21487a748b6be079bfefd2b12983efc6abbb21390e0bcccaf42c1e2ea9be4344893a3cffc23df7d086c5bafba512a17c5a6934a738f0c544436174491ddca8855697456a68ef1fc2ce34b2e04136b99047c37cfaf50223df06af531c3b7eccc036a51f8a60dedee9b21157b4429ddf8c55db086a8b0f40a404cf58e5fa7f1784e038be3b5ea222044a8c52b9144dbc43540732f11cc0141eccb69403865c7cc32590bb28acd5d87a84f59fcd04862ca53080d164e86a08d2c71aa5e643b9049230cdfedd53ae7fe2eb0e384a704f1d141e8be8736410b7dc85ad7289b768aed29b44c939c7cf2756e5f7be69cd7f6f1dbd1b5a0464691d521a6037d5cb5cf8b65529eb0794e6d1852d27616cf2e4cf7de9ec9ee25eae88a6811b61b411fc2dd0d5fded2b639dfecdbafdb58f0d8d34b822f3f2e9c0e0c384b2dac9a4b0ca9efd0ee57978daa001913309c2893fb22d05926a14a4ccddc1df030634aa848ee3dcdfad6d1a8a72b111e5eb3555cb6c5a9a1a6ab9f34857440c6e6d1cde2b9ca2460a804176efa7384bb23bee07bae0c8e2a248986a3597dd8434627cbb48cf64d8b6132778f900a3a05ae0d732604ebd92fea62123262b86eb9ed9a9279d7a4915e053072b05da38094548b7bae60b5ea84f050690b5b595cb2282210e2bac5f7829cc5215d564f43eb1580ea324cf0a355c3323c12a53f0b46a3d2da0b4dbf0c06b06458ce82d9bcb246885ad1bef598c61e8c1051b74f41baf628c2fc4fd48a1bd0685361c433d432c7076e649b41c34ffeeff51a63e6151fc620898f90ac2ca7d37dd08e7b7d2eb079619927fce9399c079a6a831204a5dcc2b40871f045a28e6342fa8a4f638a54217705683db1f71e0b618742c362cced7bc6f62253e82499c4526ad83c9c5601e42784c6ff7bce77d69ff758066615d338fb5cdd3a5b0ac23df77fbb78ca45ead00b735923e633c89117bcb540e60465aaa1b65cad8b3b5d91d5548df5c62491bfc4a2515564abb7ba7f7b1319e1892557c086aad21d705637dde0141bfcd8c45c8fb40cbb2871d63a1b3032496d8b5db73842b194a9c1fa23b6ef5b075b0f86424968c62a19f224ccc82804d5c8b59536229285f8c320cbd7a152196466a9720f0a872ac5df3458596eda379f5ce4b6df6d06eddd649c414e6734933e785c853e7a2a10378bd9594ebfe4dfe8220268d5006326fef2115dbea9d97bde6aad843f5ed2765f0c1261e962e6a46915fbb818c30e3ceadaf55d3eff65270ea4c8f79fc39007f3520228c6c6e5c08ffe9844046ed513d320fea0bf520b0f1e79b2b63d4fa73b60fa4387f804abda1ec2fc0216d2895cfbde7b2e49a68da86b69724eee3952a09923901464dc5c0a8c7368cbf34d0c62f10f326a448587aee882c4c3f4e5ce28fd279ae484e2ecc2be8b097fc9b99d4a17b277baf5079e5f93573a0d3c4a446d86984d40edea1ce63dce8f25184323e68d68c4b6bc3d90d02fa1ea4d44bc21a46e14a89b67cf05cf96326de23af14490bc9b0e4f173edcfe24989d2af14873902b6537a6d48f4ce7bd9010873a3ad44ae07614e560cb1cafa40d448685f7c32e229ad7e33b8f53716b0d09c3d11c3019635f0d6f9033975ad81077f64c2972917e302c3ed0c6dc6468c9a90c9f4d8a2aebe11ac820764265742ea558c2b3065d030e6873f75b3ef02526fa260232c7e426d813678c1bc7f582b7a08c7926eb3101d5923b86a5d6a29ce761222bfc931fd436f7925b8effc07f4ccb8a749d1cb2ad37fa7cfd68be3618f98634a1506dc23390e7f15835834e1ddd3a2ef7bde90204f35e1a4a547a2452d72d8161b9c67a0e92fbd18f93a93ea20caed8190d3852f71044c976f06afb445fdd64f72a44b9f79a543d5f178161f16849e775dfea4bbfb2812a19d8ac68a3d970651ac02b7a4e58ba84718c06cee9a22f85fabe09dcf4e6198a3d6cf312038516cc09e1aa75cd467084fd3406e10091d71e1f86b2b8ef516a77e1827d3b1ba7120e0838bac08097f6b298e49b473584900cbc1b5ef9fd6b4b8acfb9ac6f96066969bdc993777ae3eeb5a5002b2b8cc7f581895f8ff7cc1dc4be26d27f9579fc55e2fcbd7905d7a3bebc323abea352cc53df8a1894c90c2e696d4878b08c8222ffd7e679e42e7157ade2a9683c25d1a5136443c0f83ebab762b8bd53caf95d69b6bb1bf18ffb4ff2af54f02c6df50ae7c3747ef83cf2282102cc682bd3fa99c6ac0e63aab09c50a3202c142bbfb74ae075592f5b7a23165855abf322dc8e50031b126696b645ade4b85ea809ea6dc732450bda29ff0c26792aba5f4ed608659e02e3dfcb2ad9e1910a13db314f0ac42c1a03eed958758e826a3892284e735f5174e49466c027d9e94c23951c650ee1da5e0941a69d71f86ef7e9384cdf08b203fb04c30418ecee7a057cba484edf88dc36b44f7f9e43576c270244a66896233aff6c11fb4b27e501f0fd53aa5422e4719cb04953801e61e47b764bb47b6a23025f6b88256ff6aab09939b31a7b5c1811387211e7abc48f4df89ecffe731a881c3e8bc8d2fca32f3a1ff5b904585e011f292944c377610c30f6abfaee62e6615efaad4c696a57571163d9f4c31dcba040f1099640ae3adc6e2ab18f11179883b001799b87c3be427c967dbd7324764443fb79e487b6555d4afe15d14e257a834b0933ea4c7bbf6d198f3d88e142cfd6d6397cd90c2b26bedf8c061790beae3f72f7dd65a21464bbd1de50141819753370ed03a177f3881912d882de2cf8a1b601a8117d530bb95fbce59f28003cc0de3a1ff8810940b9567a00f1cc1916c150c599ce5289f75d685184fc9f62991b7332b6bfc00da09a00bd49a89b095e1c6e8abdda04c180c1fb002bd13d14a9297a03f66162bedef86357aa690848d9b55aaa16b5f45f4b5856943b52af0523cb1b918afbe0cdd3939158023c6f861c572f61b609a209de8e895daa694886676da9d6081153ee72d06ac2e400d753949bbd56a3e5036f9349b0d90dc71a7648f5b75194c9f7f581026774b3e3bdbcb30ee86bcd5337225a8bce4c61fb543efd95e41028afcd146326100a4623381a1d6793a66bb1a64cc9f614a334144adc39d4aa576c6c8d7f37a57ebfa0497313077cebb3c584ada6428a9c9c7c207f0ca0aedaf2e1ad6b646f8ce291967d636577b337b2f3dc55eaad851c0e2adab5f673b9da567b4f71103265f8ad9ca02562435d494e722c5e66d95f5827fb4d48c5de0fd3a385b8e539e3f1c791e6039d1a46caf4a7c4778d8cc1a6c01d41d7ed848a9c530a0fc04c603a2122143d8fec99000fd53d17fb59df7b92a4a6aade9ce0350c910ca520e30fada9880bb75d2e87214e1db34c820e0adaf6749fd479e66c74850e27f683b32a6fc42490018c09586787588744fae1120f74c7a13d3a8e7e70d009c067db901f224f9b07e48f18c8cc75be60647878ef019457c61113cee8715b91925b298cb23a3d45486961a63cf78f47ec218dd8079e6ca9bf42aa411b6209352e8eb90d669e2d456dff27595176c3b21cf8fa7712eb7361c6522603fc6fb35197cbf9d1116c78b10c918b20bbc643237f968576835af7a4ea1635447ad1ad64ad45658ba4b0f294daa8ec64eaad4cda82fc470232264ce771db13d5a94b7247355f0d224a274ec8fc29d19b86e87f063179ef25f2bd8c70f81a8639cb75fbedd2070e183bd3a73708b5007f53897223d3ea048d282b26a806cb0e4678b1bc7197f1fb80c00cf95add574328a3ac032d6f5d6f44152b528ceaa6b7fd1704c21b6666376a2d4b9f5b36964b21730f00e0f66d1247a9098d6b8feba44166851b880c9d249cacb31bece23876b3f303a35cc5acaf0352edef634a42114d39810af6ca1352957ab34929974616c71e70cb4fd9181917706216679e782b9195ec44fec38620be052d9c8be92dc25a6667dc43bee6f5f3510fcb02cdb757161ce944566c66b921646604d27d5b638405ce3bc7bab442b08b080b6383e157ac418948c73908f24dc3aeb5d42b004325dfdd9a9058a86a3eb77de2b28963d25474b8d6380998dcce41295708b08bf702e4c5b1e027682785077f0ad005d5d62d0196f7d72295e3efd526f198573cde75be967c99a7cacf73c33190a9d30c227958cbf21f94e4a7f2bec9a52a13881ea6a3996fef1174f27a4a25bbcbccff390aaedc8c5f11bf9ac049116f32d5400f2e5e37b0ee83430e9fb93c7a6ea41abfffeb5e4d7ecf097c5d04929b7f45744e6c1a54e50a5a3e3cfa95c8358cf96e5322b241362f8434bd624e6db069acb5b3e5bea0b753443f9114eb136adabbddbbe9d086130a0bbad1b58d1e088368eb4ecfbb962ed8d13eb7cb2965682ac0d83be30107ceecb51cc03d65f14bdb82a25349bf7072a92f1ea8bc5b0e2bf0c2c4dbbd7004c5b3cc20bec28d7fd8301b79304573a086605325d6e44851bd6af99a5736085366fec295e8ce158398ae7e5c698413f4ddad57873d005c410fb5c274e2dd3fe46f2dff80e4a9419a7af99d5f434efbaaf31865a3f89e119dd5f7bd2c7744112cc8e0898a319c0a70a5f562a9932cf2acec7d4b6d3a873a0ff8f9239c9afb6ff9f2cae0441bfada3d398f68f2815afb6bd7c1110b65723f0a8e9e16c4aec1997329ccf85b12c1ee4401d9fbf7e656d2c192c20744d44e8895548718f0b02e16a60930584704c9195de0279ed29a421849d095d91bf9c09e230de3ba287f967bdc2396b3412d250cdf5d5fb629251559131516da2f77a71f93107ab17cd800f347f8c4e79194206d0030553a28b0b7f967cf2cf1279bc33e3e0d6a86e07c61226f5998dc9ed6ba15af07f78f827517a2e2f7bd07be0be124f8bc402c337a71afab3ad28eb566d28880456a9d11020c913608bfc0e63552e9a0bcacafd3e63866c367002c48232a8b283716223759d63a5186b24ee8130f122ccea3c51a09638157b2b374514edb908d56d12f56049be2efdd07a8260dc4ffa1a57ece72e3441a598cc2fe8498738f0e41e14676fedd1f4a81a13093ebc3e345583dc55d882025bdda901177de40193bb1227de0b25f4631173281eb2caa68912e31dc9757b09077e77f97086596aa4d6e1cee3f5ccfe32815c76f5cd4b9cabf824f86cb949082439e330fabf26272c645ea352c3cb87f2a5277ae92d7827fc624fe90cd97dc8122e293bd552fcdaa23253e015a42bc559feb2b29c99082bf6aa2b34cc12f1657a2939f9c8d7a9b0a61b925c0cb785b48fb210f6e6689b88ae5d626268335dee7f39fc6eefdd936c6f6484801b42c54a06b0a5e47b352ae66d34eef1c37f4055585a773bc613a5e17051f3472d48fc31ac7b679b11b75206f123355b943d7e55a30206c0b10db931d09dcf638ad7fab3cceffce00fe9720422316517a2bb461e86e2d49451f94f9200d832bc5de28b3872ab52681802244e6eb2a6e6d834e6d89f5490afc85aa55d60796cc0bf0192367ca196d180c1f4cfad9ff91a9c5846d3d455101c2eecc31a5de18ce0bd365ef78af46015ccbde59468e867284ace5acb9996d1ffca2b35b8db86f1a875ec636a90b15f2bc73a2dca3e4923832c4fe4674096326d7ca56492b6bee87a6986a6dfe10170eabe31c2583e29842bef3bba86a0d03e23860b2a98bd6020dec66702dffa3fa218665278bc0980ca02e3e620ba3ef33460e8b765b5782a4fd679a9093f70852f34942df2c33b90e4ffea563801d313d3ee44ed695fb5bc08940cae6aa43db9a5f928614f78425b8569888766f2c622227e9831fc5fec4c46b749a078917ecef9e4f997fd988e10c9a341dc41294d3c89d1d7f37904f8e2b16c9d84f8907a7c8d5601d397ed8fbab3c955d3194cf1e048f71008c7fc0459e8a64969de2068102db87071ae23e42d1a9f2dc5ac2cbd399f0ddd1830cc67a367bd5260fdb541e783f4c034a3f14ecde54a562c28d7fbfca9baa022d4a3c099f25cf9e264315546f5991d2db4873577b4d076a901e9143aa34766b7d766e9bff01e1198a5a6e292235800f9c49c8d4b24d8ac221c4008cf01812d8f079d9e2adbbe736f9b14297d1a170a12f974ae7d7527c98396321a2f842071ca0ad8d103903f8961fc4905dabf5ce2129d67b81a2b57f1715f031f554f659d539523a0f6e3265ee81e9cafbc4957c72fd7051af5071d1cef67f35c425185e600eccc8575f2dd1fa5a778503c49875e1d09f75656bea9f8cb5aadb709118dfe130351fd82ae733eff40d836ccdc62f56b8f6e8854377220ec54acd08e21634198a53192c67006fc97ef1ae093791017a9baa16a9c6c37f923a726547f42448e69a03218d2a62e72a06d430a1430d28e9e4556be1faa034e0565fe2b30fa415a39cc3f8e98ebda80815d823968d65bfd20a370d0c48e4f699ccc62597c44f991a4090680d5a5cc76ad4af49145f2c5b0136574b3bc2f1bda8f7d601bd727504dc897c4db247f613d105d85e276a0dc4b74a1210f8886064a1e83fbbdf1e2b383ca0b8ac747500ffb5b0dd8b65e0429818c5605168e896c958e93450d0334324437ea0cacd6f343b15f28ee1136370aecc44d075bfe16649d33f9b0d58e8ea8d73364e61f22f56c457de063d81264da1452cd011de9ec8d62cdf2c0eb0d6e9ce612c9b0d553231486aff5a900439fbc224b86f13cdc499f0da31300dc129dcded313eef484a66711583b3778b403a2f78881cf41efad706965988eaab4c39c564647748ba1317ec1ef84e3ccfc3a8946a6b53e97de602294289cac790fc2b6d6de82c92cc20953b27bd3acaaab12d89c4c28bc8dbb196d442013c1a9d9b5af5a91f51ef08c0a941891bba301aa6602046fa1d4a9e8fc2958c3a7d3a87224292390d1c9cdecbea4964ff07d2f15aea9a5328794949a9967694774cecc2f752193bce257af573407dfa122951dd9db683f9b60447b327cf34ff201633deba61448b2e773b329b36c8a47f0b7139a45e7878e983ef6d26ff1cae2aea34c69adfbf629ecc9c4ccb7a0f8b0a8ca7c09d7ad214ec1b665e15bf7a2b2de5fa0bcbb333af40ff1b761a549f6ec40666afe2265d8dd85cdd001c945c49248eb03ae781d6b80d16a36fdfa2d300374874640b8cc427c15330f0cd3fda60ab5963c252b490e38b69cdb61979f559044ffbb3c19a8aa4db10b390e9e0175f0055dae7140b91c70debe88cdaba9ec63c404769994db185f0c2d86fdd1db51cfdb49197729b67d5d7aa0aa7cbe61c55aea97ac011179e62debe2a54afc5a7210c9a24c311cf05cd4f082948fa6010bbf37e55139a5831930acbd54d7be9be605f6a3e5c85d4ac2afb043f6dd17c9ac69c0cb986b266a18a041e2e97b5f1e52d71448b976d82afd815d436470228c98bd87df29f2b42caacb62fd0120437db10b274077717da2bf6b3c64c43e4640e5bdd0841f3cd17d60bfd4dc33b5d59c39e1224e9677d464a497e3fb0ffe5ff4f2c8a5b2a8ad84c6ff53f88298fe6d2b017bfec53fe30ccd6e6a631459e37cd0d981fa6cc0fc0f61bbd92caf3116a5e17028a4aff01e1c1ddcac12c7d51c6381c50f585b18608b30761809b01323c75fcd152ca0f85cd57ea0ad4d39be1a7acec558cfb92ce1b74820c89115b291fd4e69703f89daa59c53ee1ae009f01492ef46165ea1584b7df529b7ca4b7d28dc397c8b6c20d0a28477acb2d34ae1d252f1159bc98b018ba2e737a966fcab255d7a87d0175e9001ae73dc22eff8599ca20bffc85690b5bdb3cae0ce5bd84d806bbe741475a461ff5ebd435442efd38d00e257ed0d71f52553bb9d2295062a799b6be9531852ac2a53d96c6f41b0fdbb9f7bcf80a98901220faf769f334d7e51fcbe3482c183e7a62f1b56b170bf870dfb8c3d02f3a43c229438a3568d421a7335b5b8f3b4d094c46d0bcc5bd70c5dc202c3f8e126a7ac83b6d5d4d42816b94727a76c48fc82e9b945eee4ad22f505e70a214082645dfa8e0bd1fb83ab3a9e887e5520f9885d8f041f2edff9646cca01c37fce05aec107a1593748db1ef7e8deded2474b8fde433f500183bee192baedd23fbedc4c0763546465a81a5e018f4636146bd8fce9332caecf3c2a29249144c29eac2634d1e163c49124cf5a716ea7c9925f893f57667d53069a8582260e4851e738463140cfa29c965392951fa0e394f9b559f39748ccec9eb47af64fb73414528ca571eace2764b89e2a37f54ab5334f566bbc96e158695b38d2d78fdfd2e8943fd0dcedc0a66a6eff2c7b54d13f1dd42fff1b3f81e5bcd07a6c7c4fcbb9c836675a2be52528b0db4a86f6e47a07798ed2a7ce48b71db8a52c7290afa49f37058c970d171f0c572af06c618caf34a4fd8c9e78179b278e684e42fe12ff9e6bdb5d747aa8368efe9af3074ec8ae29a244652ac23042d64570d3856ce012c5c39cf8409e438010547df8126b918bc0322a4f68bd15150c663d1f5eebc0fd56256ac687b0c85cbf66f79c3a984a219e592a333ad7fbd9a75382405c1d6d6cc95ab9e8b05280df104fa3b4df7d0c4b87c233369bcb0b35a715a0c6d0347969fdab4ecfe75d916fad19b641277e0104d3a4f54c125138d7374dd829b56808464568a7c17f7d80c1b8ec9ba24d864686cb7248ef67f01e9c86c1f4183c4702b90397a8ce167423d452a680e027143b4f0abe6ad3678c9ccc9ad8a452c57b4fdc9d67658bfdb7dee3221c219fcc67ed8a1c6e14421afd09693a88cb4887b8299ca12ddf9d748e8143da895c8ddf33b28bc52ec1235aac1a5b724fb4a9a90bc5f081553b851fdd07627c5d9e536db629e7092767ef1eb7a4a563c887d31724c62513ca8f4c1569907bfe345dba5b6a01e3d82e96e90d40114325d847a5a8fcac9f6638ec6fbd6ef9ee4bb6eac8b21d42fda570bda2609214850b5b7a6a8084ef8b8c9bc04c59ba501b07ae98b2bf31e629a4594d87fe1b903f995c465200fcddba1330c86b2c307cbde57635e83237e2c67fe7b44aa6801e7c73ba939b3718ee43c036656838d4f9e2782c858c01b146b998a86a55724f0987d456926dbc4d972445943c1e973ac7a30a96d5946409b3be5c0493faa564bb5d085e827128877e2cba39d12fc285f80275a5fc4c01e5bdb72fa3b6f317589b1df117339ffd5514307d19388b35f158f918d32a47bd304d05d4b7b1f6c8d367e12e407892cb27dafa8c3ba5ac26d16dc7423b443ddd4eb347d0d2284130c0de6cfbd063076450febbb33b870dd83c8b6cd07b5be8fbf4e690543505d994bfe9b73c2626ee977b6ae733645a224f8c35a784d67fb4d6503933a04b5da63a484da0a2f0249c2ca7f387bc9610ed0cdca50ed3017b194f246231764af47174416437dbf7cb054182af37c45c509e37fe8c3f403676272922683df44b60524447adb78610e2afafb24259ca27983b3fb7d2680fcb73d3eae67ad1bf445077cd33a1719a5d68e12316ea890c51a990959c08172a67c86256887e4b9837c5f68088544ea8d8456f9e28852f48ec1250eda823ad8cd8e1d9f8d23c667839fd4c0c065d9ad3b9b0d052fd8c72b5552c0d608665decd7abd94c9a713a887b11836988c8747308123b6d157c88e6a39f2d248724f161362c7e650f344d4b9393de4c2cc5fd3420a504f7e760e0b0d9eb042924e20e2f183f9af3d39ed7b95a77513aab42127ee52c5c9cb0698d1ba7a18ad08e50cac2d7ccfcf561680381947c9ffa7ff6a6de83be7724f686bddabad882b8f3cc31d8ffe2e057abd0b17249131d1aa62d4901add47885217a101390ee1be98a4cea87e2134f7023416ba5f1b811ddd0ac0837a1af9e39345024a754d7730c39c004d310e8d7021a20a17a8cc42e8c8c19986e6abf43c59897580f51d71f53f5fce7e3f64cb0cf62d8c5222cddf484190d6e48a91f53b5c4946ce4eeafc5a98d6fa8e10ad776e49b956b5fdcefa2234b85d9609605c14ed9905dd61ac1a6cb761736ec1380483a0f30eec27d0f779f73ebc5ccedb013f80fc42459efbc8cc876bd50893abdfc7e97bbdffb01a682944966a7c5d555f5a58c1c06231b9a9d519d4e028018ae0d8e581dc1910d35435102cf9ffb97d08f7843342314f475cdd799f4402ceb9a70575305f14574ad47834f33c9ef093656082ae8b860285a0dddccb7aeec742ca8139ebfeb1666955d93d94076bc78a310b634cd5820c55364a15bdb2de8bac9c1820b538dcc563531b0eb4e163b053ce71d55c8a9b3df97bae010273a173e945edaa5c5cb002147dab969594b03d51e0c32325be9ba16500edf67a57b1369f96ce56d927d9a4f0093adce1a89e6f96fefa408620918e33405383c10ae301e4a440ce9a963cabf581e10b0c010e6ed13cf38c69d3129c97732a868cab2b11f42093aa99cbb54f33590df662f585a34f490e2beba736c0777c30c891c84f13f97938de242ef8457b8c259361e4278ea285f6a2a91886aadefb13a8f852db22ab5da6f5283051996df275aedcb043dbe10bfd94168befdea7f8d3c50b9f98f20d12bf741ba837b87823f759234dfe037f9a1ea2918729f23212aa140b9b0ce80baafce66c7c6b8ff64ace2fbd304ff784ca5cccb422a706ea56cf2eade396548e7ac890751991f9f437606d4e6593a9d2bd11ebd186ecbaf1e9bde482f6b319b88591d28fad0eed954cea8571e14d854702dbd3ca0265ed1236c25e1776b265b2c480adc2ada7c250fd036a4e31a99d904f5c42ab015b087fb030a367da19daaf08590e2a4b7298d6097fd55255dd71c8b52125932cd7186f62636d95649cd82df1875777bb8c0968f3021d6e7543ff8b3c6306737a60316225b188d3502387c16c714391c3a1857047e022a20b6244a6868297cef7336d5de5b5312298a03436f56e01295fc09ccdc9e6a185d0a4c8d8743809336a565d37c3c1fec8e088b80f7b76914fbf4dd421dd02350d7ad9bf90be7a357387e58eece8bb94d2771d20bd4c4bf642107995277f9e33b81530f7b29d499c5a834ba76db68da3859c06d27848a998f7a64089ec827110e2436ac105582cd7668fc780f3e7f47c52ff265adea26dfc45a6e256189ea75185bb70f5d6043aa8a0bf639ec7960b5fcd2d999bbfa974b61118caa43b8e5308a74cc10e17c42cecf1eccdbd10896475ad1ca86eea2a01f717556614a2727e2ed23b6ff5c801fbfc7cdd3493dc603a4ef3b5df4857a173fa0e77b79f0bd472bdf25f233a9dcc8b3582810132206df5c54c55fbdc092c9d7421f07408825642298537372dfbfdacec76bac519d7ef368b138e4f372420372f79ffd09fc44d068f011599786d11663a3c7c72fccb60bedced0a6d44933f0758b7dae716bd81be85b0e83d400fa99c8f083566003cad130e7eaed03db0fcb8dcbe75b8a9b909a60793bcf1feda3a4ce78b034b11d9b12997e2f9793c7711bfaa6309c21376aeee8e9b9e428c8e3beed38bf1003588c79bddc17125b188687d191c51d0c11bff44d82fae858f7cebbd71dbbfa26db33643f5d9133446a727546e5a36b5bf69ccdb6ae738c056fad7e00d2d6284c3df42ffa232212e900bbe1ade4f949d8c556abaa7bf1a1af23fa6e93d2a4bfed621cb971b49b1e30767459c96f0359d322e2a8e69ced7f3904b59b3685e84f388495d667cbed0a50d25ff06a8f1a31815afd642b2946a4f02d9d40a05f763c84fbce1d9001a8cdc0e4012e836bc5444ff90878ef8f09f862c144968aee994afc0f4a893c8a5da6d4dfc551f7439fcef8ed3d037b974b463c9c9f3e8053b120807fd224f62219d1f92448801c4772e95cb00cec27f123bd9e7da00c821647ca2b7c01253d30ee78eca1ed5ff00cea300c9c3ff52547162f4a41e9efce527c5289d4bc21210506f9c70688509a07601d52cb8b2386db10506e36eb031d1948a2f2684c69598de2f6a0cd1e635f6776d2b6d240f77b149ffcfa4cc3f5b8920686478925a8f545c47e520da05aab2a41cb81b6b0a47faf636e4b11e502c828fe53d4b1b4db5ff7731bd8e0525780536f18cc048a338275caf1a24b4237bb9b4739988a4ad57f90f60aa75cfb4cf5c8d60b902e1e492c5d3eddf5e3280d1972ee3b472946ecd305e348544bf67bb7a616d0dfe97c4733c6cdfa2e08c65a95ec7aa90068ec1fab6ba9c7e28124ac938b627a0876d8d68bec9179b7a601210b1c2a9eaec8750f2410c2270f6032d1628b15a215fabe7f082d30e3f58e82dce278e0d557c8446d025dfb76cf3fdc531ee36aa6a53a28dd00a412a257bfa353bc9f622f288014f95bf93e8f9d7a7954882e826d3a96a01343d2746c16894573d24a8b0e475adf2c8ec3a000d67263412d611803b7e09e699b57263fdef0d0ca9bd4437b96ba4a0999921fc63cf251d566899c4a5e6fd697e22ce3c988051fa34a175d0b3347f7967293dfd94510c0d7144e42a7f23c4d45a94cd5abd7b55c345401dcec8c38fa4bb93ec659f3d321fbe4adb8e6c54f7d58f518d52c433d6974b89fc00f769ed0748c5c8463037c0c16699a4f29bc43cdda3326692f49ef99878ba8207930732bc7e9a12604943369c21ac3fddfcb5a0a483456eea3ab57557fc4940a705f19c669c84b995a02ad106262919b8ed718d2fea5c76ae44c2074e23e74d5b19ceeee4b3ada98dd529a57b24d57dc9a2e67437a2953bde4b424b0c59143a2629a5553c23b002fb401926876af9a8eba4c3a2ae446697f385b3148fcedd236af97af779abb1a2cfa07a6abd36922573a9dc565d05dc3a2e47e4124fa00efd6d7511cd15f0c6a5acca366fa11e9aa71156a759b6d419f822f70b6a467926e37c736804ee818842a4dbd8e66030dbaaf5cc5ab423b341cb405434ead8110c8860eb9f008b49ae0ca4ecdbdae4868f0d23140911618deffa9f715830c5e3b11864282b636a907e7bb3592f8438d6b36848eb9ee5c8acaaa8b9eb35c26ecfbd0295057c7c6e5cf28bdd51d633d2a8b1378d3d73b00f5487d4b8d95f9edadce739ff610fdf84783616517caccef6dc9322d9d39a63b30f3a027b7d846ef4957cc5fe503703896b282cde7e0e4cfe495c99ea1ba46dee9465219d663a2ded6380e9265286d46835a0fad00aa348e3fc54592bb5e078c34567c436c22748ef8af38c6d7c9d9e73fc42b6faceab6286a67e19308ba76fde6cf4d86e1ccfff0ff5accff447ec5a915d1911a5a9ed9058054b2e6690f58b1b542dfa0b2ca8d499cdf2e8d121a8b3a51121289e87a4d9e83601f583fe42e7a2b1d4581b4afd1e5391b3a18bb15ddf3b0db3b7dbd4e577924590bb96500a5869c1ae3e24fd968feb81dae206a577090d656ca8c39812f991a8e222b1e3ac570b910eb71f73a5fdb696df934546b9ffd264a7479939192c2ba4979d8574c759604d6c25c50ee814226f6a82278211244978e4d865dee6c331bb7c1b9ebc2749959cff112ccaba26e17a6f1f2f773eafed89f88ce1bcf3d41cdb185afa0e368a8a2436ff7fa2d1517df24cee90ea27143e87b8c038b8796154dc58ecb56efdd8c803d6d655f2b12ea00109035c4f371088565150551010a84951bd9a6997cbe1aa2ca7a2ea0eb0f3cfd22c134712f7c6d22bcd7be7229443816f1d5dc7b3d99785210311e052539bcdce5c2bb2e8b5fbc688f3d9018a3760ea779e8ae19ea22596509fc336573cdd9bf1d11212dce90d2cbc0716b3f9bafc3903296df0ffcdea298bd8bb1e6e5a5f3702f92111d23ba57d3e0aea4fbd364a05610af3a9b367d64cf2090ff447a3bb2ef2f661117100623c0400814b6e65fbcda70d7231cdb90de43c6c1ca6b919db89002d721b399cf650a00ca07892d200f44e2234d53d845c89639bc4ea499b31b5d036727ec5dbd9d030539dba80e3ed408c134eacedf0ec462d9960062ffe0eacda2c3d104649cef7f37e339073793ec76e8b8729a55520b65c3eae98d3ba1e793a2773160d771a59ff06ed8a35717a84496047a9575058cc87da2a7e865b0e1f5d825b29686d2ef7b79e942eeecc376e4dea4144f62a9fe4de5ffa053492fc05a67be4f8a68cb491802359b05e81d331bc5a8e340be888edb9cb04b31b66a59f3773027afbbc7c8b6b32c12b48f75264dd6a93f72f60d04d744a61df59ea9169fa108114240be494711d0f5bb3d6c3059a26a74460f647c38c9cb1e8db28ec843eafa8ac388dab1c47aee652275135f9455193bc28c42865b74ae0c7c975da5ec10c316782577ab77d3575c1987b056e8b079b098e5f3c5f5e77942722a888800b1fc47bf0d957fe9cce954e616aab23d37ae5a5d48d0c55386fa0cce22ea741ca6467eb43e73b7a8e13ff85f5fcbeb605e54ac3504ea1584453e08d7859974db3e047a5c0acc1a21197ec4bcdfa78fb4420bdf0c1383e77f4ca073d0a8a18deb0aa7e79e22016959ce0aa3c71cef88fc1898c9f48a0da4d43b2da1b21c50f1a6cb11a970b9c802b3fb89f9b0e5856d3ffd98e03c52de105b608cfab35dac9abba13e525dcc0335a42840d3d57a3b56dd2c79e5f2709743f9cb8f0a30c00570497ad1818fc0d5860b1201eaf729af7abc4a15d9be741b810de027d6f5d38a5defac618d0a25d4242d95e7cf3a47d353d21402dcab005c14d2fec969b4728a7435d5b658a271a5cd0ad9aaf0fd746da4c0d717c4687c781f225cd694acf06a83a11de1f827b571a00c738f84f53ff5be172731a6dd964c1a3a22ecf0a6b3c8021f6e47a62093237bff3164e0511ecd0f48a2ec2e2b9b5aee93d87a9407e554df3bcb1b427efe2ba73c2ad0c87afea678105eb3bd01238d4e7be706e80451c4c2c20d6b7f7814a43fd69cabaf302f302c4a60e3cbce4798983a544b2f522cf4a42a8aa539468a7d2bc7102950e77213c44f3ed3959e4dd4c0c4762c465205180e48bc3698c72ff9037b6204099f7bfcabf0b66497f7093a4590b4d5dd544ff31b2ff94fe389e34dc4c1edbcea25fa7e54897a80095f57050bc8b470ba5573dc977320bcd14d1131050025c75ff771d52c0303344ad0da0137545de3b7d51e232333b536c29450d715102d1a631c7726085da55753c733cfac31b7448adfbb713dcc0a915fe679a20dcf5734732bcc480240ea2ba297971cc82f9944b47a2e358c8f9104c1c73c509dd3019291f6375c5144c9168ec30b5b1f2af419b2559f11390e7c7af26d2ef76da8d8f7476197c920b8e2811f62133ef9db350ad01f617353d7f9172e00f85631ebfa1fea8f596ed24ea5352706d05614928d2a782d9e70af10d09e98010852c86d5ee8b1c2d37b8649659b9340bfb9db32ec532700f9c4b39cbff2e678b486f99b1ca53c5acd0599fb991d23859af15dd2da79fbaf08df139734900fbdab43c4fbb56fbf5ea71bf5c5d3ee1712bac119de8f8745d8afcca752832b842f7fe8e097694814329ee3a54a463bfaf9e8ee1178e0345f91bd7f100990d816c5bc6ad8f54f4e5330d44b8567fa9f452bd32b5821c1395038f53f3ca537b27c99479b925cb4801827d0193d4b671fa219e8d351bd615c940637036ec15a90f6d7146d3a653687f3e9526333a817a7ae126d867b2897a24d4dece37e706506eab9cf422feb20b932a9246d42361e3061f8345eeb262e5ba879bbddebbb490a5d11412eb2a85f7dc4a13c5cd3ef289a6a6918319c3d7b32b205aadbfaff34828d0c434729047c1d941e9197f2f7be38cd368c43f944973684a4075f4f34f5f0c8efb13ff3176b8fe71c69a225312504e42ee0005676a0eddba569d85d3e9fbca3fa749c1de563b238bb561832451ea045a1d70c3fe2418a982e1271dcc8a947fddb603f757ddd5e764019530d1ba567c8850026f6e2a92a6101ab62abcadafceff664660a7cd7cf28f708fbfcc969b8c475300ed1ece4859dac027a50bdeada48c43ebae16b70b24567e0283b383fda33b26d6b029775dc76a4603a4af555a53c1b1a74b59da550654302c8f79ca63cc2f11eb649463c6abe89edc52e73fad70d97d4e114d89bf4271cb2f4badb0e532d99cc2a970a1cc6a04bf6eb7781c62d95c3f5830cf09cfacd3f15b9fbe684fc673dc446077e4a263a05f99353bda4063fea032d359708983b9e8891c86094ceb7e721946c48c1dd66108346231b4d43e43addd8c638954145603bbf112cf01142ff5d51cbde31884042729a20a255a384a1981cb41c7c7dffd6895b0c613700e02ec7619247c8f5293700a5110d432692ebc81952b3842018cdd7462feaba873fabb5f3e8b3544e8c3fe23ee81df7ecec029b41b80ed51f6592845dbbd19011c1aefe8ed856ae2d105bc80a8585f54329bb96207c5ac7c4eecb83615d9508a8b2afa13b21a9b7288e4a33b3078561857e5505cd6b7ec42704626453be9cb684beaf62f56dd7d5b1192085eeed45f0991b70ff6b1c35cb102fbff3f471d862a53f37e82a3ab2699d3b2b9ebacc46632e994df687149316f9be32ed7a2ffb30a266683d782bf294766013577591b59dcb7d7a69df70dea5020f6533d78aa05e4b842aae629720d889096752d678b814d9a0e2e68737746865575feae4cb3957958243bc93e8c9dbbbb76b60b1c53d583ef862fbc4185b034a18254b361b301201754f159116a8bad5686e5a24a2bd24b193a860d1b3792cb7b1db049e10f68c051032310d7e846ed58d3febd71516ad9902eb8edbf4446794ace53ada87d837966a668d8d71435b8ce7e0f83c613623ac72f2ba05615d8ec22362eb417035326e4fcc1b150fc5e9d84e4e17fe59fa040c8b21b10991b9ca320359d493d701c8b86c768d4bcf4cfd6a25d1cfc52c72d1f902645dfbe581bb99ae46c86be2077a114fd235d5b19a8370a6517c2218c2f848faa53e4653b42b18497fe37bfecb80949ccb1689d33f85b0b035cef16e243803a6409acacbd43ca9ee90f25e9bd31307b57f0d730b64cebc3cea47388cb7008c6a3f7fb956f645214bfdd417f7ca8af055d8f2b1a414e2b81c522fd132fc09c00794a245767296fd9b8eeb698530935a792a30792634cb8b1a6055a512a7a44bb3d5b686cf23325db785518ea537ecc9f346b3cef68ec75951a34189ae8082ccc2824d86194e2848cad411a4eb9b7a503f4564c7edaf90d38bf704b4c69e3d228c68893e025ee1f2df09f5eea773bb3e96106bac6a2e443554ad09be84417170170144de34a5711355d33c48f9ac277b7fc50f2da153a1e0f4f4d54888c359bb5dd422ed176dd9d87f98838557ba357f3ebd954cbc463736cd9e1fadda628ec265b7420e13a271e7fe215b77aa85a50111ab1f9ec3e09fc04702aa5f1205821d41ca47865bcfaad996ba57a08fb76f82704730ed0b22dbc28398a72dc7a0238cfc81abddd76ea90a1035308a35c9a0feb65d4a571ec089150b1f3e486c09f92ce669259e9c36f0be4a659a757f49b384863ae7075f276b6e37c03a4ac04b271864c1d1b52fe250b2f03448b7eea2fcb7c0bf59227e700d540553bf57af59b6150d5bcad17f660a05f1b676aa2dff595dd8fcb40816f79e84fa4fa782efe025698eb1259e5b8604422f83767369ab839d81c23b0b95f1d025948ebdef5f6e3bce29ff2e1ab55e0966cfc791777b386dca771d09f2923342816539531d0f2bce9235f8d07e19bb782de6ed6f2d9a06bed558d9f2b6a10d1c23544e14edc5d939b38feda9a8d353295d77c753f35c33b86441982657791ae6e9de84d2386ca75c7e99c628f67c09f57fda2019b87f77f80d4ce07e707336cc70062a256c06e0c9ee3788ea491f7b0c7e70a12edd58b3e3424c8246788163d33a3e4d23f62de1fc77619c68747d1f678173465210d4a785ce4f828a0e357764983bf9c74a70b75d78d3826e059d2710aec6f8a0abdcf709969ddd2bd9c5fc5a68276337fa3241b2a9c6472026f693e193ace65357f9490223c79cb20289a8b290958b59d1dfad5df04f31ff7061ca8eb0808789e3860fdcd0cf8526824f2816c293d634123ebbdf4fa4db45fd6e73b1999cca8e4431480507b7422c228bf06cc3140cf2d424f2d0ae2e1321f7e052fd5b047c6045cab3c95b85c4b64701314271d389a2be68028a04d09af7b6e03a1b4f6616f1d645a11bd4d289e9bab5550629088a3a2e9742037a313844916373086803c7690464bc43a66fabc774495c4a31b6c86ff547cea50e25a6577460a3b987aff18f1608fcca0686ffe4128b5c17eff6808bc196beb3c4f438dafa0c683b065055fa522465c271c81f7dee17c1aa4a600e57ca6202e73a0963f102cbffef5d2e1b856fb4160e5aa45ea8c1c28aaa272fc53bc661c47aaa45e9311eff6f455ba0a31354dec1e6b913836530411640629058d330c6f64f920b202cccee92b23f5df038b552133c57c247320a4fb1af228a8ab48a52ca5b353f0d1f02da4514a7bfeda337db2190d312fe260595ca5f77f1a2f6d362434e1022586c93f888a3bcd7a086a896fbb58159059f1636e3f650de6f6f84f50e4996d4df38ee0d4830f5f2af0669cbbb64d4df415433b0424f46b34b1f8d2e5dbda6428870319c227aa7630484f2084258f8cf9d8d27da48b98b01675dd554f0b76d4e4f8937c8b0d7480b7e0d173cf1c73626ea2cda4c3d1d490fe660a521c35f525574e31953180723d70eddb188da540715f62f31f3433a32f5891390c47c0c9178cbdb419ecd441d6e2468056050a4e91c0569ec2af5f6f4d98e8453959dd2fd3ff6c353d7bb19d37266d1c74741034ab1de78d2e0ee64f2cbaab7b614e5804602b27375447683825d145f675cb0cbf1da3f8ab19e004120115e63444e4a705f9e46a96e39b759d905e064353ff38fc766d1892f59dac05f2a20d13adb225a52fce6233e3d79a77273e27160bc19df801b5600f6da628c18b4d55cca7904b93ea962721c7edc0927de25cc72596cccb9db606f5078d629a5b735ecab27543302f2767c9b64a7ca7c097cf8133d09d5e0c780a814167d11c5bd157a32ba313fdbc01e32e429322203f8f716fe30a33df9de7101a34b20c3b2363189d110fee2f2a368fce0c092c041b8d3c68d849894271d8213f1fb5f6d36c5ded178172a983c8e12a3b95c99fb51e1bde6766a14d45de8e0b306d11b722293805ca9e63f84d14197dacc3ab0e4dfe058051622d1d6609aec8005fe1fdc8adf75731bb66fe384733304b4177ba45eda0b99f64a1ad4affa0ae545cdda343cfaf176df2156c510e06c7bb50e288fc029caf443fec919225d0ce426cf0c8bd5af570bc11f482a72a656a23ecd739c91089ccc1066ff9bd9180e5d5e7afe50fe9b5a163d78aaa77444683a6432a27de62564875033dccf0811a8f0fada80867f5a0645c4f94a7c3469ede996bed7cc97b66b19b35bd92f2e7b4912dbb51ecdb67d323cb17ac1a72060d878bc1736635d800937488be8dac49d80c57b542175dcb06ed0b2f919b58d835b70bf6db27fbef01cd41bb9f789cf21e7e74c2a97cadb6eaef196dfa41238fb27f0c9369cd6a3355b4c6cfc59f3ab2055d897784bff0aa9f1a0c378971b25e894dbe4558f07af7b47dbafab92fd057b6c01624e60b4d1373e11990ce98615684e6d853fd81c55a2cfa3b7fcadeccc519e0af0537703165a304b75deebd9091c7b086417ce24eb008ad927d6325c2cdc15845d50e70e4e400d0e384f80b052008d10b7e90339d346fb50aa35486e9e453342c0d2897a982670dfd76acb356e955cc0ef0353a73e819ab42831f6cb6d2e4dfb9edb0c8a87a44420dda25f7d49360c416bb6f172a96e82f67c9d31e1565ad14160904fcc51127e49ef872d1cda087e647c08d0cef73706eb42a28f9fc8279ba55e26ebbb982de9bb244a9b4c6c06cc361ddf8c5a7fefb0f1d56bb808436c8766dc7b1a5b68787503186fe9286aabd95a04ecf2a5a268f10cce4603f4835ef2f2ac538be878dd601b0ba20befd015acd062468c1b04f85c4080783eff54c27ea3502b60f79d20661f2236357c5962b6be3d5fbe8e200fb594ee3d6913a92d11ae36d4a0a16f25d43ac04cae0df10cd3a879b1f6fe6ebdfa4e9e787fe86409502ca49d05173cd6e0d6e1207134baa52db77a207141a7dce1af57a1dce1d2f985d9455c9701b87d43913db23f26082bfd93f5be02d7a646f10072e1ef77ea1dd05fb4a8abe13b321ccaf4938a46b8364fb0fbc0a65d12cc54b4f045db69b06a5cb3b866f2f53ec494af0bfd1ec67bf77d4aab2871a45c968559bc860ec173a52398f0d2c457dae1c1df266eab63776b43b4ac6f6671de665bde450bb512eb892ef09524a3f86ab21db66f188f75ac7f2dea2f622244a47165c9406a89e426c6bf8fb79f7e455fe226b07559648ef0d2757125260e4546075ed4c6c5ffa1eb18ee3b20b1e737a4a0c7e11d763b9a3d34f81ddc43b44d847b956599dddb581773d06840a51ce4b8ad4fff2bf3fdc784a1589b550366369d480cf72aad8a98a5e911135d2ef4dc36336a3ea596fe6389c22e39b7e2505153a2ffd3eb39af1ed970674d5cf93425c801fac91756b34cd865769dd27b9b26f36c5de822fc05913681e98a7705f78dd3afd44e82b099c5a0ec4661df248839f6fb11d456f99ff8fe7eeec1ec54b3d7bb89dddc567d8ff87f1261a17bc8ae0ccb987f1c6e9e912cadd5e59b106bb09a91b1b7719d3283a10d9b7e1323e3faadf1c939f04b956f7cc65286e3613a8360bd72485912f63ed186d6ca2cf5a2b485f1eac8cc37fd0602d31bb85360e1819b83024f1e730866bb511021a6dadfe0702819bdf3d6047ff1e4a7bc17e9d72550f738482cb7f3533324df6c66a7f22285bca3d1879889c598af44d47c248bb098d6fa5d6c8e3680e0356bdfc4d67e4858d48862e25eb0c378a279fa872626bea888115a4d42b9da91ad64081589d511032e344d2fe6de59c823ef2893f173d1fdce51c57aa81eef348f821689a5b45db7f0ef688e67770186becee6a0106e6219524733ee3289423b6441ac50959802c0d5d4dd5b1683e49e533f3edfb3af801848876a9cc9646c71784afd773683d60fea558017858dfa63af321b1c431f204a0d8e62b8122212631e96dc5ac5f7323f9efd037ea741eeb8748e9d0a9201ed74ddea2921acd795055415b88e3478f3f4807ae0b24f30d1a9f3daa6bb337660a6233cd6aa805d94c0de9eb99ddb6e302240c9659dbbac5ca19abffc6d61fdf7d0105dab9bda8fd9654a8f824d8c16f9f060aeaa17149803889a6d1f59d830fae30741eb90177a7fc2a9e9b6e47d9d1b0ce7bc143488f707125442aaef5384aeb3148c17ef922cf788e2a3e53eb485830635d3c28da77e7104e022d4b20a788c5f393ae31dbb3aa964f1c4541341a7fc41b88842f2d22ada7fef029fb6b836b38a219eca84e2362799f56ec3d99c1f9568116b7ff04b53a654954258dcb4d46524f5272d20bf471d41cec59b4bfe107f0ff8fb6c1bd0a754cb326c50551c5f481a29cc802b262e5d2caccd46e8a2fa3dd73ac135b0c48f6ec716eed7364c2217f6941fd7a3f221c71056c32bcad10269825e03f8aebe74fad51357775d3deccbdeffeb9b7d483d45aefb7ccbf0a097c9bfbdba3946dafcc57a106a6b5b4e27f250616b0ad795066eae1c135e78c82b8a6d68acabad6a69a0869212f194c876793434e573696aee2766a670766236042aca3381e766f19824e8fb5c9f9a8551c5a37d79dacd155d146eb80c06861fb130e256b27b8f2e73aa3cac576227ffebb46437e8c0cdde4352c9a7056b709f2b8c299a0b00afc9735fa3f9bb459581b2dd3814a7d5d618331b1942f562950389f605ebc6f7aa9fef02874ddd1fd32ab1813ffea992ec205d4660eb2d96865b9930a00314993f69fffed9eb9deb4630f83382b66016223556f7c262011d9a1beedc596214624f8f365245ba84adf242cd54948e2f13eabe7f9567d6aaa4d89ab171ec0c8da385a7fe27d4b9f178ea97d5e463f6692ef1128476b612252eaffb3246086b6710da4841d258db4d7dc1fb4c8f40562d1b7163f1c45dd45d5174a6dffe720d8a5241237e1ea32f45079bb629e3af38dcae0b081aee83f196333842787bec3a646d8c1ccd3131769d8209f40d3063ddd2b025b8a1de9cac1c704d85fc961ff242d2b83ae69efcda996c72196360891968d4bb3d163da771b18b145a6a7251890f2cce873dc244679e86b80915a559e4183a2dcf4cfc924f4ea7465c027d253e6b9220aa3f202032f6aab7df3a4cbd646e08144afbb43c3ebafb45f196a590d51ea6589f173ac32b9bbc96e3c281c9a78b1628c7ce651167f9abe832bab4401b8e160cd129f6328ff66939eff7932fbbc7bebeb99c198c6dd07201a83ad0362ca30393a18cb2a2c0bf73952da51c477cd07e37d823a6fd6b50d6bbb0c7d622d89d6c8f26060a24a0aa4eb8aef0d22729c5f10bf32fc2dbe28b5f614531b8546242ad53a9c9889664c5b3995ee553c0d32f43deba0a04172eab0530e4273a6903479f168846251f6f29a88be207373308bad435278f341f6ee5d404da6da6b36de111f907c74b6240e40ca561d7ad39ca1aa16ac70de9a4fb0108880087036ec885e1b6f9fd28ecb830414ba76ccec69e732157628c54946b4664db7239592b8aaae71450053998ef984f5491c3dc7114b179077b664fead24d441bac5b9c270df7ef27845cdbc283862535698815c151fc133e10c5682a663fdfc4cbdee5053fef5d9c146c0a78efd73418932d271c4b2548d2b27e9c88c39b9704a22d04e7e89146ac2647c5e87a6f6f48fb659cbcc4a320cc4aa21cdffb8c0f28e494ab2f50cd9638725275b1e6374c844d4b9c847d3cc271441f7e7b2adfd2c9c0b5955bc0cef04fce742328103b689f6c25e3dcf2fd34f01677d935567df40de6dc94e0fdda4a3c7a9cc76f52383740c9f39182e275e3d4bb2bc692ae1bf600a6f010a69c0da44e6262ebfcbf58ee8f738efc3feefed60fd02c46152fe4737205b7c87e114e131fcf93aabba24e985851776f5bf6a965b27eeb0ddeed4c1359336c4ce86940834f855e8e27bf350a39b390f8c702811199c596065646856aae5714574fa262fe891e07a7a3de5dbaee0a6730cda21b918aba91ec0d5e113395ec279c1c02c1a6bab399f04758d003320a5d6bb0d67c8d461f1da71d75f424d0b87f0db99964193032cfe79b1237a993791b3cb9d9d9b9609b267319984538e9318894cd2fc6bf9e440f193f95b27bf9634ab6b853592c48637e7bae5acd72bdd57d33bd35417b258c26b8da992db98218a34c44b45224052afe6761bf2d9331cfe3e7eb7b9b0f85614c68a6337dd6a6eebc86b743717febbcbb094cd8a0f8fcf4a10db80e864f887edcd417faf4f77f6753ccdd0b1489163e7c9a44ed666712c4e4dee93c3130efbe89fdd827b4cbc98006142e3b93f3345c18928c209b6aa0b984e9bc635080da78e8e8a4b62773fe57d499ad92ec61cc83b8c8e013de8c169b70c8aa089c3596c5a901bbb011fa9c3b26385f33e4881d142f31c5852d7ddca6c6213806d50f2d2d7f77b6dac7785757f1297b42350332ceb1806c0afcb49a20b797092ce241219d6a7fb9d17249ce0a937d1eecf0789765c6c211e650d8573e4f18916cf09d3738169c1f72c2f54c32ffe02c2ef6c4d5ad71e068fc597aa25f7cc59d34814c378411bd4f6690ea57f9c255337a86804972e9559555388db4eb42f268c06f8a9908af4bd42087d27b269ecf7f5dc2200fcacfc20273819e4d2c0311a47b3742495d624f81bf80d7e6e9922af02c7bcf3d990bbc3387275f44843be974fba1660256a81ebfaef9ffc98d7db7286cd9600ff912309a4851f847c02fc59ad559f37edbf38e0540bb9c36ac9bccd96a49ac0f02f95f688642810ddeeb6c9c7fc543bff777f6b081d85bd0a28d8e79f25a34ee581596cf7eccc9cc3ef6778e159100a61e5afcbd0df5e9afa7d283d0863fe342874acadc01d2bd976a6f1fd3e417b99ad36fc8785ac36f141858bcbf731a5f39782c749a8ba1e75268328921f70347cce1fadfa20f6d9ddc5eaf8e6a73b592a62c0a7dd065feabb2c6e514c9612a8f9c3f7a64bc80f94090d4b1c3d0bfe25683777193bcc53b36ec543ac194441de00219b42855d990018307508ad41854e6d7c042cc0fbb71e08ec45bd5ce8dc277a2feb5128d5b48669ff443d5d41d8bcb66a2bd760917bc6bd9f34bbbd8af583c17d7039e726b9747eac02da77c7781cc434a5db9e5dc7ac115250f2825ff24cf1b2355ee609e7dc481c790bd85475d0f17ac475f4678b2c9b884d8636afb6cddbeb0a90b6f426aaab663dfce8f082d77285091242c1e59d0b1717bbae965140246577cbc5cdf4f1fc22c8cc9d37a6b2ee2cfa4c75c05fb6e57cb74c446c0e0da22e4872588bae61468b9b5a9a9033fefefa42e7a7055edc6a8bf5efd1f2b991c11413936b52fe80ed23e5a4aafc8cbde657dbfa58d45c56023c8ba45c9a7716f6bec962ad4c52665059a1ab0afa0c8efc1338619b365d085108c7fc7e1d7cfda37a575706d56fc08891ce5da3bac7980674c938bc7cf14e2ad8de0ce15c06921f3484aa758f208a4c6b3b03606feaf4a02ae0696f364e55892126a4d5cdfa0ba27b1d994b919bbee499e8f290dbb466407cc47a753f07a28ac35a97b6827203f199c8ba7d3a3d695b06419be0a7f75f5da71c8e6ebfaaccc0856e2e8d9aea4fea843652bcd4d433cfd078238024026a0165a81399142b209d84710ee1bcdc75631201e3cf1e90c08a3fa88557db3b54ced36b0cfa7c5cb31fa358968f7753845a7c7d67df239f5b2457573ac7bc8da66924f737e34c53ed09611b803d68399c40fecb05c3bb7f4e867ff67a0024faa3523cb267bb6aa52f634a9847142658a5ebf72868344caad595e8f7ca79d656f69988b15c7d1ab90b6899e9f6747b149b42e16314dbc376fbc4c571ae79647b30b285b9df73c96723f498068cee4263d1daa308816ec16b4e3cd6c61899a7634a4c2b0390c62f0b0627e8b71ce5b6030f2f9aadfca75df37c0028d4e4b878acd32b1ddf0bc683ea428e66ef792bcf5bdd596a5709f48c48a182649a441ce86fb79005682a2e20ac9bc1e5db6851684e318a22033ad8de9bfebc7909f4b5d1dda92c7cdadffaf24ec3f3684400da9ee49228f9e983c6d33154d45e1c4ee8ed68194690ea787f786b85beae035bbd4eb7caa412a5a7dfdfd5c3bc329fb7f5fb6004314599a21d4299424b9fe7c36598ccef23c58d5f00ba48403c5ebd7b52138fb0c5576527b708fd4b738ee5efec21da2d16bc9481cb147817f0174021b509564a418047cf5aaa5ca4f3b479a698f708b62705c3c1b026c9fe7d3cf6a852b019c0a2338619fa05547812d2b94165efdc791f570da59c57e5561f5bd66c64030679aa65aa4637812c2742cf0ab09a782857e81054377b7adca8434a7aee98024b6679d340907d998ddcb76e965ce59d1b33ee8b4a38acc9b553958f57ad75b5b0fae03686e360ddc2a351a53494c841848de030f30cee109f56db35d423615e252640cffa6140786e0b2ccde32669a5868d55f747952f0f5e5602e9ed04c32f819ea8979f7e86bbc52afe1f4347368a13ba6ff2f5595a0ce0eca9b4c33de12b0ffcd9315fb6d8ab1a9b500accc4ed1e6eaacce9b73b371547c8b9fb5910c916484361e013bb99767fd28d83b16d876511f9569b4c858250e27f7a76594aee10a38cd4a9f210ad79d30b76239e11d6ff911a86ce4544bf24a8ff603d2008c2754d915907129de9951deba3eaef415f568cddba318c91e9498a529426160ead94e1b5e7e8a0a5a5c27d20f7565136e12396654c03d447b85af5bb2f5d4dc107eddc8bae0697ce53614573305027ff57ab31cc18d21be01662fecc96df11339cfa33e5f6a3f4deefd3e6f9b054a549087775059d193ecbfe3824b125ea0ea555b46e46f9a2aa6f45d922a96ac3fe27a1b37a444f875af9d913be683702d20af82543e9009b30209c415877157b87bc3bf774952d39c2356543339cee9bc4e08c42eb8829f859b3cbd2a5907ec842251704bf39f6955edbacec346a8b5b4bd99935e461dc736b38dac615aa3291e6a3c0ecbc21be0d46ed24879da8aec3042c03c09ff8a74372aa1fce2f2618d2ea6ec3771e5561d55d4d77d95e2a3e48910e4d8a10876bc184017452e8e3345c5b2f80b450d11c02fe74ca7fe1cede76c1d9ab7a960ea9266c9a777bc8c10af43d45a36bb73e41e5d0ebc0cd4f73071eb5bd0fab68aa2eb536abef111f728916b2f820b1f1dad92c137611f1d9a1e3cc5c886bfedfbbd01667ce61230a5c242c4fe9a16a3c81bd86a33e533a1c3fee110a50f48886c6f3919ada1e1f785456b6f8e23387cdc71c056eb8a1e3b0ec3f8cac76368b2c11e6742c2185174a001168ef2eff049375c0d761ee9a42a2edb65b10e27184f4b8c999c466c3f3ef36ba02cc88a8a9766b95fef8a0cee8f941864cf8c39d6eb746a31994ce45998d9dff05b5370762f79943e7c284b3b28cda16390a88eff7756611c306ed9280ab6083ef43a3994e0cee9aff1897948c2551ab46898c278d6128771cbb411d4b96f1f1dc72e772052fc34921cbc7c0af2baaeb5f61c79b909c4b1828c24d58e1b122acd6db3f15a57d646b33f14c28884a5b48e51aeb4d23d12bb2254dee9f3e60c4fb221dac3037f4f9807b5311fb5b265387f569f0a27550b7b29da6605003b5871d56f5fd3d354886c4bdc53aaf957c65c71aac7b1ae654e068142f8d876a0dbab0bb3eaf8efb6145560b75bdef038655829a33e5206b982b1d261f3f00f68b5a92948be3b9a8773ae7e5a942586d55275a67054cc9f7ffbe3d2297a440e33e3ad39555e71293b46144b1dfa5ea2209481b649a0156cd4ade730f0d716efe2dacc969357804b59afda155311d568a1cfab3d6b9ebdee884eb6293b4324dd389ecfa49dd3b54159584c0fd386ee14b687366845dcbe84f0792a17ff4b5a92199a6cb3f5ce11fa8ac7d13287bddd3cc0425975a6b81b9c9509bebc6ad994106588a970d56a3600724fe6ddcd967e3f82fc0fb756df5b750a8a5e8e884c6abddb9e483ce7fa0b591ddbf2440f5f74067aa5dc15bf786942abaeab1333d1073ca842daf7e58f31381d4633a0428889830df5cbcc016bd5a3ac4cfc8b967daf6e5c200ff457d433d4d41211cf373a72705aae45a12a233d103cc68816c06571a846a60ebec0888a7e600176c1fc3948997e05916cd4eb3f70110c90e5db41b917404cb76ef5dcc9a0a52a431131243a2eb4d1560aee3c610c55ec15bc721c1b6f23d719ef151fc6905d7593efc1d8ff25b110e67db986e411d441519c1676f40f816243f7c04fd218e8f0796d16b5ec143a50a897a3420c896e872d4097c2003176fb221b2a1849b245e59e84e6c6dcbfd92d20a00a8f457773a4964a03a1908bb579970e44bb8adcb0e2c1e3279217f319a9596b11a92c1a020ab6cb467fe307320af20146f12405368308a9625979d8b0bd24be36fed374a7a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA_OO_Unit2</title>
    <link href="/2024/03/29/BUAA-OO-Unit2/"/>
    <url>/2024/03/29/BUAA-OO-Unit2/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="BUAA-OO-Unit2第二单元总结"><a href="#BUAA-OO-Unit2第二单元总结" class="headerlink" title="BUAA_OO_Unit2第二单元总结"></a>BUAA_OO_Unit2第二单元总结</h1><h2 id="一、第一次作业"><a href="#一、第一次作业" class="headerlink" title="一、第一次作业"></a>一、第一次作业</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本次作业完成没有耗费多少时间，但由于对多线程的锁的了解不够深刻，将近花了两天时间来debug，中测也是交了五六次才通过。相比第一单元的作业，第二单元作业在代码复杂度，或者说代码量上存在明显下降，但是理解难度却有了更大的提升，以及由于加入了时间戳的原因，对于某些数据需要耗费大量时间在等待结果上。</p><h3 id="UML图架构"><a href="#UML图架构" class="headerlink" title="UML图架构"></a>UML图架构</h3><p><img src="UML2_1.png" alt="UML2_1"></p><p>本次作业中实现了三个线程类：<code>InputThread（输入线程）</code>，<code>Dispather（调度线程）</code>，<code>Elevator（电梯线程）</code></p><p>此外，<code>RequestTable</code>需求表类作为共享对象，所以内部方法全部加上<code>synchronized</code>关键字修饰，Strategy作为Elvator的附属类位电梯提供建议（按照作业提示，虽然本人觉得有点多余，但是确实代码理解起来简单）。</p><p>作业核心思路是<code>Inputread</code>读取到请求就加入到请求表中，接下来再由调度器将其分配加入各个电梯的分请求表中，当输入线程读取到EOF时电梯线程结束并将调度器Over标志设为true，当调度器的请求表为空且Over表示为true时调度器进程结束并将电梯进程Over标志设为true，对于某个电梯如果其分请求表为空且Over标志位为true时则电梯进程结束。</p><p>LOOK算法：电梯接收开门、沿着原方向运行一层、结束、等待、调转五种建议首先判断是否需要开门，如果需要开门则电梯执行开关门</p><p>然后，如果电梯内部还有人则电梯沿着原方向运行一层，反之，就判断请求表是否为空，如果请求表为空，如果请求表同时Over标志为true则该电梯进程结束，否则该电梯等待请求表填入，如果请求表不为空，则判断是否需要调整运行方向，不需要调整方向则沿着原方向运行一层。</p><p>分配关系如下</p><p><img src="Dispatch.png" alt="Dispatch"></p><h3 id="作业体会"><a href="#作业体会" class="headerlink" title="作业体会"></a>作业体会</h3><h4 id="锁的理解"><a href="#锁的理解" class="headerlink" title="锁的理解"></a>锁的理解</h4><p>由于本次作业对锁理解不够深入，于是我再次学习了相关知识：</p><p>java中有方法锁、对象锁、类锁、静态锁，核心都是为了达到访问的有序。</p><p>对象锁：JVM 在创建对象的时候，默认会给每个对象一把唯一的对象锁，一把钥匙</p><p>类锁：每一个类都是一个对象，每个对象都拥有一个对象锁。</p><p>静态锁： 在静态方法前面加上synchronized方法表示锁定此类，当多个线程调用这个类中的静态方法时会阻塞。</p><p>实例锁： 在实例方法前面加上synchronized方法表示锁定类的单个实例，当多个线程调用一个类申明的同一个实例的实例方法是会阻塞。</p><p>当多个线程用一个对象锁，各个线程可以达到同步的作用，如果每个线程都用自己的对象锁，那么synchronized就失去了同步的作用，如下代码将不起作用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedExample</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">numberOff</span><span class="hljs-params">(Object lock)</span> &#123;<br><span class="hljs-keyword">synchronized</span> (lock) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>num++;<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + SynchronizedExample.num);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-type">SynchronizedExample</span> <span class="hljs-variable">se</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedExample</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">3</span>; i++) &#123;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>( ()-&gt;  &#123;se.numberOff(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());&#125;, <span class="hljs-string">&quot;队列&quot;</span>+i).start();<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>静态锁是针对静态方法而言，当一个静态方法中有synchronized关键字时，默认的是使用当前类字节码对象作为锁。</p><p>最后理解好哪些调用会互斥：</p><p>1、调用同一个对象中非静态同步方法的线程是互斥的。如果是不同对象，则每个线程有自己的对象的锁，线程间彼此互不干预。</p><p>2、调用同一个类中的静态同步方法的线程将是互斥的，它们都是锁定在相同的Class对象上。</p><p>3、静态同步方法和非静态同步方法将永远不是互斥的，因为静态方法锁定在Class对象上，非静态方法锁定在该类的对象上。</p><p>4、对于同步代码块，要看清楚什么对象已经用于锁定。在同一个对象上进行同步的线程将是互斥的，在不同对象上锁定的线程将永远不会互斥。</p><h3 id="debug过程"><a href="#debug过程" class="headerlink" title="debug过程"></a>debug过程</h3><p>花费最长时间在始终有一个进程无法唤醒，最后发现，最初架构时将电梯Over和调度器Over标志一起设置为true，这就导致了电梯进程结束了而调度器进程还没结束进而导致最后调度器进程无法结束。</p><h3 id="数据生成"><a href="#数据生成" class="headerlink" title="数据生成"></a>数据生成</h3><p>还是采用随机数生成的方法，并采用官方包进行输入输出，然后对输出结果进行如下统计分析：</p><ol><li>是否有人没上电梯</li><li>是否有人没下电梯</li><li>乘客乘坐电梯编号是否正确</li></ol><h3 id="互测"><a href="#互测" class="headerlink" title="互测"></a>互测</h3><p>本次互测通过数据生成hack成功一位TLE的同学。</p><p>和一条hack所有人的数据（当然呢，不合法！！！愚人节图一乐，后续被助教撤回）</p><h2 id="二、第二次作业"><a href="#二、第二次作业" class="headerlink" title="二、第二次作业"></a>二、第二次作业</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>本次作用增加了维修指令，在维修时要将电梯内部人员“赶”下来，同时撤回已分配请求，同时需要输出receive指令，从而要求我们具有一定的分配策略（但是，由于本人技艺不足，没有选择影子电梯，而选择了随机数大法），总的来说本次作业增加代码较少，完成起来较为顺利（可能是假期的原因）。</p><h3 id="UML图架构-1"><a href="#UML图架构-1" class="headerlink" title="UML图架构"></a>UML图架构</h3><p><img src="UML2_2.png" alt="UML2_2"></p><p>本次作业，由于采用的调度方法（随机数法）较为简单，所以相比上次只增加了一个<code>Constant</code>常数类用于维护电梯各项参数，暂时只维护了一些简单参数，从而实现了电梯内部无任何常数，代码的抽象层次更高。</p><h3 id="作业体会-1"><a href="#作业体会-1" class="headerlink" title="作业体会"></a>作业体会</h3><p>本次作业，由于电梯开始reset时，如果内部还存在乘客则将乘客“赶下来”（将targetMap中的乘客重新撤回到等已分配状态的RequestTable），然后已经分配的需求撤回到未分配队列，并清空该电梯的请求表。于是就产生了以下情况：</p><p><img src="Structure.png" alt="Structure"></p><p>即待分配队列有两个输入来源：输入线程和每个电梯，这样，如何让线程正确结束成了我亟待解决的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//调度器Dispatcher的run方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (requestTable.isOver()) &#123;<br>                <span class="hljs-keyword">for</span> (RequestTable requestTable : requestTables) &#123;<br>                    requestTable.setOver(<span class="hljs-literal">true</span>);<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!requestTable.hasNext()) &#123;<br>                requestTable.waitRequest();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                allocate();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (missionComplete()) &#123; <span class="hljs-comment">//任务完成</span><br>                requestTable.setOver(<span class="hljs-literal">true</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>当输入结束时，将输入结束标志变为true，当任务全部完成时（输入结束，且待分配队列和六个已分配队列都为空且不处于reset状态），则将总表的结束标志变为true，当总表的输入标志为true时，则把所有电梯表标为结束，调度器线程结束。</p><h3 id="Debug过程"><a href="#Debug过程" class="headerlink" title="Debug过程"></a>Debug过程</h3><p><strong><code>ConcurrentModifyException</code>问题的解决</strong></p><p><code>getPersonRequestMap()</code>方法调用时可能出现ConcurrentModifyException问题（由于上图所展示的循环导致），解决方法：由于getPersonRequestMap()加锁，所以可以通过，将所有涉及元素增减的都通过调用getPersonRequestMap()方法</p><p>互测被刀惨了，由于本人架构采用不给在维修中的电梯分配请求，于是下列方式构造的数据就把我狠狠刀住</p><ol><li>首先将某个电梯速度设为最慢，容量设为最少</li><li>在49.0s作业将其他五部电梯维修，同一时刻加入64条由11层到1层的请求，这样请求就全部加给了同一部电梯了，达到卡tle的作用</li></ol><p>解决方式：电梯分配数量加入考虑因素，当然，这不是一个好的解决方案，于是第三次作业中我换了一种方式</p><h2 id="三、第三次作业"><a href="#三、第三次作业" class="headerlink" title="三、第三次作业"></a>三、第三次作业</h2><h3 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h3><p>本次的有丝分裂电梯着实令人头疼，想了很多办法依旧没能达到很好的架构，只能不断在原来的代码的基础上一点一点叠，最后真的惨不忍睹，bug也是de完一个又来一个，到周六才大概达到一个自己满意的测试结果</p><h3 id="UML图架构-2"><a href="#UML图架构-2" class="headerlink" title="UML图架构"></a>UML图架构</h3><p><img src="UML2_3.png" alt="UML2_3"></p><p>本次总体架构相比上次无较大的改动，主要多了一个TranferFloor作为上下电梯的共同对象。代码增长主要体现在Elevator电梯类和Strategy策略类</p><p>最开始计划将双轿厢电梯作为一个新的类处理，但一直没想好处理方式加上重构面积较大，由于题目中规定了第一类reset后不会出现第二类reset，所以我，最终采取了在电梯类中增加两个Elevator类<code>upElevator</code>和<code>downElevator</code>，接收到第二类reset时，完成reset后启动改电梯的这两个线程并将其加入线程池中。</p><h3 id="作业体会-2"><a href="#作业体会-2" class="headerlink" title="作业体会"></a>作业体会</h3><p>针对上次出现的保持一个电梯不在reset，随后同时加入大量请求出现的超时bug，在bug修复中我采用的是限制单个电梯的加入到请求的数量，但是感觉还是不是特别靠谱，于是我采取调度器直接分配的方式，如果处于reset状态，就加入wait2Recive队列，reset结束后再将请求加入RequestTable中。</p><h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><p>先谈谈自己debug中遇到的经典问题：</p><p><strong>NullPointerException</strong></p><p>由于双轿厢电梯和普通电梯的策略类以及各种行为的方法相同，所以一不小心涉及getUpElevator之类的方法时就会涉及NullPointerException，当然这一类的bug相对来说比较容易发现</p><p><strong>防止电梯对撞问题</strong></p><p>如何防止电梯出现撞梯现象，是本次作业的核心，也是比较难处理的部分，我采用的是抢共享类中的方法锁和标志位的方式</p><ul><li><p>在决策类中，如果发现当前楼层进行move操作后到达换乘楼层，且当前换乘楼层被占用，就执行stop操作（sleep一小段时间）</p></li><li><p>当上下两电梯同时要到达换乘楼层时（下方电梯在换乘楼层的下一层且方向向上，上方电梯在换乘楼层的上一层且方向向下），就需要采用抢锁的方式了，具体如下的共享类Transferfloor的try2Move方法，当某个线程调用该方法时，将被占用位设为true，另一线程需要等另一线程的该方法结束，再调用该方法的时候就只能等待了，直到换乘楼层不再被占用才被唤醒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">try2Move</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (isFull) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        setFull(<span class="hljs-literal">true</span>);<br>        notifyAll();<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>等待换乘楼层不被占用的线程被唤醒后立即就会arrive，所以可能会出现虽然时间戳相同，但该线程的输出可能会先输出，于是我被迫采取休息1ms的方式解决这个问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">if</span> (isDoubleCar) &#123;<br>            <span class="hljs-keyword">if</span> (currentFloor == (transferFloor.getFloor() - <span class="hljs-number">1</span>) &amp;&amp; direction.equals(Direction.UP)) &#123;<br>                transferFloor.try2Move();<br>                rest(<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (currentFloor == (transferFloor.getFloor() + <span class="hljs-number">1</span>)<br>                    &amp;&amp; direction.equals(Direction.DOWN)) &#123;<br>                transferFloor.try2Move();<br>                rest(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="总体总结"><a href="#总体总结" class="headerlink" title="总体总结"></a>总体总结</h2><h3 id="前言以及相关图"><a href="#前言以及相关图" class="headerlink" title="前言以及相关图"></a>前言以及相关图</h3><p>由于本人对影子电梯的理解不够，选择的是实现起来极其简单收益也尚可的随机数法，所以代码规模相比使用影子电梯的同学要少，但是最让自己都无法接受的就是电梯类中参杂了太多的因素——既有电梯自身的属性，又有作为线程所包括的各种运行方法，还实现了第二类reset后的线程相关的线程启动，包含了大量的if，着实不是一个好的架构。</p><p><img src="codeLines.png" alt="codeLines"></p><p>总体代码时序图：<img src="SequenceDiagram.svg" alt="SequenceDiagram"></p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>从第一次作业到第三次作业，每次花费时间最多的就是de线程安全的bug，直到最终版本，代码依旧存在极小概率的bug</p><p>其中下面这个bug是我感悟最深。</p><p>我们知道，在我们采用增强for循环遍历时若删除对象是线程不安全的，于是我们引进了迭代器删除的方法，但是在多线程中，对于共享对象即使采用迭代器删除仍然需要采用对对象加锁的方式保证线程安全，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (requestTable) &#123; <span class="hljs-comment">//同步</span><br>                Iterator&lt;PersonRequest&gt; iterator = personRequests.iterator();<br>                <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                    <span class="hljs-comment">/**/</span><br><span class="hljs-comment">                        iterator.remove();</span><br><span class="hljs-comment">                        requestTable.subRequestNum();</span><br><span class="hljs-comment">                    &#125;</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">            &#125;</span><br></code></pre></td></tr></table></figure><p>而不加入对象锁时，运行结果可能正确，而且输入可能需要多次运行才能复现bug。</p><p>总的来说，单纯的方法锁和对象锁不足以满足后续更加复杂的情况，于是我们也又有了互斥锁（一次最多只能有一个线程持有的锁）、读写锁，可重入锁（可重复可递归调用的锁，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者class））与不可重入锁……</p><h3 id="层次化设计"><a href="#层次化设计" class="headerlink" title="层次化设计"></a>层次化设计</h3><p><strong>线程设计</strong></p><ul><li>输入线程</li><li>调度线程</li><li>轿厢线程</li></ul><p>总体来说，经过总结思考，把轿厢而不是电梯作为线程更加可靠，也更加能够适应第三次作业，我的架构仅支持第二类reset后无任何reset，但是倘若可以来回reset，将轿厢作为线程，并将单轿厢电梯和双轿厢电梯作为两个类保证其自身特性可以更适应后续迭代（倘若有的话）</p><p><strong>共享类设计</strong></p><ul><li>请求表</li><li>换乘楼层</li></ul><p>将请求表作为共享类毫无争议，第三次作业中将换乘楼层作为双轿厢的共享类着实方便，可以通过抢锁十分方便的实现避免撞梯。</p><p><strong>枚举类</strong></p><ul><li>方向</li><li>电梯策略</li></ul><p>将方向作为枚举是我考虑到可能会出现上下左右乱移动设计的（可惜没有），虽然便于理解代码，但是远不如+-1代表方向来的方便。电梯策略作为枚举十分有必要，处理不同策略，用英文枚举着实提高可阅读性。</p><p>经过一个单元的学习，让我对多线程知识的了解增进了不少，从简单的方法锁对象锁的使用到抢锁实现交互的实现，对并行程序的书写不仅让我的OO水平狠狠提高（虽然预判的迭代都失败了，但是希望下届可以有hhh），对OS的帮助也是多多。</p>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象OO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA_OS_lab2</title>
    <link href="/2024/03/21/BUAA-OS-lab2/"/>
    <url>/2024/03/21/BUAA-OS-lab2/</url>
    
    <content type="html"><![CDATA[<h1 id="BUAA-OS-lab2学习日记"><a href="#BUAA-OS-lab2学习日记" class="headerlink" title="BUAA_OS_lab2学习日记"></a>BUAA_OS_lab2学习日记</h1><h2 id="一、思考题Thinking"><a href="#一、思考题Thinking" class="headerlink" title="一、思考题Thinking"></a>一、思考题Thinking</h2><h3 id="Thinking-2-1"><a href="#Thinking-2-1" class="headerlink" title="Thinking 2.1"></a>Thinking 2.1</h3><p>问题：在编写的 C 程序中，指针变量中存储的地址 被视为虚拟地址，还是物理地址？MIPS 汇编程序中 lw 和 sw 指令使用的地址被视为虚拟 地址，还是物理地址？</p><p>答：均为虚拟地址，访存、跳转等指令以及用于取指的 PC 寄存器中的访存目标地 址都是虚拟地址。我们编写的 C 程序中也经常通过对指针解引用来进行访存，其中指针的值也 会被视为虚拟地址，经过编译后生成相应的访存指令。也就说编译后指针所存储的地址才会变为物理地址。</p><h3 id="Thinking-2-2"><a href="#Thinking-2-2" class="headerlink" title="Thinking 2.2"></a>Thinking 2.2</h3><p>问题：</p><ul><li>从可重用性的角度，阐述用宏来实现链表的好处。</li><li>查看实验环境中的/usr/include/sys/queue.h，了解其中单向链表与循环链表的实 现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。</li></ul><p>答：</p><ul><li>简化代码量，使用宏定义可以减少代码的服用对函数进行封装，提高了代码的可读性。</li><li>以下是各自特性<ul><li>单向链表：如果要执行删除某一节点的下一个节点和在某一结点后插入可以直接进行，此外，由于每次能访问一个节点的下一个节点，插入节点和删除节点相同，每次必须从头节点遍历找到节点才能找到进行删除和插入操作。</li><li>循环链表如果要执行删除某一节点和在某一结点后插入可以直接进行，此外，由于循环链表也是单向链表，每次也只能访问一个节点的后一个节点，但是每次遍历时不必从头节点开始。</li><li>双向链表可访问某一节点的前后节点，在某一节点前后插入或删除前后节点都可以直接执行，此外查找删除操作对于某些链表还可以使用二分法提高效率。</li></ul></li></ul><h3 id="Thinking-2-3"><a href="#Thinking-2-3" class="headerlink" title="Thinking 2.3"></a>Thinking 2.3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//核心相关代码如下</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">LIST_ENTRY</span><span class="hljs-params">(Page)</span> Page_LIST_entry_t;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_ENTRY(type)                                                               </span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>                                    <br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">type</span> *<span class="hljs-title">le_next</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">type</span> **<span class="hljs-title">le_prev</span>;</span>             <br>    &#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> &#123;</span><br>Page_LIST_entry_t pp_link; <br>u_short pp_ref;<br>&#125;;<br>LIST_HEAD(Page_list, Page);<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_HEAD(name, type)               </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">name</span> &#123;</span>                                                                         <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">type</span> *<span class="hljs-title">lh_first</span>;</span> <br>&#125;<br></code></pre></td></tr></table></figure><p>综上可以选出C</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page_list</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">le_next</span>;</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> **<span class="hljs-title">le_prev</span>;</span><br>        &#125; pp_link;<br>    u_short pp_ref;<br>    &#125;* lh_first;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Thinking-2-4"><a href="#Thinking-2-4" class="headerlink" title="Thinking 2.4"></a>Thinking 2.4</h3><p>问题：</p><ul><li>请阅读上面有关 TLB 的描述，从虚拟内存和多进程操作系统的实现角度，阐述 ASID 的必要性。</li><li>请阅读 MIPS 4Kc 文档《MIPS32® 4K™ Processor Core Family Software User’s Manual》的 Section 3.3.1 与 Section 3.4，结合 ASID 段的位数，说明 4Kc 中可容纳不同的地址空间的最大数量。</li></ul><p>答：</p><ul><li>ASID用于区分不同的地址空间，在多进程操作系统中，由于同一虚拟地址在不同的地址空间中通常映射到不同的物理地址，使用ASID区分不同的地址空间可以保证不用每次切换进程时TLB也要改变。</li><li>ASID有8位，可以区分256个不同的地址空间。</li></ul><h3 id="Thinking-2-5"><a href="#Thinking-2-5" class="headerlink" title="Thinking 2.5"></a>Thinking 2.5</h3><p> 请回答下述三个问题：</p><ul><li>tlb_invalidate 和 tlb_out 的调用关系？</li><li>请用一句话概括 tlb_invalidate 的作用。</li><li>逐行解释 tlb_out 中的汇编代码。</li></ul><p>答：</p><ul><li>```C<br>//由函数声明可以看出tlb_invalidate调用tlb_out<br>void tlb_invalidate(u_int asid, u_long va) {<pre><code class="hljs">tlb_out((va &amp; ~GENMASK(PGSHIFT, 0)) | (asid &amp; (NASID - 1)));</code></pre>}<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><br>- 实现删除特定虚拟地址在 TLB 中的旧表项<br><br>- ```C<br>  <span class="hljs-comment">#include &lt;asm/asm.h&gt;</span><br>  <br>  LEAF(tlb_out)<br>  <span class="hljs-meta">.set</span> <span class="hljs-keyword">noreorder</span><br><span class="hljs-keyword"></span>  <span class="hljs-keyword">mfc0 </span>   <span class="hljs-built_in">t0</span>, CP0_ENTRYHI <br>  <span class="hljs-comment">/*将当前EntryHi寄存器的值赋给t0保存当前的VPN和ASID*/</span><br>  <span class="hljs-keyword">mtc0 </span>   <span class="hljs-built_in">a0</span>, CP0_ENTRYHI<br>  <span class="hljs-comment">/*将调用函数传入的参数即新的VPN和ASID写入EntryHi寄存器*/</span><br>  <span class="hljs-keyword">nop </span><br>  <span class="hljs-comment">/*冒险处理*/</span><br>  <span class="hljs-comment">/* Step 1: Use &#x27;tlbp&#x27; to probe TLB entry */</span><br>  <span class="hljs-comment">/* Exercise 2.8: Your code here. (1/2) */</span><br>  <span class="hljs-keyword">tlbp</span><br>  <span class="hljs-comment">/*根据 EntryHi中的Key查找对应的旧表项，将表项的索引存入CP0_INDEX*/</span><br>  <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span>  <span class="hljs-comment">/* Step 2: Fetch the probe result from CP0.Index */</span><br>  <span class="hljs-keyword">mfc0 </span>   <span class="hljs-built_in">t1</span>, CP0_INDEX<br>      <span class="hljs-comment">/*取出CP0的值*/</span><br>  <span class="hljs-meta">.set</span> reorder<br>  <span class="hljs-keyword">bltz </span>   <span class="hljs-built_in">t1</span>, NO_SUCH_ENTRY<br>      <span class="hljs-comment">/*如果没有查到对应表项*/</span><br>  <span class="hljs-meta">.set</span> <span class="hljs-keyword">noreorder</span><br><span class="hljs-keyword"></span>  <span class="hljs-keyword">mtc0 </span>   <span class="hljs-built_in">zero</span>, CP0_ENTRYHI<br>  <span class="hljs-keyword">mtc0 </span>   <span class="hljs-built_in">zero</span>, CP0_ENTRYLO0<br>  <span class="hljs-keyword">mtc0 </span>   <span class="hljs-built_in">zero</span>, CP0_ENTRYLO1<br>      <span class="hljs-comment">/*将CP0_ENTRYHI、CP0_ENTRYLO0、CP0_ENTRYLO1三个寄存器赋值为0，后续写入实现清零*/</span><br>  <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span>  <span class="hljs-comment">/* Step 3: Use &#x27;tlbwi&#x27; to write CP0.EntryHi/Lo into TLB at CP0.Index  */</span><br>  <span class="hljs-comment">/* Exercise 2.8: Your code here. (2/2) */</span><br>  <span class="hljs-keyword">tlbwi</span><br><span class="hljs-keyword"></span>      <span class="hljs-comment">/*将 EntryHi 和 EntryLo0、EntryLo1 中的值写入索引指定的表项*/</span><br>  <span class="hljs-meta">.set</span> reorder<br><span class="hljs-symbol">  </span><br><span class="hljs-symbol">  NO_SUCH_ENTRY:</span><br>  <span class="hljs-keyword">mtc0 </span>   <span class="hljs-built_in">t0</span>, CP0_ENTRYHI<br>      <span class="hljs-comment">/*将t0的值写回CP0_ENTRYHI*/</span><br>  <span class="hljs-keyword">j </span>      <span class="hljs-built_in">ra</span><br>      <span class="hljs-comment">/*函数返回*/</span><br>  END(tlb_out)<br></code></pre></td></tr></table></figure></li></ul><h3 id="Thinking-2-6"><a href="#Thinking-2-6" class="headerlink" title="Thinking 2.6"></a>Thinking 2.6</h3><p>问题：</p><ul><li>简单了解并叙述 X86 体系结构中的内存管理机制，比较 X86 和 MIPS 在内存管理上的区别。</li><li>简单了解并叙述 RISC-V 中的内存管理机制，比较 RISC-V 与 MIPS 在内存管理上的区别。</li><li>简单了解并叙述 LoongArch 中的内存管理机制，比较 LoongArch 与 MIPS 在内存管理上的区别。</li></ul><p>答：</p><ul><li>在x86架构中内存被分为三种形式，分别是<strong>逻辑地址</strong>（Logical Address），<strong>线性地址</strong>（Linear Address）和<strong>物理地址</strong>（Physical Address）。而mips内存只有两种形式。X86 体系结构中的内存管理机制是基于分段和分页的。分段是将程序的地址空间划分为若干个段，每个段都有自己的基地址和长度，可以独立地进行保护和共享。而X86在TLB不命中时，是由硬件MMU以<code>CR3</code>为当前进程的PGD基址，索引获得PFN后，直接输出PA。同时MMU会填充TLB以加快下次转换的速度。另外转换失败的虚址，MIPS使用<code>BadVAddr</code>寄存器存放，X86使用<code>CR2</code>存放。</li><li>RISC-V提供三种权限模式（MSU），而MIPS只提供内核态和用户态两种权限状态。RISC-V SV39支持39位虚拟内存空间，每一页占用4KB，使用三级页表访存。</li><li>硬件能够支持两级地址翻译，x86到LoongArch+虚地址到物理地址（通过改造内存快表TLB，做到两级虚地址映射以减少映射开销，以及减少指令使用/指令翻译开销，即X86虚地址直接翻译成龙芯物理地址）</li></ul><h3 id="Thinking-A-1"><a href="#Thinking-A-1" class="headerlink" title="Thinking A.1"></a>Thinking A.1</h3><p>问题：在现代的 64 位系统中，提供了 64 位的字长，但实际上不是 64 位页式存储系统。假设在 64 位系统中采用三级页表机制，页面大小 4KB。由于 64 位系统中字长为 8B，且页目录也占用一页，因此页目录中有 512 个页目录项，因此每级页表都需要 9 位。 因此在 64 位系统下，总共需要 3 × 9 + 12 = 39 位就可以实现三级页表机制，并不需要 64 位。现考虑上述 39 位的三级页式存储系统，虚拟地址空间为 512 GB，若三级页表的基地址为 PTbase，请计算：</p><ul><li>三级页表页目录的基地址。</li><li>映射到页目录自身的页目录项（自映射）。</li></ul><p>答：</p><p>分析：页目录通常指一级页表，以二级页表为例：</p><p>页目录的1024 个表项映射到这 1024 个页表。因此只需要 4MB 的空间即可容纳页表和页目录。</p><p><img src="page.png" alt="页目录自映射"></p><p>同理，本题中，三级页表中，页目录的512个二级页表项映射到512个三级页表映射到512个页表。虚拟地址可以化为 $2^{39} / 2^{12} = 2 ^ {27}$ 页，既需要 $2^{27}$ 个页表项接收这么多个页表的映射。</p><p><img src="page3result.png" alt="页目录映射关系"></p><p><img src="page3.png" alt="page3"></p><p>于是页号： <code>PN = PTBase &gt;&gt; 12</code>;</p><p>二级页表的基地址：<code>PTTBase = PTBase + PN* 8 = PTBase + PTBase &gt;&gt; 9</code></p><p>一级页表(页目录)的基地址：<code>PSTBase = PTBase + (PTTBase &gt;&gt; 12)*8</code></p><p>映射到页目录自身的页目录项的地址：<code>PDBase =PTBase + (PSTBase &gt;&gt; 12)*8  = PTBase + PTBase &gt;&gt; 9 + PTBase &gt;&gt; 18 + PTBase &gt;&gt; 27</code></p><h2 id="二、Exercise"><a href="#二、Exercise" class="headerlink" title="二、Exercise"></a>二、Exercise</h2><h3 id="exercise-2-1"><a href="#exercise-2-1" class="headerlink" title="exercise 2.1"></a>exercise 2.1</h3><p><code>mmu.h</code>文件中定义了page的大小根据物理内存/页面大小即可求出页面数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGE_SIZE 4096</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGSHIFT 12</span><br></code></pre></td></tr></table></figure><h3 id="exercise-2-2"><a href="#exercise-2-2" class="headerlink" title="exercise 2.2"></a>exercise 2.2</h3><p>易错点：指向下一个元素的指针 le_next，以及指向前一个元素链表项 le_next 的指针 le_prev（指针的指针）</p><h3 id="exercise-2-3"><a href="#exercise-2-3" class="headerlink" title="exercise 2.3"></a>exercise 2.3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C">LIST_INIT(&amp;page_free_list);<br>freemem = ROUND(freemem,PAGE_SIZE);<br>u_long usedpage = PPN(PADDR(freemem));<br><span class="hljs-keyword">for</span> (u_long i = <span class="hljs-number">0</span>;i &lt; usedpage;i ++) &#123;<br>pages[i].pp_ref = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (u_long i = usedpage;i &lt; npage;i ++) &#123;<br>pages[i].pp_ref = <span class="hljs-number">0</span>;<br>LIST_INSERT_HEAD(&amp;page_free_list,&amp;pages[i],pp_link);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="exercise-2-4"><a href="#exercise-2-4" class="headerlink" title="exercise 2.4"></a>exercise 2.4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//根据题意写出即可</span><br><span class="hljs-keyword">if</span> (LIST_EMPTY(&amp;page_free_list)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-4</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>pp = LIST_FIRST(&amp;page_free_list);<br>&#125;<br>LIST_REMOVE(pp, pp_link);<br><span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span>*)page2kva(pp),<span class="hljs-number">0</span>,PAGE_SIZE);<br></code></pre></td></tr></table></figure><h3 id="exercise-2-5"><a href="#exercise-2-5" class="headerlink" title="exercise 2.5"></a>exercise 2.5</h3><p>调用<code>LIST_INSERT_HEAD</code>即可</p><h3 id="exercise-2-6"><a href="#exercise-2-6" class="headerlink" title="exercise 2.6"></a>exercise 2.6</h3><p>第一级表称为页目录 (Page Directory)，第二级表称为页表 (Page Table)。</p><p>设 pgdir 是一个 Pde * 类型的指针，表示一个一级页表的基地址，那么使用 pgdir + i 即可得到偏移量为 i 的一级页表项（页目录项）地址</p><p><img src="address.png" alt="两级页表结构的地址变换机制"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Step 1: Get the corresponding page directory entry. */</span><br><span class="hljs-comment">/* Exercise 2.6: Your code here. (1/3) */</span><br>pgdir_entryp = pgdir + PDX(va);<br><span class="hljs-comment">/* Step 2: If the corresponding page table is not existent (valid) then:</span><br><span class="hljs-comment"> *   * If parameter `create` is set, create one. Set the permission bits &#x27;PTE_C_CACHEABLE |</span><br><span class="hljs-comment"> *     PTE_V&#x27; for this new page in the page directory. If failed to allocate a new page (out</span><br><span class="hljs-comment"> *     of memory), return the error.</span><br><span class="hljs-comment"> *   * Otherwise, assign NULL to &#x27;*ppte&#x27; and return 0.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/* Exercise 2.6: Your code here. (2/3) */</span><br><span class="hljs-keyword">if</span> (!(*pgdir_entryp &amp; PTE_V)) &#123;<span class="hljs-comment">//如果页面不合法</span><br><span class="hljs-keyword">if</span> (create) &#123;<br><span class="hljs-keyword">if</span> (page_alloc(&amp;pp) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//申请不到空间</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-4</span>;<br>&#125;<br>pp-&gt;pp_ref++; <span class="hljs-comment">//维护pp_ref</span><br>*pgdir_entryp = (PTE_D | PTE_V | page2pa(pp));<span class="hljs-comment">//并设置虚拟地址对应页目录项的内容 *pgdir_entryp = page2pa(pp) | PTE_D | PTE_V，使其与该物理页关联</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>*ppte = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">/* Step 3: Assign the kernel virtual address of the page table entry to &#x27;*ppte&#x27;. */</span><br><span class="hljs-comment">/* Exercise 2.6: Your code here. (3/3) */</span><br><span class="hljs-comment">/*二级页表基地址（指向二级页表的指针）：</span><br><span class="hljs-comment">页目录项-&gt;二级页表的物理地址-&gt;二级页表的虚拟地址-&gt;指向二级页表的指针*/</span><br>Pte *pgtable = (Pte *)KADDR(PTE_ADDR(*pgdir_entryp));<br>*ppte = pgtable + PTX(va);<br></code></pre></td></tr></table></figure><h3 id="exercise-2-7"><a href="#exercise-2-7" class="headerlink" title="exercise 2.7"></a>exercise 2.7</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Step 2: Flush TLB with &#x27;tlb_invalidate&#x27;. */</span><br><span class="hljs-comment">/* Exercise 2.7: Your code here. (1/3) */</span><br>tlb_invalidate(asid, va);<br><span class="hljs-comment">/* Step 3: Re-get or create the page table entry. */</span><br><span class="hljs-comment">/* If failed to create, return the error. */</span><br><span class="hljs-comment">/* Exercise 2.7: Your code here. (2/3) */</span><br><span class="hljs-keyword">if</span> (pgdir_walk(pgdir, va, <span class="hljs-number">1</span>, &amp;pte) == -E_NO_MEM)<br>&#123;<br><span class="hljs-keyword">return</span> -E_NO_MEM;<br>&#125;<br><span class="hljs-comment">/* Step 4: Insert the page to the page table entry with &#x27;perm | PTE_C_CACHEABLE | PTE_V&#x27;</span><br><span class="hljs-comment"> * and increase its &#x27;pp_ref&#x27;. */</span><br><span class="hljs-comment">/* Exercise 2.7: Your code here. (3/3) */</span><br>*pte = page2pa(pp) | perm | PTE_V;<br>pp-&gt;pp_ref ++;<br></code></pre></td></tr></table></figure><h3 id="exercise-2-8"><a href="#exercise-2-8" class="headerlink" title="exercise 2.8"></a>exercise 2.8</h3><p>题目描述的很清楚，指令填入即可，核心在于理解旧表项是如何被无效化的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Step 1: Use &#x27;tlbp&#x27; to probe TLB entry */</span><br><span class="hljs-comment">/* Step 2: Fetch the probe result from CP0.Index */</span><br><span class="hljs-comment">/* Step 3: Use &#x27;tlbwi&#x27; to write CP0.EntryHi/Lo into TLB at CP0.Index  */</span><br></code></pre></td></tr></table></figure><h3 id="exercise-2-9"><a href="#exercise-2-9" class="headerlink" title="exercise 2.9"></a>exercise 2.9</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* Hints:</span><br><span class="hljs-comment"> *  Invoke &#x27;page_lookup&#x27; repeatedly in a loop to find the page table entry &#x27;*ppte&#x27;</span><br><span class="hljs-comment"> * associated with the virtual address &#x27;va&#x27; in the current address space &#x27;cur_pgdir&#x27;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  **While** &#x27;page_lookup&#x27; returns &#x27;NULL&#x27;, indicating that the &#x27;*ppte&#x27; could not be found,</span><br><span class="hljs-comment"> *  allocate a new page using &#x27;passive_alloc&#x27; until &#x27;page_lookup&#x27; succeeds.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/* Exercise 2.9: Your code here. */</span><br><span class="hljs-keyword">while</span> (page_lookup(cur_pgdir,va,&amp;ppte) == <span class="hljs-literal">NULL</span>) &#123;<br>passive_alloc(va,cur_pgdir,asid);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="exercise-2-10"><a href="#exercise-2-10" class="headerlink" title="exercise 2.10"></a>exercise 2.10</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Hint: use &#x27;tlbwr&#x27; to write CP0.EntryHi/Lo into a random tlb entry. */</span><br><span class="hljs-comment">/* Exercise 2.10: Your code here. */</span><br>tlbwr<br></code></pre></td></tr></table></figure><h2 id="三、实验难点及感想"><a href="#三、实验难点及感想" class="headerlink" title="三、实验难点及感想"></a>三、实验难点及感想</h2><h3 id="实验感想"><a href="#实验感想" class="headerlink" title="实验感想"></a>实验感想</h3><p>本次实验几乎花了整个周末，实验总体分为虚拟内存和TLB 重填两大部分，其中TLB重填部分由于提示给的相当足够，完成起来不是特别难，但是理解TLB重填的汇编代码较为困难，虚拟内存部分宏定义和大量指针的存在加大了阅读的难度，总体来说，lab2相比前两次，难度有了质的上升，特别是两级页表部分的实现，需要阅读大量的代码才能读懂。</p><h3 id="核心处理重难点"><a href="#核心处理重难点" class="headerlink" title="核心处理重难点"></a>核心处理重难点</h3><p>实验的核心都在围绕下面这张图进行寻址和地址处理</p><p><img src="ctm.png" alt="CPU-TLB-Memory关系图"></p><p>面对全是宏定义和满天飞的指针，理解各个宏定义的含义尤为重要。</p><h3 id="常见宏的理解"><a href="#常见宏的理解" class="headerlink" title="常见宏的理解"></a>常见宏的理解</h3><ul><li><code>page2kva</code>：将页面转换为虚拟地址</li><li><code>page2pa</code>：将页面转换为物理地址</li><li><code>pa2page</code>: 物理地址到页</li><li><code>KADDR</code>:将物理地址转化虚拟地址</li><li><code>PADDR</code>:将虚拟地址转化为物理地址</li></ul><h3 id="自映射机制"><a href="#自映射机制" class="headerlink" title="自映射机制"></a>自映射机制</h3><p>思考题A.1困扰我良久，下面是我找到到的比较详细的解释：</p><p>一些计算：因为1M个页表项和4G的地址空间是线性映射，因此页目录地址（简称PD）对应的应该是第PT&gt;&gt;12个页表项，也就是第一个页目录项。而一个页目录项32位，4字节，因此该项相对于起始地址的偏移为(PT&gt;&gt;12)&lt;<2 = pt>&gt;10，因此PD = PT | PT&gt;&gt;10。同理，PT&gt;&gt;10是页目录在整个页表上的偏移，对应(PT&gt;&gt;10)&gt;&gt;10是自映射页目录项在页目录这张页表上的偏移。</2></p><p>页表相关位</p><p><code>PTE_V</code> 有效位，若某页表项的有效位为 1，则该页表项有效，其中高 20 位就是对应的物理页号。</p><p><code>PTE_C_CACHEABLE</code> 可缓存位，配置对应页面的访问属性为可缓存。通常对于所有物理 页面，都将其配置为可缓存，以允许 CPU 使用 cache 加速对这些页面的访存请求。</p><p><code>PTE_D</code>可写位，若某页表项的可写位为 1，则允许经由该页表项对物理页进行写操作。</p>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA_OS_lab1</title>
    <link href="/2024/03/16/BUAA-OS-lab1/"/>
    <url>/2024/03/16/BUAA-OS-lab1/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统lab1学习日记"><a href="#操作系统lab1学习日记" class="headerlink" title="操作系统lab1学习日记"></a>操作系统lab1学习日记</h1><h2 id="一、思考题"><a href="#一、思考题" class="headerlink" title="一、思考题"></a>一、思考题</h2><h3 id="Thinking1-1"><a href="#Thinking1-1" class="headerlink" title="Thinking1.1"></a>Thinking1.1</h3><ul><li><code>objdump -DS 要反汇编的目标文件名 &gt; 导出文本文件名</code><ul><li>-D：反汇编所有的section；</li><li>-d：反汇编那些特定指令机器码的section；</li><li>-S ：尽可能反汇编出源代码，尤其当编译的时候指定了-g 这种调试参数时，效果比较明显,隐含了-d参数;</li><li>-s：显示指定section的完整内容。默认所有的非空section都会被显示</li></ul></li></ul><p>printf 的实现是在链接 (Link) 这一步骤中被插入到最终的可执行文件中的。节省了过程中对printf这些频繁使用的程序的编译。</p><p><img src="编译链接图.png" alt="编译链接"></p><h3 id="Thinking1-2"><a href="#Thinking1-2" class="headerlink" title="Thinking1.2"></a>Thinking1.2</h3><p>问题：</p><ul><li>尝试使用我们编写的 readelf 程序，解析之前在 target 目录下生成的内核 ELF 文 件。 </li><li>也许你会发现我们编写的 readelf 程序是不能解析 readelf 文件本身的，而我们刚 才介绍的系统工具 readelf 则可以解析，这是为什么呢？（提示：尝试使用 readelf -h，并阅读 tools/readelf 目录下的 Makefile，观察 readelf 与 hello 的不同）</li></ul><p><code>readelf [option(s)]</code> ，用来解析一个或者多个 ELF 文件的信息，使用readeif可以查看具体用法，我们执行 readelf -S hello 命令后，hello 文件中各个节的详细信息将以列表的形式为我们展示出来。我们可以利用 readelf 工具来验证我们自己写的简易版 readelf 输出的结果是否正确，还可以使用 readelf —help 看到该命令各个选项及其对 ELF 文件的解析方式</p><p>执行./tools/readelf/readelf ./target/mos后输出</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mos</span><br><span class="hljs-attribute">0</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">1</span>:<span class="hljs-number">0</span>x80020000<br><span class="hljs-attribute">2</span>:<span class="hljs-number">0</span>x80022080<br><span class="hljs-attribute">3</span>:<span class="hljs-number">0</span>x80022098<br><span class="hljs-attribute">4</span>:<span class="hljs-number">0</span>x800220b0<br><span class="hljs-attribute">5</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">6</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">7</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">8</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">9</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">10</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">11</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">12</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">13</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">14</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">15</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">16</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">17</span>:<span class="hljs-number">0</span>x0<br></code></pre></td></tr></table></figure><p>执行readelf -h readelf输出如下</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">ELF 头：</span><br><span class="hljs-attribute">  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="hljs-attribute">  类别</span><span class="hljs-punctuation">:</span> <span class="hljs-string">                             ELF64</span><br>  <span class="hljs-attribute">数据</span><span class="hljs-punctuation">:</span> <span class="hljs-string">                             2 补码，小端序 (little endian)</span><br>  <span class="hljs-attribute">Version</span><span class="hljs-punctuation">:</span> <span class="hljs-string">                          1 (current)</span><br>  <span class="hljs-attribute">OS/ABI</span><span class="hljs-punctuation">:</span> <span class="hljs-string">                           UNIX - System V</span><br>  <span class="hljs-attribute">ABI 版本</span><span class="hljs-punctuation">:</span> <span class="hljs-string">                         0</span><br>  <span class="hljs-attribute">类型</span><span class="hljs-punctuation">:</span> <span class="hljs-string">                             DYN (Position-Independent Executable file)</span><br>  <span class="hljs-attribute">系统架构</span><span class="hljs-punctuation">:</span> <span class="hljs-string">                         Advanced Micro Devices X86-64</span><br>  <span class="hljs-attribute">版本</span><span class="hljs-punctuation">:</span> <span class="hljs-string">                             0x1</span><br>  <span class="hljs-attribute">入口点地址：               0x1180</span><br><span class="hljs-attribute">  程序头起点：          64 (bytes into file)</span><br><span class="hljs-attribute">  Start of section headers</span><span class="hljs-punctuation">:</span> <span class="hljs-string">         14488 (bytes into file)</span><br>  <span class="hljs-attribute">标志：             0x0</span><br><span class="hljs-attribute">  Size of this header</span><span class="hljs-punctuation">:</span> <span class="hljs-string">              64 (bytes)</span><br>  <span class="hljs-attribute">Size of program headers</span><span class="hljs-punctuation">:</span> <span class="hljs-string">          56 (bytes)</span><br>  <span class="hljs-attribute">Number of program headers</span><span class="hljs-punctuation">:</span> <span class="hljs-string">        13</span><br>  <span class="hljs-attribute">Size of section headers</span><span class="hljs-punctuation">:</span> <span class="hljs-string">          64 (bytes)</span><br>  <span class="hljs-attribute">Number of section headers</span><span class="hljs-punctuation">:</span> <span class="hljs-string">        31</span><br>  <span class="hljs-attribute">Section header string table index</span><span class="hljs-punctuation">:</span> <span class="hljs-string">30</span><br></code></pre></td></tr></table></figure><p>./readelf readelf无输出，readelf无法解析本身但是readelf命令可以</p><p>下面的图用于辅助理解下面的Makefile</p><p><img src="预定义变量.jpg" alt="Makefile预定义变量"></p><p>readelf 与 hello 的不同在于hello有static修饰是静态的，且hello文件被编译为32位而readelf是64位的</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">readelf: main.o readelf.o</span><br>        <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br> <br><span class="hljs-section">hello: hello.c</span><br><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span> -m32 -static -g<br><span class="hljs-comment">#-g可执行程序包含调试信息，-g为了调试用的，加个-g 是为了gdb 用，不然gdb用不到</span><br></code></pre></td></tr></table></figure><h3 id="Thinking1-3"><a href="#Thinking1-3" class="headerlink" title="Thinking1.3"></a>Thinking1.3</h3><p>问题：</p><p>在理论课上我们了解到，MIPS 体系结构上电时，启动入口地址为 0xBFC00000 （其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但 一定是一个确定的地址），但实验操作系统的内核入口并没有放在上电启动地址，而是按照 内存布局图放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？ （提示：思考实验中启动过程的两阶段分别由谁执行。） </p><p>解答：</p><ul><li>bootloader 将内核可执行文件拷贝到内存中，之后将控制权交给操作系统，只需要启动入口地址为 bootloader 的入口地址。</li><li>Linker Script——控制加载地址，Linker Script 中记录了各个节应该如何映射到段，以及各个段应该被加载到的位置。程序执行的第一条指令的地址称为入口地址（entrypoint），与此同时kernel.lds规定了 ENTRY(_start) ，即把内核入口定为 _start 这个函数。</li><li>通过对 /init/start.S 中 _start 函数的设置，即可以正确的跳转至 mips_init 函数。</li></ul><h2 id="二、测试题Exercise"><a href="#二、测试题Exercise" class="headerlink" title="二、测试题Exercise"></a>二、测试题Exercise</h2><h3 id="exercise-1-1"><a href="#exercise-1-1" class="headerlink" title="exercise 1.1"></a>exercise 1.1</h3><p>核心思路：认识结构体中各个变量的意义计算地址及其他变量即可</p><p>测试结果：</p><p><img src="exercise1.1.png" alt="exercise1.1"></p><h3 id="exercise-1-2"><a href="#exercise-1-2" class="headerlink" title="exercise 1.2"></a>exercise 1.2</h3><p>Linker Script</p><p>.text 保存可执行文件的操作指令。 .data 保存已初始化的全局变量和静态变量。 .bss 保存未初始化的全局变量和静态变量。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">. = 0x8002000; /*load address of test section*/<br>/*。例如“<span class="hljs-string">.bss</span> : &#123;*<span class="hljs-params">(.bss)</span>&#125;”表示将所有输入文件中的 <span class="hljs-string">.bss</span> 节（右边的 <span class="hljs-string">.bss</span>）都放到输出的 <span class="hljs-string">.bss</span> 节（左边的 <span class="hljs-string">.bss</span>）中,请注意代码结尾无;*/<br><span class="hljs-string">.test</span> : &#123;*<span class="hljs-params">(.test)</span>&#125;<br><span class="hljs-string">.data</span> : &#123;*<span class="hljs-params">(.data)</span>&#125;<br><span class="hljs-string">.bss</span> : &#123;*<span class="hljs-params">(.bss)</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="exercise-1-3"><a href="#exercise-1-3" class="headerlink" title="exercise 1.3"></a>exercise 1.3</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment">/* set up the kernel stack */</span><br><span class="hljs-comment">/*注意Kernel Stack是向下增长，即栈顶在低地址*/</span><br>li      <span class="hljs-built_in">sp</span>, <span class="hljs-number">0x80400000</span><br><span class="hljs-keyword">jal </span>    mips_init<br></code></pre></td></tr></table></figure><h3 id="exercise-1-4"><a href="#exercise-1-4" class="headerlink" title="exercise 1.4"></a>exercise 1.4</h3><p>根据格式符<code>%[flags][width][length]</code>补齐即可</p><h2 id="三、难点分析与感想"><a href="#三、难点分析与感想" class="headerlink" title="三、难点分析与感想"></a>三、难点分析与感想</h2><p>lab1实验主要是大致理解printf函数的内部实现，与我们最初印象不同，printf并不是全部在C语言库中全部实现，而是通过一系列编译链接后，在操作系统基础上实现。</p><h4 id="3-1-编译链接部分"><a href="#3-1-编译链接部分" class="headerlink" title="3.1 编译链接部分"></a>3.1 编译链接部分</h4><p>在链接阶段，链接器会将所有的目标文件链接在一起，并填写具体的地址等信息，形成最终的可执行文件。核心在于ELF文件</p><p><img src="ELF.png" alt="ELF文件结构"></p><p>其由五部分构成，ELF头（包含程序基本信息、段头表与节头表的偏移量）、段头表、节头表、段头表中的每一个表项（记录了该段数据载入内存时的目标位置等，记录了用于指导应用 程序加载的各类信息）、节头表（记录了该段数据载入内存时的目标位置等，记录了用于指导应用 程序加载的各类信息）</p><h4 id="3-2-内存布局以及内核被加载到哪里"><a href="#3-2-内存布局以及内核被加载到哪里" class="headerlink" title="3.2 内存布局以及内核被加载到哪里"></a>3.2 内存布局以及内核被加载到哪里</h4><p>附录中给出了对于内存布局，根据Linker Script——控制加载地址，在使用了我们自定义的 Linker Script 以后，生成的程序中，各个节的位置就被 调整到了我们所指定的地址上。段是由节组合而成的，节的地址被调整了，那么最终段的地址也 会相应地被调整，我们的实验就在 kernel.lds 中通过 ENTRY(_start) 来设置程序入口为 _start。</p><h4 id="3-3-Make中是如何构建内核的？"><a href="#3-3-Make中是如何构建内核的？" class="headerlink" title="3.3 Make中是如何构建内核的？"></a>3.3 Make中是如何构建内核的？</h4><p>mos 的构建会在在完成了所有 (modules) 目标的构建后开始。从代码中可以看出，这里执 行了 <code>$(LD) -o $(mos_elf) -N -T $(link_script) $(objects)</code></p><p>$(LD)调用链接器，-o参数后设置输出文件名，-T 文件, —script 文件  读取链接脚本，这条命令作用是使用$(link_script) 将 $(objects) 链接， 输出到$(mos_elf) 位置。</p><h4 id="3-4-start函数怎么设置的？"><a href="#3-4-start函数怎么设置的？" class="headerlink" title="3.4 _start函数怎么设置的？"></a>3.4 _start函数怎么设置的？</h4><p>EXPORT(_start)是一个宏，它将 _start 函数导出为一个符号，使得链接器可以找到它。函数中实现跳转mips_init函数</p><h4 id="3-5-内核是如何输出到控制台的？"><a href="#3-5-内核是如何输出到控制台的？" class="headerlink" title="3.5 内核是如何输出到控制台的？"></a>3.5 内核是如何输出到控制台的？</h4><p>print.c函数实现了格式化输出的主体逻辑，outputk 函数指针传入 vprintfmt 这个函数中，这个函数实际上是用来输出一个字符串的，它实际上调用了一个叫做 printcharc 的函数（调用往 QEMU 的控制台输出字符，其原理为读写某一个特殊的内存地址的函数），想让控制台输出一个字符，实际上是对某一个内存地址写了一个字节。</p><p>总体感想：本次实验相比lab0理解要更难，重在理解 操作系统中mos的启动与构建</p><h2 id="四、附录"><a href="#四、附录" class="headerlink" title="四、附录"></a>四、附录</h2><p>lab1核心——课程内存布局</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs coq">/*<br> o     <span class="hljs-number">4</span>G -----------&gt;  +----------------------------+-----------<span class="hljs-number">-0x100000000</span><br> o                      |       <span class="hljs-type">...                  |  kseg2</span><br> o      KSEG2    -----&gt; +----------------------------+-----------<span class="hljs-number">-0xc000</span> <span class="hljs-number">0000</span><br> o                      |          <span class="hljs-type">Devices</span>           |  <span class="hljs-type">kseg1</span><br> o      KSEG1    -----&gt; +----------------------------+-----------<span class="hljs-number">-0xa000</span> <span class="hljs-number">0000</span><br> o                      |      <span class="hljs-type">Invalid</span> Memory        |   <span class="hljs-type">/|\</span><br><span class="hljs-type"> o</span>                      +----------------------------+----|<span class="hljs-type">-------Physical</span> Memory Max<br> o                      |       <span class="hljs-type">...                  |  kseg0</span><br> o      KSTACKTOP-----&gt; +----------------------------+----|<span class="hljs-type">-------0x8040</span> <span class="hljs-number">0000</span>-------<span class="hljs-keyword">end</span><br> o                      |       <span class="hljs-type">Kernel</span> Stack         |    <span class="hljs-type">| KSTKSIZE</span>            /|<span class="hljs-type">\</span><br><span class="hljs-type"> o</span>                      +----------------------------+----|<span class="hljs-type">------                |</span><br><span class="hljs-type"> o</span>                      |       <span class="hljs-type">Kernel</span> Text          |    <span class="hljs-type">|                    PDMAP</span><br> o      KERNBASE -----&gt; +----------------------------+----|<span class="hljs-type">-------0x8002</span> <span class="hljs-number">0000</span>    |<br> <span class="hljs-type">o</span>                      |      <span class="hljs-type">Exception</span> Entry       |   <span class="hljs-type">\|/                    \|/</span><br><span class="hljs-type"> o</span>      ULIM     -----&gt; +----------------------------+-----------<span class="hljs-number">-0x8000</span> <span class="hljs-number">0000</span>-------<br> o                      |         <span class="hljs-type">User</span> VPT           |     <span class="hljs-type">PDMAP</span>                /|<span class="hljs-type">\</span><br><span class="hljs-type"> o</span>      UVPT     -----&gt; +----------------------------+-----------<span class="hljs-number">-0x7fc0</span> <span class="hljs-number">0000</span>    |<br> <span class="hljs-type">o</span>                      |           <span class="hljs-type">pages</span>            |     <span class="hljs-type">PDMAP</span>                 |<br> <span class="hljs-type">o</span>      UPAGES   -----&gt; +----------------------------+-----------<span class="hljs-number">-0x7f80</span> <span class="hljs-number">0000</span>    |<br> <span class="hljs-type">o</span>                      |           <span class="hljs-type">envs</span>             |     <span class="hljs-type">PDMAP</span>                 |<br> <span class="hljs-type">o</span>  UTOP,UENVS   -----&gt; +----------------------------+-----------<span class="hljs-number">-0x7f40</span> <span class="hljs-number">0000</span>    |<br> <span class="hljs-type">o</span>  UXSTACKTOP -/       |     <span class="hljs-type">user</span> exception stack   |     <span class="hljs-type">PTMAP</span>                 |<br> <span class="hljs-type">o</span>                      +----------------------------+-----------<span class="hljs-number">-0x7f3f</span> f000    |<br> <span class="hljs-type">o</span>                      |                            <span class="hljs-type">|     PTMAP</span>                 |<br> <span class="hljs-type">o</span>      USTACKTOP ----&gt; +----------------------------+-----------<span class="hljs-number">-0x7f3f</span> e000    |<br> <span class="hljs-type">o</span>                      |     <span class="hljs-type">normal</span> user stack      |     <span class="hljs-type">PTMAP</span>                 |<br> <span class="hljs-type">o</span>                      +----------------------------+-----------<span class="hljs-number">-0x7f3f</span> d000    |<br> <span class="hljs-type">a</span>                      |                            <span class="hljs-type">|                           |</span><br><span class="hljs-type"> a</span>                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                           |<br> <span class="hljs-type">a</span>                      .                            .                           |<br> <span class="hljs-type">a</span>                      .                            .                         kuseg<br> a                      .                            .                           |<br> <span class="hljs-type">a</span>                      |<span class="hljs-type">~~~~~~~~~~~~~~~~~~~~~~~~~~~~|                           |</span><br><span class="hljs-type"> a</span>                      |                            <span class="hljs-type">|                           |</span><br><span class="hljs-type"> o</span>       UTEXT   -----&gt; +----------------------------+-----------<span class="hljs-number">-0x0040</span> <span class="hljs-number">0000</span>    |<br> <span class="hljs-type">o</span>                      |      <span class="hljs-type">reserved</span> <span class="hljs-keyword">for</span> COW      |     <span class="hljs-type">PTMAP</span>                 |<br> <span class="hljs-type">o</span>       UCOW    -----&gt; +----------------------------+-----------<span class="hljs-number">-0x003f</span> f000    |<br> <span class="hljs-type">o</span>                      |   <span class="hljs-type">reversed</span> <span class="hljs-keyword">for</span> temporary   |     <span class="hljs-type">PTMAP</span>                 |<br> <span class="hljs-type">o</span>       UTEMP   -----&gt; +----------------------------+-----------<span class="hljs-number">-0x003f</span> e000    |<br> <span class="hljs-type">o</span>                      |       <span class="hljs-type">invalid</span> memory       |                          <span class="hljs-type">\|/</span><br><span class="hljs-type"> a</span>     <span class="hljs-number">0</span> ------------&gt;  +----------------------------+ ----------------------------<br> o<br>*/<br>/* <span class="hljs-keyword">End</span> of Key Code <span class="hljs-string">&quot;load-kernel&quot;</span> */<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA_OS_lab0</title>
    <link href="/2024/03/06/BUAA-OS-lab0/"/>
    <url>/2024/03/06/BUAA-OS-lab0/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统lab0学习日记"><a href="#操作系统lab0学习日记" class="headerlink" title="操作系统lab0学习日记"></a>操作系统lab0学习日记</h1><h3 id="1-学习阶段的难点分析与体会"><a href="#1-学习阶段的难点分析与体会" class="headerlink" title="1 学习阶段的难点分析与体会"></a>1 学习阶段的难点分析与体会</h3><h4 id="1-1-基础命令和快捷键"><a href="#1-1-基础命令和快捷键" class="headerlink" title="1.1 基础命令和快捷键"></a>1.1 基础命令和快捷键</h4><ul><li>Ctrl+C 终止当前程序的执行</li><li>Ctrl+Z 挂起当前程序 </li><li>Ctrl+D 终止输入（若正在使用 shell，则退出当前 shell）</li><li>Ctrl+L 清屏</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">语法:gcc [选项]... [参数]... <br>选项（常用）：<br>-o 指定生成的输出文件 <br>-S 将 C 代码转换为汇编代码 <br>-Wall 显示一些警告信息 <br>-c 仅执行编译操作，不进行链接操作<br>-M 列出依赖<br>-I 编译时指定头文件目录，使用标准库时不需要指定目录，-I 参数可以用相对 ,→ 路径，比如头文件在当前目录，可以用-I. 来指定<br></code></pre></td></tr></table></figure><h4 id="1-2-ctags"><a href="#1-2-ctags" class="headerlink" title="1.2 ctags"></a>1.2 ctags</h4><p>回到命令行界面，执行命令<code>ctags -R *</code>，会发现在该目录下出现了新的文 件 tags，接下来就可以使用一些 ctags 的功能了：</p><p>按下 Ctrl+ ]，便可以跳转到函数定义处；再按下 Ctrl+T 或 Ctrl+O（有 些浏览器 Ctrl+T 是新建页面，会出现热键冲突），便可以回到跳转前的位置。</p><h4 id="1-3-git"><a href="#1-3-git" class="headerlink" title="1.3 git"></a>1.3 git</h4><p>git四种状态：</p><p><img src="git.png" alt="Git"></p><p><img src="gitPrinciple.png" alt></p><p>详见指导书p22，图中我们可以看出此时 HEAD 实际是指向 master 分支的一个“指针”。所以图示 的命令中出现 HEAD 的地方可以用 master 来替换。</p><p>当执行 <code>git rm --cached&lt;file&gt;</code>命令时，会直接从暂存区删除文件，工作区则 不做出改变，实现从暂存区删去不想继续跟踪的文件</p><p><code>git checkout -- &lt;file&gt;</code>如果在工作区中对多个文件经过多次修改后，发现编译 无法通过了。如果尚未执行 <code>git add</code>，则可使用本命令将工作区恢复成原来的样子。作用和<code>git restore</code>类似</p><p><code>git reset HEAD &lt;file&gt;</code>上一条命令是在未执行 <code>git add</code>命令便修改文件生效并 放入暂存区，可使用<code>git checkout</code> 命令。那么如果不慎已经执行了<code>git add</code>，则 可使用本命令。再对需要恢复的文件使用上一条命令即可。</p><p><code>git reset --hard</code>进行版本回退，使用这条命令可以进行版本回退或者切换到任何一个版本。它有两种用法：第一 种是使用<code>HEAD</code>类似形式，如果想退回上个版本就用<code>HEAD^</code>，上上个版本的话就用<code>HEAD^^</code>，要是回退到前 50 个版本则可使用<code>HEAD~50</code>来代替；第二种就是使用<code>hash</code>值，使用<code>hash</code>值可以在不同版本之间任意切换，足见<code>hash</code>值的强大。但是，它强制覆盖了工作目录中的文件。若该文件还未提交，Git 会覆盖它从 而导致无法恢复。</p><p><code>git branch</code>,</p><p>选项：</p><p><code>-D</code>  强制删除一个指定分支</p><p><code>-a</code>   查看所有的原地和本地分支</p><p><img src="gitBranch.png" alt="git branch"></p><h4 id="1-4-linux进阶"><a href="#1-4-linux进阶" class="headerlink" title="1.4 linux进阶"></a>1.4 linux进阶</h4><p><code>find</code>:使用 find 命令并加上 -name 选项可以在当前目录下递归地查找符合参数所示文件 名的文件，并将文件的路径输出至屏幕上。</p><p><code>grep</code>:grep 命令可以从文件中查找包含 pattern 部分字符串的行，并将 该文件的路径和该行输出至屏幕</p><p><code>chmod</code>:+ 表示增加权限、- 表示取消权限、= 表示唯一设定权 限。r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者 该文件已经被设定过为可执行。</p><p><code>diff</code>:比较文件差异，-b 不检查空白字符的不同，-B不检查空行，-q仅显示有无差异不显示详细信息</p><p><code>sed</code>:</p><p>选项（常用）：</p><ul><li>-n 安静模式，只显示经过 sed 处理的内容。否则显示输入文本的所有内容。</li><li>-i 直接修改读取的档案内容，而不是输出到屏幕。否则，只输出不编辑。</li><li><code>-e</code>允许在同一行类执行多条命令</li></ul><p>命令（常用）：</p><ul><li>[行号]a[内容] 新增，在行号后新增一行相应内容。行号可以是“数字”，在这一行之后新增，不写行号时，在每一行之后新增。使用 $ 表示最后一行。后面的命令同理。</li><li>[行号]c[内容] 取代。用内容取代相应行的文本。</li><li>[行号]i[内容] 插入。在当前行的上面插入一行文本。</li><li>[行号]d 删除当前行的内容。</li><li>[行号]p 输出选择的内容。通常与选项-n 一起使用。</li><li>s/re/string 将 re（正则表达式）匹配的内容替换为 string。</li></ul><p><code>awk</code>:awk ‘pattern action’ file，pattern 为条件，action 为命 令，file 为文件。</p><h4 id="1-5-shell"><a href="#1-5-shell" class="headerlink" title="1.5 shell"></a>1.5 shell</h4><p><code>$n</code>就表示第几个参数，<code>$#</code>表示传递参数的个数，<code>$*</code>表示传递的全部参数</p><h3 id="2-Thinking"><a href="#2-Thinking" class="headerlink" title="2 Thinking"></a>2 Thinking</h3><h4 id="Thinking-0-1"><a href="#Thinking-0-1" class="headerlink" title="Thinking 0.1"></a>Thinking 0.1</h4><p>问题：思考下列有关 Git 的问题：</p><ul><li>在前述已初始化的 ~/learnGit 目录下，创建一个名为 README.txt 的文件。执 行命令 git status &gt; Untracked.txt（其中的 &gt; 为输出重定向，我们将在 0.6.3 中 详细介绍）。 </li><li>在 README.txt 文件中添加任意文件内容，然后使用 add 命令，再执行命令 git status &gt; Stage.txt。 </li><li>提交 README.txt，并在提交说明里写入自己的学号。</li><li>执行命令 cat Untracked.txt 和 cat Stage.txt，对比两次运行的结果，体会 README.txt 两次所处位置的不同。</li><li>修改 README.txt 文件，再执行命令 git status &gt; Modified.txt。</li><li>执行命令 cat Modified.txt，观察其结果和第一次执行 add 命令之前的 status 是 否一样，并思考原因。</li></ul><p>解答：新建<code>README.txt</code>文件后，文件处于Untracked状态，文件中添加部分内容，git add后会处于staged状态。先git commit文件接下来再修改文件，文件会处于Modified状态</p><h4 id="Thinking-0-2"><a href="#Thinking-0-2" class="headerlink" title="Thinking 0.2"></a>Thinking 0.2</h4><p>问题：上图中思考一下箭头中的 add the file 、stage the file 和 commit 分别对应的是 Git 里的哪些命令呢？ </p><p>解答：</p><ul><li><code>git add</code></li><li><code>git add</code></li><li><code>git commit</code></li></ul><h4 id="Thinking-0-3"><a href="#Thinking-0-3" class="headerlink" title="Thinking 0.3"></a>Thinking 0.3</h4><p>问题：</p><ol><li>代码文件 print.c 被错误删除时，应当使用什么命令将其恢复？ </li><li>代码文件 print.c 被错误删除后，执行了 git rm print.c 命令，此时应当 使用什么命令将其恢复？</li><li>无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区</li></ol><p>解答：</p><ul><li><code>git checkout --print.c</code></li><li><code>git reset HEAD print.c &amp;&amp; git checkout --print.c</code></li><li><code>git rm -- chched print.c</code></li></ul><h4 id="Thinking-0-4"><a href="#Thinking-0-4" class="headerlink" title="Thinking 0.4"></a>Thinking 0.4</h4><p>版本回退中，<code>git reset --hard</code>后面添加<code>HEAD^</code>可以回到上一版本，<code>HEAD~32</code>这样最多支持回到上五十个版本，此外也使用 hash 值可以在不同版本之间任意切换。</p><h4 id="Thinking-0-5"><a href="#Thinking-0-5" class="headerlink" title="Thinking 0.5"></a>Thinking 0.5</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">执行如下命令, 并查看结果<br>• echo first #输出first<br>• echo second &gt; output.txt #将second输出到output.txt<br>• echo third &gt; output.txt<br><span class="hljs-meta prompt_">#</span><span class="language-bash">将third输出到output.txt并覆盖</span><br>• echo forth &gt;&gt; output.txt<br><span class="hljs-meta prompt_">#</span><span class="language-bash">将forth输出到output.txt但不覆盖</span><br><br></code></pre></td></tr></table></figure><h4 id="Thinking-0-6"><a href="#Thinking-0-6" class="headerlink" title="Thinking 0.6"></a>Thinking 0.6</h4><p>echo echo Shell Start 直接把“echo Shell Start” 作为字符串输出；</p><p>echo (反顿号)echo Shell Start(反顿号)是将 “echo Shell Start” 的输出作为 外层echo 的输入，故会输出 Shell Start；</p><p>echo (单引号)echo Shell Start(单引号)直接把“echo Shell Start” 作为字符串输出</p><h3 id="3-lab0作业debug阶段的易错点"><a href="#3-lab0作业debug阶段的易错点" class="headerlink" title="3 lab0作业debug阶段的易错点"></a>3 lab0作业debug阶段的易错点</h3><h4 id="3-1-脚本执行参数不能丢"><a href="#3-1-脚本执行参数不能丢" class="headerlink" title="3.1 脚本执行参数不能丢"></a>3.1 脚本执行参数不能丢</h4><p>在./search.sh 时未输入一下参数会爆出重定向有歧义（只是其中之一）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -n <span class="hljs-string">&quot;<span class="hljs-variable">$2</span>&quot;</span> <span class="hljs-variable">$1</span> | awk -F <span class="hljs-string">&#x27;:&#x27;</span> <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span> &gt; <span class="hljs-variable">$3</span><br></code></pre></td></tr></table></figure><h4 id="3-2-Makefile中的问题"><a href="#3-2-Makefile中的问题" class="headerlink" title="3.2 Makefile中的问题"></a>3.2 Makefile中的问题</h4><ol><li><code>.PHONY</code>后面跟的目标都被称为伪目标，也就是说我们 make 命令后面跟的参数如果出现在.PHONY 定义的伪目标中，那就直接在Makefile中就执行伪目标的依赖和命令。不管Makefile同级目录下是否有该伪目标同名的文件，即使有也不会产生冲突。另一个就是提高执行makefile时的效率。</li><li>如下,如果执行all会同时执行fibo和clean对应命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">all :fibo clean<br><br>clean:<br><span class="hljs-built_in">rm</span> -rf $(TARGET)<br>fibo: fibo.c<br>gcc -o fibo fibo.c<br></code></pre></td></tr></table></figure><h4 id="3-3-gcc"><a href="#3-3-gcc" class="headerlink" title="3.3 gcc"></a>3.3 gcc</h4><p><code>-I</code>参数是用来指定头文件目录</p><p><code>-l</code>参数就是用来指定程序要链接的库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc ./code/fibo.o ./code/main.o -o fibo <br></code></pre></td></tr></table></figure><p>这段代码作用:</p><p>这段代码使用了gcc编译器将两个目标文件（fibo.o和main.o）链接在一起，生成一个名为fibo的可执行文件。通常，这种编译方式适用于将程序分成多个源文件编写，然后分别编译成目标文件，最后将它们链接在一起以生成最终的可执行文件。</p><h3 id="4-Exercice总结"><a href="#4-Exercice总结" class="headerlink" title="4 Exercice总结"></a>4 Exercice总结</h3><h4 id="4-1-Exercise-0-1"><a href="#4-1-Exercise-0-1" class="headerlink" title="4.1 Exercise 0.1"></a>4.1 Exercise 0.1</h4><ol><li><p>palindrome.c代码补全，实现回文数判断，核心思路：将数字n的各位上的数字存到数组中进行比对</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> main &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span> (<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>        a[i++] = n % <span class="hljs-number">10</span>;<br>        n /= <span class="hljs-number">10</span>;<br>    &#125;<br>    j = i - <span class="hljs-number">1</span>;<br>    i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">if</span> (a[i] != a[j]) &#123;<br>            flag = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        i ++;<br>        j --;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flag) &#123;<br>        print(<span class="hljs-string">&quot;Y\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>print(<span class="hljs-string">&quot;N\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ol><li><p>```shell<br>gcc -o palindrome palindrome.c</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><br><span class="hljs-number">3.</span> sed指令的使用<br><br>   ```shell<br>   <span class="hljs-meta">#实现通过命令 bash hello_os.sh AAA BBB，在 hello_os.sh 所处的目录新建一个名为 BBB 的文件，内容是AAA 文件的第 8、32、128、512、1024 行的内容提取</span><br>   sed -n <span class="hljs-string">&#x27;8p;32p;128p;512p;1024p&#x27;</span> $1 &gt; $2<br>   <span class="hljs-meta">#-n 表示在安静模式下进行</span><br></code></pre></td></tr></table></figure></li><li><p>文件复制,co指令的使用</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cp -r src<span class="hljs-regexp">/* dst/</span><br>re dst<span class="hljs-regexp">/sh_test/</span>hello_os.sh<br></code></pre></td></tr></table></figure></li></ol><h4 id="4-2-Exercise-0-2"><a href="#4-2-Exercise-0-2" class="headerlink" title="4.2 Exercise 0.2"></a>4.2 Exercise 0.2</h4><ol><li><p>删除和重命名的使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -r &quot;file$a&quot; #删除file4(若$a == 4)<br>mv ./&quot;file$a&quot; ./&quot;newfile$a&quot;<br>let a=a+1 #使得a递增，注意不要加些空格<br></code></pre></td></tr></table></figure></li></ol><h4 id="4-3-Exercise-0-3"><a href="#4-3-Exercise-0-3" class="headerlink" title="4.3 Exercise 0.3"></a>4.3 Exercise 0.3</h4><p>​    <code>grep</code>与<code>awk</code>的使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -n $2 $1 | awk -F &#x27;:&#x27; &#x27;&#123;print $1&#125;&#x27; &gt; $3<br></code></pre></td></tr></table></figure><h4 id="4-4-Exercise-0-4"><a href="#4-4-Exercise-0-4" class="headerlink" title="4.4 Exercise 0.4"></a>4.4 Exercise 0.4</h4><ol><li><p><code>sed</code>使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#将$1文件中的$s2替换为$s3</span><br>sed -i <span class="hljs-string">&quot;s/<span class="hljs-variable">$2</span>/<span class="hljs-variable">$3</span>/g&quot;</span> <span class="hljs-variable">$1</span><br></code></pre></td></tr></table></figure></li><li><p><code>Makefile</code>编写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"> 内部Makefile<br>  1 all: fibo main<br>  2 <br>  3 fibo: fibo.c<br>  4         gcc -I ../include -c fibo.c<br>  5 <br>  6 main: main.c fibo.o<br>  7         gcc -I ../include -c main.c<br>  8 <br>  9 clean:<br> 10         rm *.o<br>外部<br>  1 all: fibo<br>  2 <br>  3 fibo: <br>  4         cd code &amp;&amp; make <br>  5         gcc ./code/fibo.o ./code/main.o -o fibo<br>  6 <br>  7 clean: <br>  8         rm ./code/fibo.o<br>  9         rm ./code/main.o<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA_OO_Unit1</title>
    <link href="/2024/03/01/BUAA-OO-Unit1/"/>
    <url>/2024/03/01/BUAA-OO-Unit1/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="BUAA-OO-Unit1总结"><a href="#BUAA-OO-Unit1总结" class="headerlink" title="BUAA_OO_Unit1总结"></a>BUAA_OO_Unit1总结</h1><h2 id="一、第一次作业hw1"><a href="#一、第一次作业hw1" class="headerlink" title="一、第一次作业hw1"></a>一、第一次作业hw1</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>耗时数天完成了代码书写及代码调试，感悟良多，归功于Training中的内容，我在本次作业中也选择了对应的递归下降的思路构造语法树，同时在根据语法树利用逆向思路将解析完的表达式转化为多项式形式，最后多项式存入TreeMap中按要求降序输出结果。此外UML图中单箭头为本人添加，代表核心的依赖关系。</p><h3 id="1-代码UML框架"><a href="#1-代码UML框架" class="headerlink" title="1.代码UML框架"></a>1.代码UML框架</h3><p><img src="uml.png" alt="UML框架"></p><p><code>NumFactor,VarFactor,ExprFactor</code>继承Factor父类，既可以调用父类<code>exponet</code>的相关方法，又有各自<code>toPoly</code>的方法，<code>Monomial</code>单项式类用于处理单项式，<code>Poly</code>用于处理多项式，<code>PolynomialAnswer</code>用于最终化简输出</p><h3 id="2-代码架构分析"><a href="#2-代码架构分析" class="headerlink" title="2.代码架构分析"></a>2.代码架构分析</h3><h4 id="2-1-预处理"><a href="#2-1-预处理" class="headerlink" title="2.1 预处理"></a>2.1 预处理</h4><p><img src="image-20240301204258960.png" alt="形式化表述"></p><p>根据表达式的形式化表达我们可以得到以下结论：</p><ol><li>表达式中最多三个连续的<code>+</code>或者<code>-</code></li><li>常数因子可以有前导0</li><li>指数符号后只可能是<code>token.ADD</code>或者<code>token.NUM</code></li><li>表达式中可能存在大量 <code>space</code>和<code>\t</code></li><li>表达式或<code>(</code>后可能存在符号</li></ol><p>于是为了简化后续操作我选择进行的以下操作</p><ol><li>若读到<code>+</code>且前面存在其他符号或位于开头则去掉加号</li><li>若读到<code>-</code>且前面存在<code>(</code>或者位于开头则在前面加上0，若减号连续则将其换为一个<code>+</code></li><li>去掉所有空格</li></ol><h4 id="2-2-词法分析与解析部分"><a href="#2-2-词法分析与解析部分" class="headerlink" title="2.2 词法分析与解析部分"></a>2.2 词法分析与解析部分</h4><h5 id="2-2-1-Lexer部分"><a href="#2-2-1-Lexer部分" class="headerlink" title="2.2.1 Lexer部分"></a>2.2.1 Lexer部分</h5><ol><li>在读取到<code>token.NUM</code>时去除前缀0（但是谨记保证数不会被全部去掉）</li><li>在读取到未知符号时我们选择抛出异常（强烈建议此方法，后续可以快速定位bug）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Invalid token&quot;</span>);<br></code></pre></td></tr></table></figure><h5 id="2-2-2-Parse"><a href="#2-2-2-Parse" class="headerlink" title="2.2.2 Parse"></a>2.2.2 Parse</h5><p>该部分是代码词法解析的核心部分</p><ol><li><p>我完成了<code>parseExpr()、parseTerm()、parseFactor()</code>的书写并采用递归下降的方法调用</p></li><li><p>由于预处理我们可以只对Term加上正负属性并且在这里完成项的正负号的确定</p></li><li><p>在解析项时去掉指数符号，将其全部转化为因子形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">Factor</span> <span class="hljs-variable">factor</span> <span class="hljs-operator">=</span> parseFactor();<br>        <span class="hljs-keyword">if</span> (factor.getExponent() == <span class="hljs-number">0</span>) &#123;<br>            term.addFactor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NumFactor</span>(BigInteger.ONE));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; factor.getExponent(); i++) &#123;<br>            term.addFactor(factor);<br>        &#125;<br></code></pre></td></tr></table></figure></li></ol><ol><li><p>同上在解析未知符号是我们选择抛出异常便于debug</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Invalid token&quot;</span>);<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-3-根据解析结果转化为多项式"><a href="#2-3-根据解析结果转化为多项式" class="headerlink" title="2.3 根据解析结果转化为多项式"></a>2.3 根据解析结果转化为多项式</h4><p>该部分核心思路还是递归思路</p><p>Expr -&gt; Term -&gt; Factor</p><p>然后多项式中存入<code>TreeMap&lt;Integer,BigInteger&gt; polynomial</code></p><p>最后，我们要得到形如：$Expr =  \sum\limits_ { i = 0 } a_i * x ^ { b_i }$</p><p>好处：保证有序性和便于得到$a_i$和$b_i$，在此基础上得到一个字符串即可</p><h3 id="3-测试思路"><a href="#3-测试思路" class="headerlink" title="3.测试思路"></a>3.测试思路</h3><h4 id="3-1-自动化测试"><a href="#3-1-自动化测试" class="headerlink" title="3.1.自动化测试"></a>3.1.自动化测试</h4><h5 id="3-11-数据生成"><a href="#3-11-数据生成" class="headerlink" title="3.11 数据生成"></a>3.11 数据生成</h5><p>思路还是和解答程序程序相似,按照generate_factor  —&gt; generate_term —&gt; generate_expr —&gt;generate_testcase</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_factor</span>(<span class="hljs-params">floor</span>):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_term</span>(<span class="hljs-params">floor</span>):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_expr</span>(<span class="hljs-params">floor</span>):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_testcase</span>(<span class="hljs-params">Limit,floor</span>):<br></code></pre></td></tr></table></figure><p>最后随机在生成式之间添加空格</p><h5 id="3-12-测试比对"><a href="#3-12-测试比对" class="headerlink" title="3.12 测试比对"></a>3.12 测试比对</h5><p>依赖于sympy自带的化简功能实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">execute_java</span> (stdin, <span class="hljs-built_in">str</span>):<br>    cmd = [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-built_in">str</span> + <span class="hljs-string">&quot;.jar&quot;</span>]  <span class="hljs-comment"># 更改为自己的.jar包名</span><br>    proc = subprocess.Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=STDOUT)<br>    stdout, stderr = proc.communicate(stdin.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>    <span class="hljs-keyword">return</span> stdout.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>).strip()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">isEqual</span>(<span class="hljs-params">javaInput,javaOutput</span>):<br>    javaInput = sp.simplify(javaInput)<br>    javaOutput = sp.simplify(javaOutput)<br>    <span class="hljs-keyword">return</span> javaInput.equals(javaOutput)<br></code></pre></td></tr></table></figure><h2 id="二、第二次作业hw2"><a href="#二、第二次作业hw2" class="headerlink" title="二、第二次作业hw2"></a>二、第二次作业hw2</h2><h4 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h4><p>本次作业花费大多时间在构思解决最后的化简上，同时在debug时也遇到了不少问题，但最终一一解决，虽代码相比第一次变化不小，但总体思路大致相同</p><h4 id="1-代码UML框架-1"><a href="#1-代码UML框架-1" class="headerlink" title="1.代码UML框架"></a>1.代码UML框架</h4><p><img src="UML_Unit1.2.png" alt="UML"></p><p>相比上次增加了自定义函数类、自定义函数集合、自定义函数因子类用于处理自定义函数以及其替换，迭代中发现<code>PolynomailAnswer</code>类作为最终输出由于增加了<code>ExpFuncFactor</code>指数函数类的原因，反而不能起到化简的作用，于是删去了，相关输出在<code>Poly</code>类中实现。</p><h4 id="2-作业体会"><a href="#2-作业体会" class="headerlink" title="2.作业体会"></a>2.作业体会</h4><ol><li>关于使用替换进行函数展开，要注意不要引入新的形参。例如f(y, x)=y+x，展开f(x, x^2)时，若不加任何修改直接用x替换形参y，f就会变为x+x， 再直接用x^2替换所有形参x，就会变为x^2+x^2的错误结果。因此，可以先将所有形参变为其他形式， 如f(v,u) = v+u，再替换形参v和u就不会发生上述错误。对于<code>exp(x)</code>,由于<code>exp</code>中包含x，可能会影响我们后续对于x的替换，所以在一开始我们可以选择将<code>exp</code>替换为<code>e</code></li><li>深拷贝与浅拷贝学习，由于JAVA默认一般是浅拷贝，如下我们正常写法应该是<code>return this.defineFunctions</code>,但是函数的参数替换时可能会涉及多次形参的替换，如果不采用深拷贝的话，会导致第一遍替换后会影响我们到后续的替换。        </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ArrayList&lt;DefineFunction&gt; <span class="hljs-title function_">getDefineFunctions</span><span class="hljs-params">()</span> &#123;<br>    ArrayList&lt;DefineFunction&gt; dfs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (DefineFunction defineFunction : <span class="hljs-built_in">this</span>.defineFunctions) &#123;<br>        dfs.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefineFunction</span>(defineFunction.getName(), defineFunction.getBody()));<br>        dfs.get(dfs.size() - <span class="hljs-number">1</span>).setParameters(defineFunction.getParameters());<br>    &#125;<br>    <span class="hljs-keyword">return</span> dfs;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现深拷贝也有很多种方法，对于String 类型的我们可以new一个String类型对象后赋值，对于某一个自定义对象，我们可以通过以下方法实现：</p><ul><li><p>重写<code>clone（）</code>方法，但是这种方法某一类有多少个引用类型，我们就要重写多少次，如果存在很多引用类型，那么代码量显然会很大，所以这种方法不太合适。</p></li><li><p>利用序列化序，列化是将对象写到流中便于传输，而反序列化则是把对象从流中读取出来。这里写到流中的对象则是原始对象的一个拷贝，因为原始对象还存在 JVM 中，所以我们可以利用对象的序列化产生克隆对象，然后通过反序列化获取这个对象。 注意每个需要序列化的类都要实现 Serializable 接口，如果有某个属性不需要序列化，可以将其声明为 transient，即将其排除在克隆属性之外。下面是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.Serial;<br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-comment">//Serializable的作用是为了实现对象的序列化，只有实现了Serializable接口的类才能被序列化</span><br>    <span class="hljs-meta">@Serial</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> age; <span class="hljs-comment">//transient关键字修饰的变量不会被序列化</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">deepClone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//序列化</span><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>(); <span class="hljs-comment">//创建字节数组输出流</span><br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bos);<br>        oos.writeObject(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-comment">//反序列化</span><br>        <span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bos.toByteArray());<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(bis);<br>        <span class="hljs-keyword">return</span> ois.readObject();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h4 id="3-代码架构分析"><a href="#3-代码架构分析" class="headerlink" title="3.代码架构分析"></a>3.代码架构分析</h4><p>本次迭代继承了上次大部分的思路，增加了DefineFunction，FunctionList两个类用于读取和储存自定义函数，同时根据提示题意增加了需要的DefineFunctionFactor、ExpFuncFactor类适应新的需求</p><h5 id="3-1-自定义函数的替换"><a href="#3-1-自定义函数的替换" class="headerlink" title="3.1 自定义函数的替换"></a>3.1 自定义函数的替换</h5><p>由于在于处理中一直没有好的思路实现替换，于是我决定牺牲部分运行的时间，先解析一遍表达式，再将Expr通过递归思路转化为String形式，在这个过程中在DefineFunctionFactor下的toString()方法实现替换，但在这里要注意调用我们储存好的FunctionList的内容时要实现深拷贝</p><h5 id="3-2-多项式的化简"><a href="#3-2-多项式的化简" class="headerlink" title="3.2 多项式的化简"></a>3.2 多项式的化简</h5><p>本次单项式相比上次多了Poly类对象对应exp（）内部的多项式，多项式类采用以下储存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> ArrayList&lt;Monomial&gt; monomials;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TreeMap&lt;BigInteger, HashMap&lt;Poly, BigInteger&gt;&gt; polyMap;<br></code></pre></td></tr></table></figure><p>最开始先不断在monomials中添加单项式，后再往polyMap中添加实现化简，注意由于HashMap的key是自定义类，我们需要重写equals（）方法和hashcode()方法</p><h3 id><a href="#" class="headerlink" title=" "></a> </h3><h3 id="4-debug"><a href="#4-debug" class="headerlink" title="4. debug"></a>4. debug</h3><h4 id="CPU超时以及超内存应对"><a href="#CPU超时以及超内存应对" class="headerlink" title="CPU超时以及超内存应对"></a>CPU超时以及超内存应对</h4><ul><li><strong>慎用异常</strong></li></ul><p>异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace()的本地同步方法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。</p><p>本次bug是由于递归深度过深导致的下面这条数据超内存且超时，尝试了很多提高性能的方法均不奏效，于是被迫更改递归思路</p><p><code>0(((((((((((x^8)^8)^8)^8)^8)^8)^8)^8)^8)^8)^8)^8</code></p><p>原思路如下，没读到一个因子就根据其次数向项中加入对应数量的因子，后续会导致递归不断深入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">for</span> (<span class="hljs-type">BigInteger</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> BigInteger.ZERO; i.compareTo(factor.getExponent()) &lt; <span class="hljs-number">0</span>;<br>     i = i.add(BigInteger.ONE)) &#123;<br>    term.addFactor(factor);<br>&#125;<br></code></pre></td></tr></table></figure><p>更改后，在转换为多项式时根据次数乘上对应因子，极大简化了对应的递归深度。</p><p>至于Main中的更改，原因在于我采用的是解析<code>String</code>类型字符串再<code>ToString</code>实现替换的功能，当没有需要替换的的函数时就只需要解析一次。综上实现了超内存和超时的问题。</p><p>综上，递归解决问题中，如何保证递归的深度不会太深是我们必须需要思考的问题。</p><h3 id="5-hack经历"><a href="#5-hack经历" class="headerlink" title="5. hack经历"></a>5. hack经历</h3><p>hack时主要还是通过评测机进行初查，但由于python的<code>sympy</code>包无法检测作业中的格式问题，最终主要还是人力排查格式问题，本次通过exp((-x))格式错误hack成功一次。</p><h2 id="三、第三次作业"><a href="#三、第三次作业" class="headerlink" title="三、第三次作业"></a>三、第三次作业</h2><h4 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h4><p>本次作业相比前两次代码量上有所减少，作业核心求导方面还是第一单元的核心思路递归下降解决。但是由于作业难度的加大以及迭代导致本次在debug方面耗费了大量的时间。</p><h4 id="1-代码UML框架-2"><a href="#1-代码UML框架-2" class="headerlink" title="1.代码UML框架"></a>1.代码UML框架</h4><p><img src="UML1.3.png" alt="UML1.3"></p><p>增加了求导函数因子，求导过程主要是转化为<code>String</code>类型递归实现。但是注意指数函数（<del>血的教训</del>）的求导如下：</p><p>$dx(exp((expr))^n) = n<em>dx(expr)</em>(exp((expr))^n)$</p><h4 id="2-作业体会-1"><a href="#2-作业体会-1" class="headerlink" title="2. 作业体会"></a>2. 作业体会</h4><p><code>derivation()</code>求导函数和<code>toString()</code>类似返回String类型，采用递归下降思路，此外无较大改动。</p><h4 id="3-hack经历"><a href="#3-hack经历" class="headerlink" title="3. hack经历"></a>3. hack经历</h4><p>本次hack过程，有了上次自己超时的经验，卡着代价函数通过下面数据卡了性能成功一次</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-number">0</span><br><span class="hljs-function"><span class="hljs-title">dx</span>(<span class="hljs-title">exp</span>(<span class="hljs-title">exp</span>(<span class="hljs-title">exp</span>(<span class="hljs-title">exp</span>(<span class="hljs-title">exp</span>(<span class="hljs-title">exp</span>(<span class="hljs-title">exp</span>(<span class="hljs-title">exp</span>(<span class="hljs-variable">x</span>^<span class="hljs-number">2</span>)))))))))</span><br></code></pre></td></tr></table></figure><h4 id="4-输出优化"><a href="#4-输出优化" class="headerlink" title="4. 输出优化"></a>4. 输出优化</h4><p>关于输出优化我没做特别的提出exp内部的最小公因数和因式分解操作，但是通过<code>TreeMap&lt;BigInteger, HashMap&lt;Poly, BigInteger&gt;&gt; polyMap</code>的多项式储存方式，通过讨论指数和系数的值通过打表的方式，对于无指数函数多项式的优化几乎是最简形式。</p><h2 id="Unit1总结"><a href="#Unit1总结" class="headerlink" title="Unit1总结"></a>Unit1总结</h2><p>第一单元的核心是解析表达式，总体处理思路是递归下降构建语法树，总体代码规模如下，为了便于理解，我将Factor抽象为父类，里面实现一些因子类的通用方法，并将所有的因子都对应创建的一个子类从而实现不同的<code>toString(),derivation(),toPoly</code>方法。</p><h4 id="1-代码规模以及复杂度"><a href="#1-代码规模以及复杂度" class="headerlink" title="1.代码规模以及复杂度"></a>1.代码规模以及复杂度</h4><p><img src="codeNum.png" alt="codeNum"></p><p>通过与他人对比，发现个人的代码规模还是比较庞大的，主要在于部分类的抽象程度还是不够高，将对应因子以及各类处理都写成了对应的类——因此可以提高抽象程度，例如Expr作为Factor接口下的实例。优点：理解起来较为容易，更改增加新功能较为容易。缺点：随着代码的迭代，增添的代码量相比会更加多。</p><p>复杂度如下：</p><ul><li><strong>OCavg</strong> : 每个类中所有非抽象方法的平均圈复杂度(继承的方法不计算在内)。</li><li><strong>OCmax</strong> : 每个类中非抽象方法的最大圈复杂度(继承的方法不计算在内)。</li><li><strong>WMC</strong> : 每个类中方法的总圈复杂度.</li></ul><div class="table-container"><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>MainClass</td><td>2</td><td>2</td><td>2</td></tr><tr><td>analysis.Lexer</td><td>4</td><td>16</td><td>36</td></tr><tr><td>analysis.Parser</td><td>2.75</td><td>7</td><td>33</td></tr><tr><td>analysis.Token</td><td>1</td><td>1</td><td>4</td></tr><tr><td>analysis.Token.Type</td><td>n/a</td><td>n/a</td><td>0</td></tr><tr><td>definefunction.DefineFunction</td><td>1</td><td>1</td><td>7</td></tr><tr><td>definefunction.FunctionList</td><td>2.8</td><td>8</td><td>14</td></tr><tr><td>expression.DefineFuncFactor</td><td>2.33</td><td>5</td><td>7</td></tr><tr><td>expression.DerivationFactor</td><td>1</td><td>1</td><td>4</td></tr><tr><td>expression.ExpFuncFactor</td><td>1.75</td><td>2</td><td>7</td></tr><tr><td>expression.Expr</td><td>2</td><td>3</td><td>10</td></tr><tr><td>expression.ExprFactor</td><td>2</td><td>3</td><td>8</td></tr><tr><td>expression.Factor</td><td>1</td><td>1</td><td>6</td></tr><tr><td>expression.NumFactor</td><td>1</td><td>1</td><td>4</td></tr><tr><td>expression.Term</td><td>2.86</td><td>8</td><td>20</td></tr><tr><td>expression.VarFactor</td><td>1.5</td><td>2</td><td>6</td></tr><tr><td>gather.Monomial</td><td>1.43</td><td>3</td><td>10</td></tr><tr><td>gather.Poly</td><td>4.13</td><td>14</td><td>62</td></tr><tr><td>pre.Treatment</td><td>2</td><td>5</td><td>12</td></tr></tbody></table></div><h4 id="2-调试闹鬼现象的分析"><a href="#2-调试闹鬼现象的分析" class="headerlink" title="2.调试闹鬼现象的分析"></a>2.调试闹鬼现象的分析</h4><p>通过讨论区即自己学习，后续作业中可以选择遵循Command与Query分离原则，即命令型方法无返回值，查询型方法不修改字段，不对形参进行副作用操作。</p><h4 id="3-作业感想"><a href="#3-作业感想" class="headerlink" title="3.作业感想"></a>3.作业感想</h4><p>关于第一次作业，开学第一天就被狠狠上强度，被迫开始速通OO，第二次作业中由于自己测试时没有充分考虑运行时间，所以强测寄了一个点，后续大改后，加上第三次作业较为简单，没出啥问题。</p><p>最后，未来建议互测小房间可不可以及时给出被hack的点（出现超时问题需要重构好及时构想，待到下一次作业布置两手抓真的不知道咋办）。</p>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象OO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA_CO_P7设计文稿</title>
    <link href="/2024/01/01/BUAA-CO-P7%E8%AE%BE%E8%AE%A1%E6%96%87%E7%A8%BF/"/>
    <url>/2024/01/01/BUAA-CO-P7%E8%AE%BE%E8%AE%A1%E6%96%87%E7%A8%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="P7CPU设计文稿"><a href="#P7CPU设计文稿" class="headerlink" title="P7CPU设计文稿"></a>P7CPU设计文稿</h1><h2 id="1-总体架构"><a href="#1-总体架构" class="headerlink" title="1.总体架构"></a>1.总体架构</h2><p><img src="Structure.png" alt="Structure"></p><p><strong>任务清单</strong></p><p>新增指令：<strong>mfc0,</strong> <strong>mtc0,</strong> <strong>eret,</strong> <strong>syscall</strong></p><p>P7 与之前的 project 相比，涉及的内容较多，所以在实现的时候很容易手忙脚乱，这里列出完成 P7 需要的事宜：</p><div class="table-container"><table><thead><tr><th style="text-align:left">任务</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">计时器</td><td style="text-align:left">课程组提供实现代码，只需要结合代码和文档理解应用即可。</td></tr><tr><td style="text-align:left">系统桥</td><td style="text-align:left">为 CPU 提供统一的访问外设的接口，需要按规格自行实现。</td></tr><tr><td style="text-align:left">协处理器 CP0</td><td style="text-align:left">设置 CPU 的异常处理功能，反馈 CPU 的异常信息，需要按规格自行实现。</td></tr><tr><td style="text-align:left">内部异常检测与流水</td><td style="text-align:left">CPU 需要具有可以检测内部指令执行错误的能力。</td></tr><tr><td style="text-align:left">外部中断响应</td><td style="text-align:left">CPU 需要具有初步响应外部中断信号的能力。</td></tr><tr><td style="text-align:left">异常处理指令</td><td style="text-align:left">在异常处理程序中，会有一些特殊的指令需要实现。</td></tr><tr><td style="text-align:left">单周期 CPU 的封装</td><td style="text-align:left">让 CPU 从外部看上去是一个单周期 CPU。</td></tr><tr><td style="text-align:left">异常处理程序</td><td style="text-align:left">利用 MARS 编写简单的异常处理程序用于测试。</td></tr></tbody></table></div><p><img src="p6cpu.jpg" alt="p6CPU"></p><h2 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2.具体实现"></a>2.具体实现</h2><h3 id="1-CP0"><a href="#1-CP0" class="headerlink" title="1.CP0"></a>1.CP0</h3><p>将CP0置于M级，故宏观PC为M级对于PC</p><p> CP0 的端口声明如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">端口</th><th style="text-align:left">方向</th><th style="text-align:left">位数</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">clk</td><td style="text-align:left">I</td><td style="text-align:left">1</td><td style="text-align:left">时钟信号。</td></tr><tr><td style="text-align:left">reset</td><td style="text-align:left">I</td><td style="text-align:left">1</td><td style="text-align:left">复位信号。</td></tr><tr><td style="text-align:left">en</td><td style="text-align:left">I</td><td style="text-align:left">1</td><td style="text-align:left">写使能信号。</td></tr><tr><td style="text-align:left">CP0Addr</td><td style="text-align:left">I</td><td style="text-align:left">5</td><td style="text-align:left">寄存器地址。</td></tr><tr><td style="text-align:left">CP0In</td><td style="text-align:left">I</td><td style="text-align:left">32</td><td style="text-align:left">CP0 写入数据。</td></tr><tr><td style="text-align:left">CP0Out</td><td style="text-align:left">O</td><td style="text-align:left">32</td><td style="text-align:left">CP0 读出数据。</td></tr><tr><td style="text-align:left">VPC</td><td style="text-align:left">I</td><td style="text-align:left">32</td><td style="text-align:left">受害 PC。</td></tr><tr><td style="text-align:left">BDIn</td><td style="text-align:left">I</td><td style="text-align:left">1</td><td style="text-align:left">是否是延迟槽指令。</td></tr><tr><td style="text-align:left">ExcCodeIn</td><td style="text-align:left">I</td><td style="text-align:left">5</td><td style="text-align:left">记录异常类型。</td></tr><tr><td style="text-align:left">HWInt</td><td style="text-align:left">I</td><td style="text-align:left">6</td><td style="text-align:left">输入中断信号。</td></tr><tr><td style="text-align:left">EXLClr</td><td style="text-align:left">I</td><td style="text-align:left">1</td><td style="text-align:left">用来复位 EXL。</td></tr><tr><td style="text-align:left">EPCOut</td><td style="text-align:left">O</td><td style="text-align:left">32</td><td style="text-align:left">EPC 的值。</td></tr><tr><td style="text-align:left">Req</td><td style="text-align:left">O</td><td style="text-align:left">1</td><td style="text-align:left">进入处理程序请求。</td></tr></tbody></table></div><p>CP0位置确定</p><h3 id="2-约定"><a href="#2-约定" class="headerlink" title="2.约定"></a>2.约定</h3><ol><li>如果发生异常的指令是延迟槽指令，那么返回程序时仍然返回这条指令所属的跳转指令。也就是说“异常延迟槽回到跳转”。</li><li>如果发生异常的指令是跳转指令，那么我们要求执行完延迟槽。</li><li>如果发生异常的指令是乘除指令的下一条，乘除指令不被撤回。也就是对于 M错误指令，W乘除指令 的情况，此时乘除槽正在计算，本来在异常处理时可能会覆盖乘除槽的结果，但是我们约定不会这么做。但是注意，如果是 E乘除指令，M错误指令，你要保证乘除指令不执行。</li></ol><p><strong>范围约定</strong></p><p><img src="strict.png" alt="strict"></p><h3 id="3-中断异常"><a href="#3-中断异常" class="headerlink" title="3.中断异常"></a>3.中断异常</h3><p><strong>中断异常约束</strong></p><ul><li><p>异常入口：《SMRL》的表 5.1 中定义了 MIPS 的异常入口，但考虑到简化设计以及与 MARS 保持一致，我们只支持 0x4180 一个入口地址，所有异常与中断都将从这里进入。</p></li><li><p>嵌套中断异常：本实验不要求支持中断异常嵌套的情况。</p></li><li><p>优先级：中断优先级高于异常优先级，即当有异常提交至 CP0 寄存器时，若有中断发生，则硬件应先响应中断，并重新执行受害指令及其后续指令；若没有中断发生，则处理异常。</p></li><li><p>精确异常：</p><ul><li><p>除下面的情况外，对所有中断异常的处理都应遵循精确异常的处理规则。</p></li><li><p>在进入中断或异常状态时，如果受害指令及其后续指令</p><p>已经改变</p><p>了 MDU 的状态，则无需恢复。假设 CP0 在 M 级，MDU 在 E 级，考虑以下情况：</p><ul><li><code>mult</code> 在 E 级启动了乘法运算，流水到 M 级时产生了中断，此时无需停止乘法计算，其它乘除法指令同理。</li><li><code>mthi</code> 在 E 级修改了 HI 寄存器，流水到 M 级时产生了中断，此时无需恢复 HI 寄存器的值，<code>mtlo</code> 同理。</li><li><code>mult</code> 在 E 级，受害指令在 M 级，此时还未改变 MDU 状态，不应开始乘法计算，其它乘除法指令同理。</li><li><code>mthi</code> 在 E 级，受害指令在 M 级，此时还未改变 MDU 状态，不应修改 HI 寄存器的值，<code>mtlo</code> 同理。</li></ul></li></ul></li><li><p>中断规范：</p><ul><li>Timer0 输出的中断信号接入 HWInt[0] (最低中断位)，Timer1 输出的中断信号接入 HWInt[1]，来自中断发生器的中断信号接入 HWInt[2]。</li><li>规定中断产生时的受害指令为宏观 PC 对应的指令，此时应将宏观 PC 写入 EPC。</li></ul></li><li><p>MIPS 微系统需要支持的异常：</p><p>| ExcCode | 助记符  | 描述                                             |<br>| :——— | :——— | :———————————————————————- |<br>| 0       | Int     | 中断。                                           |<br>| 4       | AdEL    | 取数或取指时地址错误。                           |<br>| 5       | AdES    | 存数时地址错误。                                 |<br>| 8       | Syscall | 系统调用。                                       |<br>| 10      | RI      | 不认识的（或者非法的）指令码。                   |<br>| 12      | Ov      | 自陷形式的整数算术指令（例如 <code>add</code>）导致的溢出。 |</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">异常与中断码</th><th style="text-align:left">助记符与名称</th><th style="text-align:left">指令与指令类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left"><code>Int</code> （外部中断）</td><td style="text-align:left">所有指令</td><td style="text-align:left">中断请求，来源于计时器与外部中断。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><code>AdEL</code> （取指异常）</td><td style="text-align:left">所有指令</td><td style="text-align:left">PC 地址未字对齐。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">PC 地址超过 <code>0x3000 ~ 0x6ffc</code>。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>AdEL</code> （取数异常）</td><td style="text-align:left"><code>lw</code></td><td style="text-align:left">取数地址未与 4 字节对齐。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"><code>lh</code></td><td style="text-align:left">取数地址未与 2 字节对齐。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"><code>lh</code>, <code>lb</code></td><td style="text-align:left">取 Timer 寄存器的值。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">load 型指令</td><td style="text-align:left">计算地址时加法溢出。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">load 型指令</td><td style="text-align:left">取数地址超出 DM、Timer0、Timer1、中断发生器的范围。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><code>AdES</code> （存数异常）</td><td style="text-align:left"><code>sw</code></td><td style="text-align:left">存数地址未 4 字节对齐。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"><code>sh</code></td><td style="text-align:left">存数地址未 2 字节对齐。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"><code>sh</code>, <code>sb</code></td><td style="text-align:left">存 Timer 寄存器的值。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">store 型指令</td><td style="text-align:left">计算地址加法溢出。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">store 型指令</td><td style="text-align:left">向计时器的 Count 寄存器存值。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">store 型指令</td><td style="text-align:left">存数地址超出 DM、Timer0、Timer1、中断发生器的范围。</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><code>Syscall</code> （系统调用）</td><td style="text-align:left"><code>syscall</code></td><td style="text-align:left">系统调用。</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><code>RI</code>（未知指令）</td><td style="text-align:left"></td><td style="text-align:left">未知的指令码。</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><code>Ov</code>（溢出异常）</td><td style="text-align:left"><code>add</code>, <code>addi</code>, <code>sub</code></td><td style="text-align:left">算术溢出。</td></tr></tbody></table></div><h3 id="4-eret指令"><a href="#4-eret指令" class="headerlink" title="4.eret指令"></a>4.eret指令</h3><p>eret 将保存在 CP0 的 EPC 寄存器中的现场(被中断指令的下一条地址)写入 PC，从而实现从中断、 异常或指令执行错误的处理程序中返回</p><h2 id="3-思考题"><a href="#3-思考题" class="headerlink" title="3.思考题"></a>3.思考题</h2><h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h3><p>1、请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？</p><p>2、请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）</p><p>3、为何与外设通信需要 Bridge？</p><p>4、请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。</p><p>5、倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？</p><p>6、为什么 <code>jalr</code> 指令为什么不能写成 <code>jalr $31, $31</code>？</p><h3 id="2-答案"><a href="#2-答案" class="headerlink" title="2.答案"></a>2.答案</h3><ol><li><p>鼠标和键盘的输入信号是通过它们的接口（例如 USB）发送给计算机的主板。主板上的输入/输出控制器会将这些信号转换成数字信号，然后发送给中央处理器（CPU）。CPU会解析这些信号并根据用户的操作来执行相应的指令。IO设备的输入输出有好几种方式，键盘、鼠标这类的低速设备是通过中断请求的方式进行IO操作的。即当键盘上按下一个按键的时候，键盘会发出一个中断信号，中断信号经过中断控制器传到CPU，然后CPU根据不同的中断号执行不同的中断响应程序，然后进行相应的IO操作，把按下的按键编码读到寄存器（或者鼠标的操作），最后放入内存中。</p></li><li><p>保证设计的统一性，即通过协议保证接口更加兼容。用户使用自定义处理可能出现不兼容的问题</p></li><li><p>正如教程所说，系统桥是连接 CPU 和外设的功能设备，它会给 CPU 提供一种接口，使得 CPU 可以像读写普通存储器一样（即按地址读写）来读写复杂多变的外设，不用管数据是从哪来，怎么来，只用发挥CPU本身功能就可以。系统桥统一且简化了 CPU 的对外接口，CPU 不必为每种外设单独提供接口，符合高内聚，低耦合的设计思想。</p></li><li><p>模式0通常用于产生定时中断  ,当计数器倒计数为 0 后，计数器停止计数，Ctrl 寄存器的计数使能自动变为 0，并且中断信号始终保持有效，直到屏蔽中断或重新开始计数。</p><p><img src="mode0.jpg" alt="mode0"></p><p>模式1当计数器倒计数为 0 后， 初值寄存器值被自动加载至计数器， 计数器继续倒计数。模式 1 通常用于产生周期性脉冲</p><p><img src="mode1.jpg" alt="mode1"></p></li><li><p>会导致宏观PC突然为0或者为x。在清空流水线的时候，应该保留PC信息。</p></li><li><p>PC &lt;- GPR[rs]和GPR[rd] &lt;- PC + 4的进行顺序未知，存在二义</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成CO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA_CO_P5和P6CPU设计文稿</title>
    <link href="/2024/01/01/BUAA-CO-P5%E5%92%8CP6CPU%E8%AE%BE%E8%AE%A1%E6%96%87%E7%A8%BF/"/>
    <url>/2024/01/01/BUAA-CO-P5%E5%92%8CP6CPU%E8%AE%BE%E8%AE%A1%E6%96%87%E7%A8%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="P5——CPU设计文稿"><a href="#P5——CPU设计文稿" class="headerlink" title="P5——CPU设计文稿"></a>P5——CPU设计文稿</h1><h2 id="1-总示意图"><a href="#1-总示意图" class="headerlink" title="1.总示意图"></a>1.总示意图</h2><p><img src="p5cpu.jpg" alt="p5CPU"></p><h2 id="2-命名规范"><a href="#2-命名规范" class="headerlink" title="2.命名规范"></a>2.命名规范</h2><p>1.模块以及接口加上各级前缀</p><p>2.属于某模块在级后面在加模块名</p><h2 id="3-模块定义"><a href="#3-模块定义" class="headerlink" title="3.模块定义"></a>3.模块定义</h2><h3 id="1）Datapath"><a href="#1）Datapath" class="headerlink" title="1）Datapath"></a>1）Datapath</h3><h4 id="1、E-ALU模块"><a href="#1、E-ALU模块" class="headerlink" title="1、E_ALU模块"></a>1、E_ALU模块</h4><p>同指导书，改为case来操作</p><div class="table-container"><table><thead><tr><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">E_ALU_A [31 : 0]</td><td style="text-align:center">I</td><td style="text-align:left">32位输入信号</td></tr><tr><td style="text-align:center">E_ALU_B [31 : 0]</td><td style="text-align:center">I</td><td style="text-align:left">32位输入信号</td></tr><tr><td style="text-align:center">E_ALU_Shamt [4 : 0]</td><td style="text-align:center">I</td><td style="text-align:left">五位输入信号</td></tr><tr><td style="text-align:center">E_ALUop [2 : 0]</td><td style="text-align:center">I</td><td style="text-align:left">操作选择控制    <br>E_ALUop == 3’b000 A +B；<br>E_ALUop == 3’b001 A - B;<br>E_ALUop == 3’b010 A \</td><td>B; <br>E_ALUop == 3’b011 A &amp; B;<br>E_ALUop == 3’b100 B左移Shamt位<br>E_ALUop == 3’b101 B加载到高位</td></tr><tr><td style="text-align:center">E_ALU_Result [31 : 0]</td><td style="text-align:center">O</td><td style="text-align:left">32位输出信号</td></tr></tbody></table></div><h4 id="2、D-CMP模块"><a href="#2、D-CMP模块" class="headerlink" title="2、D_CMP模块"></a>2、D_CMP模块</h4><p>从原来的ALU模块分离出来到译码阶段</p><div class="table-container"><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>D_CMP_A [31: 0]</td><td>I</td><td>32位输入</td></tr><tr><td>D_CMP_B [31: 0]</td><td>I</td><td>32位输入</td></tr><tr><td>D_CMP_Equal</td><td>O</td><td>相等 ？ 1  ：0</td></tr><tr><td>D_CMP_Less</td><td>O</td><td>小于 ？ 1  ：0</td></tr><tr><td>D_CMP_Greater</td><td>O</td><td>大于 ？ 1 ： 0</td></tr></tbody></table></div><h4 id="3、E-EXT模块"><a href="#3、E-EXT模块" class="headerlink" title="3、E_EXT模块"></a>3、E_EXT模块</h4><div class="table-container"><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>D_EXT_Imm [15: 0 ]</td><td>I</td><td>16位待扩展立即数</td></tr><tr><td>D_EXTop [1:0]</td><td>I</td><td>扩展选择<br>D_EXTop == 2’b00 符号扩展<br>D_EXTop == 2’b01 无符号扩展</td></tr><tr><td>D_EXT_Result [31:0]</td><td>O</td><td>扩展结果</td></tr></tbody></table></div><h4 id="4、F-PC模块"><a href="#4、F-PC模块" class="headerlink" title="4、F_PC模块"></a>4、F_PC模块</h4><div class="table-container"><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>F_PC_clk</td><td>I</td><td>时钟信号</td></tr><tr><td>F_PC_reset</td><td>I</td><td>复位信号</td></tr><tr><td>F_PC_en</td><td>I</td><td>使能信号</td></tr><tr><td>F_PC_ NPC [31:0]</td><td>I</td><td>32位输入信号</td></tr><tr><td>F_PC_PC [31:0]</td><td>O</td><td>输出信号</td></tr></tbody></table></div><h4 id="5、F-IM模块"><a href="#5、F-IM模块" class="headerlink" title="5、F_IM模块"></a>5、F_IM模块</h4><div class="table-container"><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>F_IM_PC [31:0]</td><td>I</td><td>32位取址信号</td></tr><tr><td>F_IM_Instr [31 :0]</td><td>O</td><td>32位结果</td></tr></tbody></table></div><h4 id="6、D-NPC模块"><a href="#6、D-NPC模块" class="headerlink" title="6、D_NPC模块"></a>6、D_NPC模块</h4><div class="table-container"><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>D_NPC_PC[31:0]</td><td>I</td><td>32位PC信号</td></tr><tr><td>D_NPC_Imm[26:0]</td><td>I</td><td>26位立即数地址</td></tr><tr><td>D_NPC_RA[31:0]</td><td>I</td><td>$RA</td></tr><tr><td>D_NPC_Branch[2 :0]</td><td>I</td><td>对应不同Branch<br>3’b000表示不是Branch<br>若为3’b001对应beq</td></tr><tr><td>D_NPC_J</td><td>I</td><td>对应J跳转指令</td></tr><tr><td>D_NPC_JR</td><td>I</td><td>对应Jr跳转指令</td></tr><tr><td>D_NPC_Equal</td><td>I</td><td>比较结果</td></tr><tr><td>D_NPC_Great</td><td>I</td><td>比较结果</td></tr><tr><td>D_NPC_Less</td><td>I</td><td>比较结果</td></tr><tr><td>D_NPC_NPC[31:0]</td><td>O</td><td></td></tr><tr><td>D_Jump</td><td>O</td><td>判断地址是否跳转</td></tr></tbody></table></div><h4 id="7、D-GRF模块"><a href="#7、D-GRF模块" class="headerlink" title="7、D_GRF模块"></a>7、D_GRF模块</h4><div class="table-container"><table><thead><tr><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">D_GRF_A1 [4:0]</td><td style="text-align:center">I</td><td style="text-align:left">5位地址输入信号，输入rs指定的寄存器并将其结果读出到RD1</td></tr><tr><td style="text-align:center">D_GRF_A2 [4:0]</td><td style="text-align:center">I</td><td style="text-align:left">5位地址输入信号，输入rt指定的寄存器并将其结果读出到RD2</td></tr><tr><td style="text-align:center">D_GRF_A3 [4:0]</td><td style="text-align:center">I</td><td style="text-align:left">5位地址输入信号，输入rd指定的寄存器并将WD写入</td></tr><tr><td style="text-align:center">D_GRF_WD [31:0]</td><td style="text-align:center">I</td><td style="text-align:left">32位输入信号</td></tr><tr><td style="text-align:center">D_GRF_clk</td><td style="text-align:center">I</td><td style="text-align:left">时钟信号</td></tr><tr><td style="text-align:center">D_GRF_reset</td><td style="text-align:center">I</td><td style="text-align:left">异步复位信号</td></tr><tr><td style="text-align:center">D_GRF_WE</td><td style="text-align:center">I</td><td style="text-align:left">使能信号</td></tr><tr><td style="text-align:center">D_GRF_RD1 [31:0]</td><td style="text-align:center">O</td><td style="text-align:left">输出A1指定寄存器的32位数据</td></tr><tr><td style="text-align:center">D_GRF_RD2 [31:0]</td><td style="text-align:center">O</td><td style="text-align:left">输出A2指定寄存器的32位数据</td></tr></tbody></table></div><h4 id="8、M-DM模块"><a href="#8、M-DM模块" class="headerlink" title="8、M_DM模块"></a>8、M_DM模块</h4><div class="table-container"><table><thead><tr><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">M_DM_clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">M_DM_reset</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">M_Mem_Write</td><td style="text-align:center">I</td><td style="text-align:center">写信号</td></tr><tr><td style="text-align:center">M_signed</td><td style="text-align:center">I</td><td style="text-align:center">输出是否符号位扩展信号</td></tr><tr><td style="text-align:center">Size</td><td style="text-align:center">I</td><td style="text-align:center">决定是字、半字、字节</td></tr><tr><td style="text-align:center">M_ALU_Result[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">储存地址</td></tr><tr><td style="text-align:center">M_WriteData[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">储存数据</td></tr><tr><td style="text-align:center">M_PC[31:0]]</td><td style="text-align:center">I</td><td style="text-align:center">PC</td></tr><tr><td style="text-align:center">M_Read_Data</td><td style="text-align:center">O</td><td style="text-align:center">load结果</td></tr></tbody></table></div><h4 id="9、Controller"><a href="#9、Controller" class="headerlink" title="9、Controller"></a>9、Controller</h4><p>根据名称要求更改，采取重构</p><div class="table-container"><table><thead><tr><th style="text-align:center">信号名</th><th style="text-align:center">方向</th></tr></thead><tbody><tr><td style="text-align:center">opcode[5:0]</td><td style="text-align:center">I</td></tr><tr><td style="text-align:center">funct[5:0]</td><td style="text-align:center">I</td></tr><tr><td style="text-align:center">D_EXTop [1:0]</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">D_NPC_Branch [2:0]</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">D_NPC_J</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">D_NPC_JR</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">E_Reg_Dst [1:0]</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">E_ALU_Src [1:0]</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">E_ALUop [2:0]</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">M_Mem_Write</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">M_DM_Size[1:0]</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">M_Signed</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">W_MemtoReg [1:0]</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">W_RegWrite</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">D_Rs_Tuse</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">D_Rt_Tuse</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">D_Tnew</td><td style="text-align:center">O</td></tr></tbody></table></div><p>其真值表对应如下，同时改为case结构，代码长度显著增加，但便于debug</p><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th>D_EXTop[1:0]</th><th>D_NPC_Branch[2:0]</th><th>D_NPC_J</th><th>D_NPC_JR</th><th>D_Reg_Dst[1:0]</th><th>E_ALU_Src[1:0]</th><th>E_ALUop[2:0]</th><th>M_Mem_Write</th><th>M_DM_Size[1:0]</th><th>M_signed</th><th>W_MemtoReg[1:0]</th><th>W_RegWrite</th></tr></thead><tbody><tr><td style="text-align:center">Add</td><td>00</td><td>000</td><td>0</td><td>0</td><td>01</td><td>00</td><td>000</td><td>0</td><td>00</td><td>0</td><td>01</td><td>1</td></tr><tr><td style="text-align:center">Sub</td><td>00</td><td>000</td><td>0</td><td>0</td><td>01</td><td>00</td><td>001</td><td>0</td><td>00</td><td>0</td><td>01</td><td>1</td></tr><tr><td style="text-align:center">Jr</td><td>00</td><td>000</td><td>0</td><td>1</td><td>00</td><td>00</td><td>000</td><td>0</td><td>00</td><td>0</td><td>00</td><td>0</td></tr><tr><td style="text-align:center">Ori</td><td>01</td><td>000</td><td>0</td><td>0</td><td>00</td><td>01</td><td>010</td><td>0</td><td>00</td><td>0</td><td>01</td><td>1</td></tr><tr><td style="text-align:center">Lw</td><td>00</td><td>000</td><td>0</td><td>0</td><td>00</td><td>01</td><td>000</td><td>0</td><td>00</td><td>0</td><td>00</td><td>1</td></tr><tr><td style="text-align:center">Sw</td><td>00</td><td>000</td><td>0</td><td>0</td><td>00</td><td>01</td><td>000</td><td>1</td><td>00</td><td>0</td><td>00</td><td>0</td></tr><tr><td style="text-align:center">Beq</td><td>00</td><td>001</td><td>0</td><td>0</td><td>00</td><td>00</td><td>000</td><td>0</td><td>00</td><td>0</td><td>00</td><td>0</td></tr><tr><td style="text-align:center">Lui</td><td>00</td><td>000</td><td>0</td><td>0</td><td>00</td><td>01</td><td>101</td><td>0</td><td>00</td><td>0</td><td>01</td><td>1</td></tr><tr><td style="text-align:center">J</td><td>00</td><td>000</td><td>1</td><td>0</td><td>00</td><td>00</td><td>00</td><td>0</td><td>00</td><td>0</td><td>00</td><td>0</td></tr><tr><td style="text-align:center">Jal</td><td>00</td><td>000</td><td>1</td><td>0</td><td>10</td><td>01</td><td>000</td><td>0</td><td>00</td><td>0</td><td>10</td><td>1</td></tr></tbody></table></div><h3 id="2）RiskUnit-冒险处理"><a href="#2）RiskUnit-冒险处理" class="headerlink" title="2）RiskUnit 冒险处理"></a>2）RiskUnit 冒险处理</h3><p>D_Tuse与D_Tnew表格，每次走过一个寄存器，T_new都会减一</p><p>Tuse&lt;Tnew 暂停</p><p>对不需要使用寄存器的Tuse置最大值。</p><p>注意：不转发0</p><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">D_Rs_Tuse</th><th style="text-align:center">D_Rt_Tuse</th><th style="text-align:center">D_Tnew</th></tr></thead><tbody><tr><td style="text-align:center">Add</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Sub</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Jr</td><td style="text-align:center">0</td><td style="text-align:center">M</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Ori</td><td style="text-align:center">1</td><td style="text-align:center">M</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Lw</td><td style="text-align:center">1</td><td style="text-align:center">M</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">Sw</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Beq</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Lui</td><td style="text-align:center">M</td><td style="text-align:center">M</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">J</td><td style="text-align:center">M</td><td style="text-align:center">M</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Jal</td><td style="text-align:center">M</td><td style="text-align:center">M</td><td style="text-align:center">2</td></tr></tbody></table></div><h2 id="4-测试数据"><a href="#4-测试数据" class="headerlink" title="4.测试数据"></a>4.测试数据</h2><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-string">`0x0000000000000000:  34 1C 00 00    ori <span class="hljs-variable">$gp</span>, <span class="hljs-variable">$zero</span>, 0`</span> <br><br><span class="hljs-string">`0x0000000000000004:  34 1D 00 00    ori <span class="hljs-variable">$sp</span>, <span class="hljs-variable">$zero</span>, 0`</span> <br><br><span class="hljs-string">`0x0000000000000008:  34 01 10 10    ori <span class="hljs-variable">$at</span>, <span class="hljs-variable">$zero</span>, 0x1010`</span> <br><br><span class="hljs-string">`0x000000000000000c:  3C 02 87 23    lui <span class="hljs-variable">$v0</span>, 0x8723`</span> <br><br><span class="hljs-string">`0x0000000000000010:  34 03 78 56    ori <span class="hljs-variable">$v1</span>, <span class="hljs-variable">$zero</span>, 0x7856`</span> <br><br><span class="hljs-string">`0x0000000000000014:  3C 04 85 FF    lui <span class="hljs-variable">$a0</span>, 0x85ff`</span> <br><br><span class="hljs-string">`0x0000000000000018:  34 05 00 01    ori <span class="hljs-variable">$a1</span>, <span class="hljs-variable">$zero</span>, 1`</span> <br><br><span class="hljs-string">`0x000000000000001c:  3C 06 FF FF    lui <span class="hljs-variable">$a2</span>, 0xffff`</span> <br><br><span class="hljs-string">`0x0000000000000020:  34 07 FF FF    ori <span class="hljs-variable">$a3</span>, <span class="hljs-variable">$zero</span>, 0xffff`</span> <br><br><span class="hljs-string">`0x0000000000000024:  00 22 08 20    add <span class="hljs-variable">$at</span>, <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v0</span>`</span> <br><br><span class="hljs-string">`0x0000000000000028:  00 23 48 20    add <span class="hljs-variable">$t1</span>, <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v1</span>`</span> <br><br><span class="hljs-string">`0x000000000000002c:  00 22 40 22    sub <span class="hljs-variable">$t0</span>, <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v0</span>`</span> <br><br><span class="hljs-string">`0x0000000000000030:  00 E0 00 22    sub <span class="hljs-variable">$zero</span>, <span class="hljs-variable">$a3</span>, <span class="hljs-variable">$zero</span>`</span> <br><br><span class="hljs-string">`0x0000000000000034:  13 91 00 03    beq <span class="hljs-variable">$gp</span>, <span class="hljs-variable">$s1</span>, 0x44`</span> <br><br><span class="hljs-string">`0x0000000000000038:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x000000000000003c:  10 00 00 15    b   0x94`</span> <br><br><span class="hljs-string">`0x0000000000000040:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x0000000000000044:  10 22 00 13    beq <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v0</span>, 0x94`</span> <br><br><span class="hljs-string">`0x0000000000000048:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x000000000000004c:  34 02 00 0C    ori <span class="hljs-variable">$v0</span>, <span class="hljs-variable">$zero</span>, 0xc`</span> <br><br><span class="hljs-string">`0x0000000000000050:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x0000000000000054:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x0000000000000058:  00 00 00 00    nop`</span> <br><br><span class="hljs-string">`0x000000000000005c:  0C 00 0C 1B    jal 0x306c`</span> <br><br><span class="hljs-string">`0x0000000000000060:  AC 41 00 00    sw  <span class="hljs-variable">$at</span>, (<span class="hljs-variable">$v0</span>)`</span> <br><br><span class="hljs-string">`0x0000000000000064:  10 00 00 0B    b   0x94`</span> <br><br><span class="hljs-string">`0x0000000000000068:  00 22 08 20    add <span class="hljs-variable">$at</span>, <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v0</span>`</span> <br><br><span class="hljs-string">`0x000000000000006c:  00 22 08 20    add <span class="hljs-variable">$at</span>, <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v0</span>`</span> <br><br><span class="hljs-string">`0x0000000000000070:  00 22 08 20    add <span class="hljs-variable">$at</span>, <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v0</span>`</span><br><br> <span class="hljs-string">`0x0000000000000074:  00 22 08 20    add <span class="hljs-variable">$at</span>, <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v0</span>`</span> <br><br><span class="hljs-string">`0x0000000000000078:  AC 5F 00 00    sw  <span class="hljs-variable">$ra</span>, (<span class="hljs-variable">$v0</span>)`</span> <br><br><span class="hljs-string">`0x000000000000007c:  8C 41 00 00    lw  <span class="hljs-variable">$at</span>, (<span class="hljs-variable">$v0</span>)`</span> <br><br><span class="hljs-string">`0x0000000000000080:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x0000000000000084:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x0000000000000088:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x000000000000008c:  00 20 00 08    jr  <span class="hljs-variable">$at</span>`</span> <br><br><span class="hljs-string">`0x0000000000000090:  AC 5F 00 00    sw  <span class="hljs-variable">$ra</span>, (<span class="hljs-variable">$v0</span>)`</span> <br><br><span class="hljs-string">`0x0000000000000094:  10 00 FF FF    b   0x94`</span> <br><br><span class="hljs-string">`0x0000000000000098:  00 00 00 00    nop`</span> <br></code></pre></td></tr></table></figure><h2 id="5-思考题"><a href="#5-思考题" class="headerlink" title="5.思考题"></a>5.思考题</h2><p>1.在D级就直接就直接计算出是否需要跳转，若需要发生跳转，由于NPC是组合逻辑，下一条指令的地址直接传出到PC模块，这样只会多读跳转指令下一条的指令，即使将分支判断提到 D 级，发生跳转的时候，F 级指令依然是需要作废的。但是我们如果约定 F 级指令不作废呢？也就是说，不论判断结果如何，我们都将执行分支或跳转指令的下一条指令。这也就是所谓的“<strong>延迟槽</strong>”。那么指令执行的效率就提高了。</p><p>2.Jal需要将jal下一条指令的位置写入$ra寄存器，由于延迟槽的地址是PC+4，所以实际应该写回PC +8了。</p><p>3.流水线中的各个阶段需要在特定的时钟周期内完成其任务。如果数据来自功能部件，可能会增加流水线的复杂性，导致更难以保持稳定的时序。通过限制数据转发只能来自寄存器，可以简化流水线的设计，提高稳定性。</p><p>4.当前 GPR 被写入的值会即时反馈到读取端上。具体的说，当读寄存器时的地址与同周期写寄存器的地址相同时，我们将读取的内容改为写寄存器的内容，而不是该地址可以索引到的寄存器文件中的值。这也就对应着图中的两个四选一多路选择器。利用冲突单元生成选择信号即可</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">assign</span> D_ForwardA = <br>    (D_Rs == M_Write_Reg &amp;&amp; M_MemtoReg == <span class="hljs-number">2&#x27;b01</span> &amp;&amp; M_Reg_Write == <span class="hljs-number">1&#x27;b1</span> &amp;&amp; M_Write_Reg != <span class="hljs-number">5&#x27;b00000</span>) ? `M_Data_ALU :<br>    (D_Rs == M_Write_Reg &amp;&amp; M_MemtoReg == <span class="hljs-number">2&#x27;b10</span> &amp;&amp; M_Reg_Write == <span class="hljs-number">1&#x27;b1</span> &amp;&amp; M_Write_Reg != <span class="hljs-number">5&#x27;b00000</span>) ? `M_Data_PC8 :<br>    (D_Rs == W_Write_Reg &amp;&amp; W_Reg_Write == <span class="hljs-number">1&#x27;b1</span>  &amp;&amp; W_Write_Reg != <span class="hljs-number">5&#x27;b00000</span>) ? `W_Data :<br>                                                `D_Data ;<br></code></pre></td></tr></table></figure><p>5.需求者：D级：CMP，E级：ALU</p><p>​    提供者：M级：ALU_Result,PC8</p><p>​                    W级：因为已经被选择过，过Writeback_Data就已经可以满足需求</p><p>6.大致可将指令分为三类</p><p>​    1）计算指令，主要对ALU模块进行增加操作，如Add指令</p><p>​    2）跳转指令，可能需要调整ALU模块或者NPC，由于这里是流水线，ALU模块的输出不能直接和单周期一样课上直接连在NPC模块，可能需要考虑在增加D级就增加符合跳转的运算</p><p>​    3）访存指令，DM中已经支持字、半字、字节的存取，根据题意做ALU，NPC等对应的增添即可</p><p>7.采取分散式译码</p><p>译码结果较易观察，且不容易产生bug，不同指令之间完全分离，缺点就是代码冗长。</p><p>选做2，采取交叉式出现</p><h1 id="P6——CPU"><a href="#P6——CPU" class="headerlink" title="P6——CPU"></a>P6——CPU</h1><p>支持指令：<strong>add,</strong> <strong>sub,</strong> <strong>and,</strong> <strong>or,</strong> <strong>slt,</strong> <strong>sltu,</strong> <strong>lui</strong> <strong>addi,</strong> <strong>andi,</strong> <strong>ori</strong> <strong>lb,</strong> <strong>lh,</strong> <strong>lw,</strong> <strong>sb,</strong> <strong>sh,</strong> <strong>sw</strong> <strong>mult,</strong> <strong>multu,</strong> <strong>div,</strong> <strong>divu,</strong> <strong>mfhi,</strong> <strong>mflo,</strong> <strong>mthi,</strong> <strong>mtlo</strong> <strong>beq,</strong> <strong>bne,</strong> <strong>jal,</strong> <strong>jr</strong></p><h2 id="1-模块定义"><a href="#1-模块定义" class="headerlink" title="1.模块定义"></a>1.模块定义</h2><p>增加E_MUDI乘除模块与M_DE模块，删除看F_IM与M_DM模块</p><h4 id="1、M-BE"><a href="#1、M-BE" class="headerlink" title="1、M_BE"></a>1、M_BE</h4><div class="table-container"><table><thead><tr><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">M_BE_A[1:0]</td><td style="text-align:center">I</td><td style="text-align:left">最低两位的地址</td></tr><tr><td style="text-align:center">M_BE_Din[31:0]</td><td style="text-align:center">I</td><td style="text-align:left">输入的 32 位数据</td></tr><tr><td style="text-align:center">M_BE_Op[2:0]</td><td style="text-align:center">I</td><td style="text-align:left">数据扩展控制码 000：<br>无扩展 001：无符号字节数据扩展 <br>010：符号字节数据扩展 <br>011：无符号半字数据扩展 <br>100：符号半字数据扩展</td></tr><tr><td style="text-align:center">M_BE_Dout[31:0]</td><td style="text-align:center">O</td><td style="text-align:left">扩展后的 32 位数据</td></tr></tbody></table></div><h4 id="2、E-MUDI"><a href="#2、E-MUDI" class="headerlink" title="2、E_MUDI"></a>2、E_MUDI</h4><div class="table-container"><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>E_MUDI_clk</td><td>I</td><td>时钟信号</td></tr><tr><td>E_MUDI_reset</td><td>I</td><td>复位信号</td></tr><tr><td>E_MUDI_A [31:0]</td><td>I</td><td>运算数据A</td></tr><tr><td>E_MUDI_B [31:0]</td><td>I</td><td>运算数据B</td></tr><tr><td>E_MUDI_Start</td><td>I</td><td>开始计算信号</td></tr><tr><td>E_MUDI_op [2:0]</td><td>I</td><td>运算选择信号</td></tr><tr><td>E_HI_Write</td><td>I</td><td>高位写信号</td></tr><tr><td>E_LO_Write</td><td>I</td><td>地位写信号</td></tr><tr><td>E_HI [31:0]</td><td>O</td><td>高位寄存器输出结果</td></tr><tr><td>E_LO[31:0]</td><td>O</td><td>低位寄存器输出结果</td></tr><tr><td>E_MUDI_Busy</td><td>O</td><td>计算中信号</td></tr></tbody></table></div><h2 id="2-总示意图"><a href="#2-总示意图" class="headerlink" title="2.总示意图"></a>2.总示意图</h2><p><img src="p6cpu.jpg" alt="p6CPU"></p><h2 id="3-思考题"><a href="#3-思考题" class="headerlink" title="3.思考题"></a>3.思考题</h2><p>1.乘除法运算效率远低于ALU内的各个计算，需要耗费大量时间，放在一起会大大拖慢效率，独立的HI、LO也是为了高效率，因为只有乘除法会用到高位寄存器，低位寄存器，与其他不一致，分开便于控制。</p><p>2.真实的流水线 CPU 使用乘法和除法指令来实现乘除法运算。在执行乘法和除法指令时，CPU会将操作数加载到寄存器中，然后通过一系列的算术逻辑单元(ALU)来进行乘法或除法计算。这些计算通常会在多个时钟周期内完成，因为乘法和除法是比较复杂的运算。乘法：乘法可以通过一系列的加法和移位来实现。处理器中的乘法单元通常包括：部分积生成器（Partial Product Generator）：将两个乘数的每一位相乘，生成部分积。部分积累加器（Partial Product Accumulator）： 将所有部分积相加，得到最终的乘积。这个过程可能需要多个时钟周期，因此在流水线中可能会有多个阶段用于处理不同的部分。除法：除法通常比乘法更为复杂，可能涉及到迭代的过程。处理器中的除法单元通常包括：部分商生成器（Partial Quotient Generator）： 生成每一位的部分商。部分商累加器（Partial Quotient Accumulator）： 将所有部分商相加，得到最终的商。这个过程同样可能需要多个时钟周期，并且可能需要进行多轮迭代来得到最终的结果。</p><p>在流水线中，这些乘法和除法的阶段可能被划分为多个子阶段，以便在每个时钟周期内执行一些部分操作。流水线的设计需要考虑到数据相关性、控制信号的传递以及流水线暂停和刷新等问题，以确保正确且高效地执行指令。</p><p>3.当且仅当Busy且指令为乘除有关的那八条指令时阻塞</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">assign</span> MUDI_Stall = (E_MUDI_Busy == <span class="hljs-number">1&#x27;b1</span>  || E_MUDI_Start == <span class="hljs-number">1&#x27;b1</span>) &amp;&amp; (D_MD_MT_MF == <span class="hljs-number">1&#x27;b1</span>) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br></code></pre></td></tr></table></figure><p>4.清晰性：每个字节的写分开，互不干扰，统一性：各个字节的控制信号仍然来自m_data_byteen[3:0]</p><p>5.不是，如果只实现按字使能，就不得不先读取值再进行更改，这样数据通路就延长了，导致效率下降。</p><p>6.对于选择信号以及条件尽可能实现宏定义来实现，避免出现6‘b100000这种无缘无故的常数，方便查找bug</p><p>7.连续的乘除有关的那八条指令，同3进行阻塞或者转发实现，测试数据</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t1</span> $<span class="hljs-built_in">t1</span> <span class="hljs-number">0x1234</span><br><span class="hljs-keyword">mult </span>$<span class="hljs-built_in">t0</span> $<span class="hljs-built_in">t1</span><br><span class="hljs-keyword">mfhi </span>$<span class="hljs-built_in">s0</span><br></code></pre></td></tr></table></figure><p>8.多增加连续的乘除有关的那八条指令，其余同P5构造</p><p><strong>{</strong>temp_hi<strong>,</strong> temp_lo<strong>}</strong> <strong>&lt;=</strong> <strong>{</strong>hi<strong>,</strong> lo<strong>}</strong> <strong>+</strong> $signed<strong>(</strong>$signed<strong>(64’d0</strong>) <strong>+</strong> $signed<strong>(</strong>rs<strong>)</strong> <strong>*</strong> $signed<strong>(</strong>rt<strong>));</strong></p>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成CO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FirstTest</title>
    <link href="/2023/12/15/FirstTest/"/>
    <url>/2023/12/15/FirstTest/</url>
    
    <content type="html"><![CDATA[<hr><p>这是我的第一篇博客，用于记录自己的学习过程。</p><p>下面是我创建过程中的一些tips</p><h6 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo n -p post <span class="hljs-built_in">dir</span>/post1<br></code></pre></td></tr></table></figure><p>通过这个指令会在<code>source/_post/dir</code>目录下创建<code>post1.md</code></p><h6 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h6><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure><p>这个指令启动本地服务器</p><h6 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h6><ul><li><p>删除已有静态文件：<code>hexo clean</code>（为了避免可能的错误）</p></li><li><p>重新生成静态文件：<code>hexo g</code></p></li><li><p>重新部署：<code>hexo d</code>，稍等一段时间后刷新网页，发现主题生效</p><p></p><p align="right">By Fantasylee</p><p></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Test</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
