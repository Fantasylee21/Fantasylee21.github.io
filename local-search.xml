<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>BUAA_OO_Unit1</title>
    <link href="/2024/03/01/BUAA-OO-Unit1/"/>
    <url>/2024/03/01/BUAA-OO-Unit1/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="BUAA-OO-Unit1总结"><a href="#BUAA-OO-Unit1总结" class="headerlink" title="BUAA_OO_Unit1总结"></a>BUAA_OO_Unit1总结</h1><h2 id="一、第一次作业hw1"><a href="#一、第一次作业hw1" class="headerlink" title="一、第一次作业hw1"></a>一、第一次作业hw1</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>耗时数天完成了代码书写及代码调试，感悟良多，归功于Training中的内容，我在本次作业中也选择了对应的递归下降的思路构造语法树，同时在根据语法树利用逆向思路将解析完的表达式转化为多项式形式，最后多项式存入TreeMap中按要求降序输出结果</p><h3 id="1-代码UML框架"><a href="#1-代码UML框架" class="headerlink" title="1.代码UML框架"></a>1.代码UML框架</h3><p><img src="uml.png" alt="UML框架"></p><h3 id="2-代码架构分析"><a href="#2-代码架构分析" class="headerlink" title="2.代码架构分析"></a>2.代码架构分析</h3><h4 id="2-1-预处理"><a href="#2-1-预处理" class="headerlink" title="2.1 预处理"></a>2.1 预处理</h4><p><img src="image-20240301204258960.png" alt="形式化表述"></p><p>根据表达式的形式化表达我们可以得到以下结论：</p><ol><li>表达式中最多三个连续的<code>+</code>或者<code>-</code></li><li>常数因子可以有前导0</li><li>指数符号后只可能是<code>token.ADD</code>或者<code>token.NUM</code></li><li>表达式中可能存在大量 <code>space</code>和<code>\t</code></li><li>表达式或<code>(</code>后可能存在符号</li></ol><p>于是为了简化后续操作我选择进行的以下操作</p><ol><li>若读到<code>+</code>且前面存在其他符号或位于开头则去掉加号</li><li>若读到<code>-</code>且前面存在<code>(</code>或者位于开头则在前面加上0，若减号连续则将其换为一个<code>+</code></li><li>去掉所有空格</li></ol><h4 id="2-2-词法分析与解析部分"><a href="#2-2-词法分析与解析部分" class="headerlink" title="2.2 词法分析与解析部分"></a>2.2 词法分析与解析部分</h4><h5 id="2-2-1-Lexer部分"><a href="#2-2-1-Lexer部分" class="headerlink" title="2.2.1 Lexer部分"></a>2.2.1 Lexer部分</h5><ol><li>在读取到<code>token.NUM</code>时去除前缀0（但是谨记保证数不会被全部去掉）</li><li>在读取到未知符号时我们选择抛出异常（强烈建议此方法，后续可以快速定位bug）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Invalid token&quot;</span>);<br></code></pre></td></tr></table></figure><h5 id="2-2-2-Parse"><a href="#2-2-2-Parse" class="headerlink" title="2.2.2 Parse"></a>2.2.2 Parse</h5><p>该部分是代码词法解析的核心部分</p><ol><li><p>我完成了<code>parseExpr()、parseTerm()、parseFactor()</code>的书写并采用递归下降的方法调用</p></li><li><p>由于预处理我们可以只对Term加上正负属性并且在这里完成项的正负号的确定</p></li><li><p>在解析项时去掉指数符号，将其全部转化为因子形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">Factor</span> <span class="hljs-variable">factor</span> <span class="hljs-operator">=</span> parseFactor();<br>        <span class="hljs-keyword">if</span> (factor.getExponent() == <span class="hljs-number">0</span>) &#123;<br>            term.addFactor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NumFactor</span>(BigInteger.ONE));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; factor.getExponent(); i++) &#123;<br>            term.addFactor(factor);<br>        &#125;<br></code></pre></td></tr></table></figure></li></ol><ol><li><p>同上在解析未知符号是我们选择抛出异常便于debug</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Invalid token&quot;</span>);<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-3-根据解析结果转化为多项式"><a href="#2-3-根据解析结果转化为多项式" class="headerlink" title="2.3 根据解析结果转化为多项式"></a>2.3 根据解析结果转化为多项式</h4><p>该部分核心思路还是递归思路</p><p>Expr -&gt; Term -&gt; Factor</p><p>然后多项式中存入<code>TreeMap&lt;Integer,BigInteger&gt; polynomial</code></p><p>最后，我们要得到形如：$Expr =  \sum\limits_ { i = 0 } a_i * x ^ { b_i }$</p><p>好处：保证有序性和便于得到$a_i$和$b_i$，在此基础上得到一个字符串即可</p><h3 id="3-测试思路"><a href="#3-测试思路" class="headerlink" title="3.测试思路"></a>3.测试思路</h3><h4 id="3-1-自动化测试"><a href="#3-1-自动化测试" class="headerlink" title="3.1.自动化测试"></a>3.1.自动化测试</h4><h5 id="3-11-数据生成"><a href="#3-11-数据生成" class="headerlink" title="3.11 数据生成"></a>3.11 数据生成</h5><p>思路还是和解答程序程序相似,按照generate_factor  —&gt; generate_term —&gt; generate_expr —&gt;generate_testcase</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_factor</span>(<span class="hljs-params">floor</span>):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_term</span>(<span class="hljs-params">floor</span>):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_expr</span>(<span class="hljs-params">floor</span>):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_testcase</span>(<span class="hljs-params">Limit,floor</span>):<br></code></pre></td></tr></table></figure><p>最后随机在生成式之间添加空格</p><h5 id="3-12-测试比对"><a href="#3-12-测试比对" class="headerlink" title="3.12 测试比对"></a>3.12 测试比对</h5><p>依赖于sympy自带的化简功能实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">execute_java</span> (stdin, <span class="hljs-built_in">str</span>):<br>    cmd = [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-built_in">str</span> + <span class="hljs-string">&quot;.jar&quot;</span>]  <span class="hljs-comment"># 更改为自己的.jar包名</span><br>    proc = subprocess.Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=STDOUT)<br>    stdout, stderr = proc.communicate(stdin.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>    <span class="hljs-keyword">return</span> stdout.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>).strip()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">isEqual</span>(<span class="hljs-params">javaInput,javaOutput</span>):<br>    javaInput = sp.simplify(javaInput)<br>    javaOutput = sp.simplify(javaOutput)<br>    <span class="hljs-keyword">return</span> javaInput.equals(javaOutput)<br></code></pre></td></tr></table></figure><h2 id="二、第二次作业hw2"><a href="#二、第二次作业hw2" class="headerlink" title="二、第二次作业hw2"></a>二、第二次作业hw2</h2><h4 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h4><ol><li>关于使用替换进行函数展开，要注意不要引入新的形参。例如f(y, x)=y+x，展开f(x, x^2)时，若不加任何修改直接用x替换形参y，f就会变为x+x， 再直接用x^2替换所有形参x，就会变为x^2+x^2的错误结果。因此，可以先将所有形参变为其他形式， 如f(v,u) = v+u，再替换形参v和u就不会发生上述错误。表达式解析</li><li>深拷贝与浅拷贝学习</li></ol>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BUAA_OO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA_CO_P7设计文稿</title>
    <link href="/2024/01/01/BUAA-CO-P7%E8%AE%BE%E8%AE%A1%E6%96%87%E7%A8%BF/"/>
    <url>/2024/01/01/BUAA-CO-P7%E8%AE%BE%E8%AE%A1%E6%96%87%E7%A8%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="P7CPU设计文稿"><a href="#P7CPU设计文稿" class="headerlink" title="P7CPU设计文稿"></a>P7CPU设计文稿</h1><h2 id="1-总体架构"><a href="#1-总体架构" class="headerlink" title="1.总体架构"></a>1.总体架构</h2><p><img src="Structure.png" alt="Structure.png"></p><p><strong>任务清单</strong></p><p>新增指令：<strong>mfc0,</strong> <strong>mtc0,</strong> <strong>eret,</strong> <strong>syscall</strong></p><p>P7 与之前的 project 相比，涉及的内容较多，所以在实现的时候很容易手忙脚乱，这里列出完成 P7 需要的事宜：</p><div class="table-container"><table><thead><tr><th style="text-align:left">任务</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">计时器</td><td style="text-align:left">课程组提供实现代码，只需要结合代码和文档理解应用即可。</td></tr><tr><td style="text-align:left">系统桥</td><td style="text-align:left">为 CPU 提供统一的访问外设的接口，需要按规格自行实现。</td></tr><tr><td style="text-align:left">协处理器 CP0</td><td style="text-align:left">设置 CPU 的异常处理功能，反馈 CPU 的异常信息，需要按规格自行实现。</td></tr><tr><td style="text-align:left">内部异常检测与流水</td><td style="text-align:left">CPU 需要具有可以检测内部指令执行错误的能力。</td></tr><tr><td style="text-align:left">外部中断响应</td><td style="text-align:left">CPU 需要具有初步响应外部中断信号的能力。</td></tr><tr><td style="text-align:left">异常处理指令</td><td style="text-align:left">在异常处理程序中，会有一些特殊的指令需要实现。</td></tr><tr><td style="text-align:left">单周期 CPU 的封装</td><td style="text-align:left">让 CPU 从外部看上去是一个单周期 CPU。</td></tr><tr><td style="text-align:left">异常处理程序</td><td style="text-align:left">利用 MARS 编写简单的异常处理程序用于测试。</td></tr></tbody></table></div><p><img src="p6cpu.jpg" alt="p6cpu"></p><h2 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2.具体实现"></a>2.具体实现</h2><h3 id="1-CP0"><a href="#1-CP0" class="headerlink" title="1.CP0"></a>1.CP0</h3><p>将CP0置于M级，故宏观PC为M级对于PC</p><p> CP0 的端口声明如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">端口</th><th style="text-align:left">方向</th><th style="text-align:left">位数</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">clk</td><td style="text-align:left">I</td><td style="text-align:left">1</td><td style="text-align:left">时钟信号。</td></tr><tr><td style="text-align:left">reset</td><td style="text-align:left">I</td><td style="text-align:left">1</td><td style="text-align:left">复位信号。</td></tr><tr><td style="text-align:left">en</td><td style="text-align:left">I</td><td style="text-align:left">1</td><td style="text-align:left">写使能信号。</td></tr><tr><td style="text-align:left">CP0Addr</td><td style="text-align:left">I</td><td style="text-align:left">5</td><td style="text-align:left">寄存器地址。</td></tr><tr><td style="text-align:left">CP0In</td><td style="text-align:left">I</td><td style="text-align:left">32</td><td style="text-align:left">CP0 写入数据。</td></tr><tr><td style="text-align:left">CP0Out</td><td style="text-align:left">O</td><td style="text-align:left">32</td><td style="text-align:left">CP0 读出数据。</td></tr><tr><td style="text-align:left">VPC</td><td style="text-align:left">I</td><td style="text-align:left">32</td><td style="text-align:left">受害 PC。</td></tr><tr><td style="text-align:left">BDIn</td><td style="text-align:left">I</td><td style="text-align:left">1</td><td style="text-align:left">是否是延迟槽指令。</td></tr><tr><td style="text-align:left">ExcCodeIn</td><td style="text-align:left">I</td><td style="text-align:left">5</td><td style="text-align:left">记录异常类型。</td></tr><tr><td style="text-align:left">HWInt</td><td style="text-align:left">I</td><td style="text-align:left">6</td><td style="text-align:left">输入中断信号。</td></tr><tr><td style="text-align:left">EXLClr</td><td style="text-align:left">I</td><td style="text-align:left">1</td><td style="text-align:left">用来复位 EXL。</td></tr><tr><td style="text-align:left">EPCOut</td><td style="text-align:left">O</td><td style="text-align:left">32</td><td style="text-align:left">EPC 的值。</td></tr><tr><td style="text-align:left">Req</td><td style="text-align:left">O</td><td style="text-align:left">1</td><td style="text-align:left">进入处理程序请求。</td></tr></tbody></table></div><p>CP0位置确定</p><h3 id="2-约定"><a href="#2-约定" class="headerlink" title="2.约定"></a>2.约定</h3><ol><li>如果发生异常的指令是延迟槽指令，那么返回程序时仍然返回这条指令所属的跳转指令。也就是说“异常延迟槽回到跳转”。</li><li>如果发生异常的指令是跳转指令，那么我们要求执行完延迟槽。</li><li>如果发生异常的指令是乘除指令的下一条，乘除指令不被撤回。也就是对于 M错误指令，W乘除指令 的情况，此时乘除槽正在计算，本来在异常处理时可能会覆盖乘除槽的结果，但是我们约定不会这么做。但是注意，如果是 E乘除指令，M错误指令，你要保证乘除指令不执行。</li></ol><p><strong>范围约定</strong></p><p><img src="strict.png" alt="strict"></p><h3 id="3-中断异常"><a href="#3-中断异常" class="headerlink" title="3.中断异常"></a>3.中断异常</h3><p><strong>中断异常约束</strong></p><ul><li><p>异常入口：《SMRL》的表 5.1 中定义了 MIPS 的异常入口，但考虑到简化设计以及与 MARS 保持一致，我们只支持 0x4180 一个入口地址，所有异常与中断都将从这里进入。</p></li><li><p>嵌套中断异常：本实验不要求支持中断异常嵌套的情况。</p></li><li><p>优先级：中断优先级高于异常优先级，即当有异常提交至 CP0 寄存器时，若有中断发生，则硬件应先响应中断，并重新执行受害指令及其后续指令；若没有中断发生，则处理异常。</p></li><li><p>精确异常：</p><ul><li><p>除下面的情况外，对所有中断异常的处理都应遵循精确异常的处理规则。</p></li><li><p>在进入中断或异常状态时，如果受害指令及其后续指令</p><p>已经改变</p><p>了 MDU 的状态，则无需恢复。假设 CP0 在 M 级，MDU 在 E 级，考虑以下情况：</p><ul><li><code>mult</code> 在 E 级启动了乘法运算，流水到 M 级时产生了中断，此时无需停止乘法计算，其它乘除法指令同理。</li><li><code>mthi</code> 在 E 级修改了 HI 寄存器，流水到 M 级时产生了中断，此时无需恢复 HI 寄存器的值，<code>mtlo</code> 同理。</li><li><code>mult</code> 在 E 级，受害指令在 M 级，此时还未改变 MDU 状态，不应开始乘法计算，其它乘除法指令同理。</li><li><code>mthi</code> 在 E 级，受害指令在 M 级，此时还未改变 MDU 状态，不应修改 HI 寄存器的值，<code>mtlo</code> 同理。</li></ul></li></ul></li><li><p>中断规范：</p><ul><li>Timer0 输出的中断信号接入 HWInt[0] (最低中断位)，Timer1 输出的中断信号接入 HWInt[1]，来自中断发生器的中断信号接入 HWInt[2]。</li><li>规定中断产生时的受害指令为宏观 PC 对应的指令，此时应将宏观 PC 写入 EPC。</li></ul></li><li><p>MIPS 微系统需要支持的异常：</p><p>| ExcCode | 助记符  | 描述                                             |<br>| :——— | :——— | :———————————————————————- |<br>| 0       | Int     | 中断。                                           |<br>| 4       | AdEL    | 取数或取指时地址错误。                           |<br>| 5       | AdES    | 存数时地址错误。                                 |<br>| 8       | Syscall | 系统调用。                                       |<br>| 10      | RI      | 不认识的（或者非法的）指令码。                   |<br>| 12      | Ov      | 自陷形式的整数算术指令（例如 <code>add</code>）导致的溢出。 |</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">异常与中断码</th><th style="text-align:left">助记符与名称</th><th style="text-align:left">指令与指令类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left"><code>Int</code> （外部中断）</td><td style="text-align:left">所有指令</td><td style="text-align:left">中断请求，来源于计时器与外部中断。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><code>AdEL</code> （取指异常）</td><td style="text-align:left">所有指令</td><td style="text-align:left">PC 地址未字对齐。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">PC 地址超过 <code>0x3000 ~ 0x6ffc</code>。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>AdEL</code> （取数异常）</td><td style="text-align:left"><code>lw</code></td><td style="text-align:left">取数地址未与 4 字节对齐。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"><code>lh</code></td><td style="text-align:left">取数地址未与 2 字节对齐。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"><code>lh</code>, <code>lb</code></td><td style="text-align:left">取 Timer 寄存器的值。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">load 型指令</td><td style="text-align:left">计算地址时加法溢出。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">load 型指令</td><td style="text-align:left">取数地址超出 DM、Timer0、Timer1、中断发生器的范围。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><code>AdES</code> （存数异常）</td><td style="text-align:left"><code>sw</code></td><td style="text-align:left">存数地址未 4 字节对齐。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"><code>sh</code></td><td style="text-align:left">存数地址未 2 字节对齐。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"><code>sh</code>, <code>sb</code></td><td style="text-align:left">存 Timer 寄存器的值。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">store 型指令</td><td style="text-align:left">计算地址加法溢出。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">store 型指令</td><td style="text-align:left">向计时器的 Count 寄存器存值。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">store 型指令</td><td style="text-align:left">存数地址超出 DM、Timer0、Timer1、中断发生器的范围。</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><code>Syscall</code> （系统调用）</td><td style="text-align:left"><code>syscall</code></td><td style="text-align:left">系统调用。</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><code>RI</code>（未知指令）</td><td style="text-align:left"></td><td style="text-align:left">未知的指令码。</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><code>Ov</code>（溢出异常）</td><td style="text-align:left"><code>add</code>, <code>addi</code>, <code>sub</code></td><td style="text-align:left">算术溢出。</td></tr></tbody></table></div><h3 id="4-eret指令"><a href="#4-eret指令" class="headerlink" title="4.eret指令"></a>4.eret指令</h3><p>eret 将保存在 CP0 的 EPC 寄存器中的现场(被中断指令的下一条地址)写入 PC，从而实现从中断、 异常或指令执行错误的处理程序中返回</p><h2 id="3-思考题"><a href="#3-思考题" class="headerlink" title="3.思考题"></a>3.思考题</h2><h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h3><p>1、请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？</p><p>2、请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）</p><p>3、为何与外设通信需要 Bridge？</p><p>4、请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。</p><p>5、倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？</p><p>6、为什么 <code>jalr</code> 指令为什么不能写成 <code>jalr $31, $31</code>？</p><h3 id="2-答案"><a href="#2-答案" class="headerlink" title="2.答案"></a>2.答案</h3><ol><li><p>鼠标和键盘的输入信号是通过它们的接口（例如 USB）发送给计算机的主板。主板上的输入/输出控制器会将这些信号转换成数字信号，然后发送给中央处理器（CPU）。CPU会解析这些信号并根据用户的操作来执行相应的指令。IO设备的输入输出有好几种方式，键盘、鼠标这类的低速设备是通过中断请求的方式进行IO操作的。即当键盘上按下一个按键的时候，键盘会发出一个中断信号，中断信号经过中断控制器传到CPU，然后CPU根据不同的中断号执行不同的中断响应程序，然后进行相应的IO操作，把按下的按键编码读到寄存器（或者鼠标的操作），最后放入内存中。</p></li><li><p>保证设计的统一性，即通过协议保证接口更加兼容。用户使用自定义处理可能出现不兼容的问题</p></li><li><p>正如教程所说，系统桥是连接 CPU 和外设的功能设备，它会给 CPU 提供一种接口，使得 CPU 可以像读写普通存储器一样（即按地址读写）来读写复杂多变的外设，不用管数据是从哪来，怎么来，只用发挥CPU本身功能就可以。系统桥统一且简化了 CPU 的对外接口，CPU 不必为每种外设单独提供接口，符合高内聚，低耦合的设计思想。</p></li><li><p>模式0通常用于产生定时中断  ,当计数器倒计数为 0 后，计数器停止计数，Ctrl 寄存器的计数使能自动变为 0，并且中断信号始终保持有效，直到屏蔽中断或重新开始计数。</p><p><img src="mode0.jpg" alt="mode0"></p><p>模式1当计数器倒计数为 0 后， 初值寄存器值被自动加载至计数器， 计数器继续倒计数。模式 1 通常用于产生周期性脉冲</p><p><img src="mode1.jpg" alt="mode1"></p></li><li><p>会导致宏观PC突然为0或者为x。在清空流水线的时候，应该保留PC信息。</p></li><li><p>PC &lt;- GPR[rs]和GPR[rd] &lt;- PC + 4的进行顺序未知，存在二义</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成CO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA_CO_P5和P6CPU设计文稿</title>
    <link href="/2024/01/01/BUAA-CO-P5%E5%92%8CP6CPU%E8%AE%BE%E8%AE%A1%E6%96%87%E7%A8%BF/"/>
    <url>/2024/01/01/BUAA-CO-P5%E5%92%8CP6CPU%E8%AE%BE%E8%AE%A1%E6%96%87%E7%A8%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="P5——CPU设计文稿"><a href="#P5——CPU设计文稿" class="headerlink" title="P5——CPU设计文稿"></a>P5——CPU设计文稿</h1><h2 id="1-总示意图"><a href="#1-总示意图" class="headerlink" title="1.总示意图"></a>1.总示意图</h2><p><img src="p5cpu.jpg" alt="&quot;p5cpu.jpg&quot;"></p><h2 id="2-命名规范"><a href="#2-命名规范" class="headerlink" title="2.命名规范"></a>2.命名规范</h2><p>1.模块以及接口加上各级前缀</p><p>2.属于某模块在级后面在加模块名</p><h2 id="3-模块定义"><a href="#3-模块定义" class="headerlink" title="3.模块定义"></a>3.模块定义</h2><h3 id="1）Datapath"><a href="#1）Datapath" class="headerlink" title="1）Datapath"></a>1）Datapath</h3><h4 id="1、E-ALU模块"><a href="#1、E-ALU模块" class="headerlink" title="1、E_ALU模块"></a>1、E_ALU模块</h4><p>同指导书，改为case来操作</p><div class="table-container"><table><thead><tr><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">E_ALU_A [31 : 0]</td><td style="text-align:center">I</td><td style="text-align:left">32位输入信号</td></tr><tr><td style="text-align:center">E_ALU_B [31 : 0]</td><td style="text-align:center">I</td><td style="text-align:left">32位输入信号</td></tr><tr><td style="text-align:center">E_ALU_Shamt [4 : 0]</td><td style="text-align:center">I</td><td style="text-align:left">五位输入信号</td></tr><tr><td style="text-align:center">E_ALUop [2 : 0]</td><td style="text-align:center">I</td><td style="text-align:left">操作选择控制    <br>E_ALUop == 3’b000 A +B；<br>E_ALUop == 3’b001 A - B;<br>E_ALUop == 3’b010 A \</td><td>B; <br>E_ALUop == 3’b011 A &amp; B;<br>E_ALUop == 3’b100 B左移Shamt位<br>E_ALUop == 3’b101 B加载到高位</td></tr><tr><td style="text-align:center">E_ALU_Result [31 : 0]</td><td style="text-align:center">O</td><td style="text-align:left">32位输出信号</td></tr></tbody></table></div><h4 id="2、D-CMP模块"><a href="#2、D-CMP模块" class="headerlink" title="2、D_CMP模块"></a>2、D_CMP模块</h4><p>从原来的ALU模块分离出来到译码阶段</p><div class="table-container"><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>D_CMP_A [31: 0]</td><td>I</td><td>32位输入</td></tr><tr><td>D_CMP_B [31: 0]</td><td>I</td><td>32位输入</td></tr><tr><td>D_CMP_Equal</td><td>O</td><td>相等 ？ 1  ：0</td></tr><tr><td>D_CMP_Less</td><td>O</td><td>小于 ？ 1  ：0</td></tr><tr><td>D_CMP_Greater</td><td>O</td><td>大于 ？ 1 ： 0</td></tr></tbody></table></div><h4 id="3、E-EXT模块"><a href="#3、E-EXT模块" class="headerlink" title="3、E_EXT模块"></a>3、E_EXT模块</h4><div class="table-container"><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>D_EXT_Imm [15: 0 ]</td><td>I</td><td>16位待扩展立即数</td></tr><tr><td>D_EXTop [1:0]</td><td>I</td><td>扩展选择<br>D_EXTop == 2’b00 符号扩展<br>D_EXTop == 2’b01 无符号扩展</td></tr><tr><td>D_EXT_Result [31:0]</td><td>O</td><td>扩展结果</td></tr></tbody></table></div><h4 id="4、F-PC模块"><a href="#4、F-PC模块" class="headerlink" title="4、F_PC模块"></a>4、F_PC模块</h4><div class="table-container"><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>F_PC_clk</td><td>I</td><td>时钟信号</td></tr><tr><td>F_PC_reset</td><td>I</td><td>复位信号</td></tr><tr><td>F_PC_en</td><td>I</td><td>使能信号</td></tr><tr><td>F_PC_ NPC [31:0]</td><td>I</td><td>32位输入信号</td></tr><tr><td>F_PC_PC [31:0]</td><td>O</td><td>输出信号</td></tr></tbody></table></div><h4 id="5、F-IM模块"><a href="#5、F-IM模块" class="headerlink" title="5、F_IM模块"></a>5、F_IM模块</h4><div class="table-container"><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>F_IM_PC [31:0]</td><td>I</td><td>32位取址信号</td></tr><tr><td>F_IM_Instr [31 :0]</td><td>O</td><td>32位结果</td></tr></tbody></table></div><h4 id="6、D-NPC模块"><a href="#6、D-NPC模块" class="headerlink" title="6、D_NPC模块"></a>6、D_NPC模块</h4><div class="table-container"><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>D_NPC_PC[31:0]</td><td>I</td><td>32位PC信号</td></tr><tr><td>D_NPC_Imm[26:0]</td><td>I</td><td>26位立即数地址</td></tr><tr><td>D_NPC_RA[31:0]</td><td>I</td><td>$RA</td></tr><tr><td>D_NPC_Branch[2 :0]</td><td>I</td><td>对应不同Branch<br>3’b000表示不是Branch<br>若为3’b001对应beq</td></tr><tr><td>D_NPC_J</td><td>I</td><td>对应J跳转指令</td></tr><tr><td>D_NPC_JR</td><td>I</td><td>对应Jr跳转指令</td></tr><tr><td>D_NPC_Equal</td><td>I</td><td>比较结果</td></tr><tr><td>D_NPC_Great</td><td>I</td><td>比较结果</td></tr><tr><td>D_NPC_Less</td><td>I</td><td>比较结果</td></tr><tr><td>D_NPC_NPC[31:0]</td><td>O</td><td></td></tr><tr><td>D_Jump</td><td>O</td><td>判断地址是否跳转</td></tr></tbody></table></div><h4 id="7、D-GRF模块"><a href="#7、D-GRF模块" class="headerlink" title="7、D_GRF模块"></a>7、D_GRF模块</h4><div class="table-container"><table><thead><tr><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">D_GRF_A1 [4:0]</td><td style="text-align:center">I</td><td style="text-align:left">5位地址输入信号，输入rs指定的寄存器并将其结果读出到RD1</td></tr><tr><td style="text-align:center">D_GRF_A2 [4:0]</td><td style="text-align:center">I</td><td style="text-align:left">5位地址输入信号，输入rt指定的寄存器并将其结果读出到RD2</td></tr><tr><td style="text-align:center">D_GRF_A3 [4:0]</td><td style="text-align:center">I</td><td style="text-align:left">5位地址输入信号，输入rd指定的寄存器并将WD写入</td></tr><tr><td style="text-align:center">D_GRF_WD [31:0]</td><td style="text-align:center">I</td><td style="text-align:left">32位输入信号</td></tr><tr><td style="text-align:center">D_GRF_clk</td><td style="text-align:center">I</td><td style="text-align:left">时钟信号</td></tr><tr><td style="text-align:center">D_GRF_reset</td><td style="text-align:center">I</td><td style="text-align:left">异步复位信号</td></tr><tr><td style="text-align:center">D_GRF_WE</td><td style="text-align:center">I</td><td style="text-align:left">使能信号</td></tr><tr><td style="text-align:center">D_GRF_RD1 [31:0]</td><td style="text-align:center">O</td><td style="text-align:left">输出A1指定寄存器的32位数据</td></tr><tr><td style="text-align:center">D_GRF_RD2 [31:0]</td><td style="text-align:center">O</td><td style="text-align:left">输出A2指定寄存器的32位数据</td></tr></tbody></table></div><h4 id="8、M-DM模块"><a href="#8、M-DM模块" class="headerlink" title="8、M_DM模块"></a>8、M_DM模块</h4><div class="table-container"><table><thead><tr><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">M_DM_clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">M_DM_reset</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">M_Mem_Write</td><td style="text-align:center">I</td><td style="text-align:center">写信号</td></tr><tr><td style="text-align:center">M_signed</td><td style="text-align:center">I</td><td style="text-align:center">输出是否符号位扩展信号</td></tr><tr><td style="text-align:center">Size</td><td style="text-align:center">I</td><td style="text-align:center">决定是字、半字、字节</td></tr><tr><td style="text-align:center">M_ALU_Result[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">储存地址</td></tr><tr><td style="text-align:center">M_WriteData[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">储存数据</td></tr><tr><td style="text-align:center">M_PC[31:0]]</td><td style="text-align:center">I</td><td style="text-align:center">PC</td></tr><tr><td style="text-align:center">M_Read_Data</td><td style="text-align:center">O</td><td style="text-align:center">load结果</td></tr></tbody></table></div><h4 id="9、Controller"><a href="#9、Controller" class="headerlink" title="9、Controller"></a>9、Controller</h4><p>根据名称要求更改，采取重构</p><div class="table-container"><table><thead><tr><th style="text-align:center">信号名</th><th style="text-align:center">方向</th></tr></thead><tbody><tr><td style="text-align:center">opcode[5:0]</td><td style="text-align:center">I</td></tr><tr><td style="text-align:center">funct[5:0]</td><td style="text-align:center">I</td></tr><tr><td style="text-align:center">D_EXTop [1:0]</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">D_NPC_Branch [2:0]</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">D_NPC_J</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">D_NPC_JR</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">E_Reg_Dst [1:0]</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">E_ALU_Src [1:0]</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">E_ALUop [2:0]</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">M_Mem_Write</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">M_DM_Size[1:0]</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">M_Signed</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">W_MemtoReg [1:0]</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">W_RegWrite</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">D_Rs_Tuse</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">D_Rt_Tuse</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">D_Tnew</td><td style="text-align:center">O</td></tr></tbody></table></div><p>其真值表对应如下，同时改为case结构，代码长度显著增加，但便于debug</p><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th>D_EXTop[1:0]</th><th>D_NPC_Branch[2:0]</th><th>D_NPC_J</th><th>D_NPC_JR</th><th>D_Reg_Dst[1:0]</th><th>E_ALU_Src[1:0]</th><th>E_ALUop[2:0]</th><th>M_Mem_Write</th><th>M_DM_Size[1:0]</th><th>M_signed</th><th>W_MemtoReg[1:0]</th><th>W_RegWrite</th></tr></thead><tbody><tr><td style="text-align:center">Add</td><td>00</td><td>000</td><td>0</td><td>0</td><td>01</td><td>00</td><td>000</td><td>0</td><td>00</td><td>0</td><td>01</td><td>1</td></tr><tr><td style="text-align:center">Sub</td><td>00</td><td>000</td><td>0</td><td>0</td><td>01</td><td>00</td><td>001</td><td>0</td><td>00</td><td>0</td><td>01</td><td>1</td></tr><tr><td style="text-align:center">Jr</td><td>00</td><td>000</td><td>0</td><td>1</td><td>00</td><td>00</td><td>000</td><td>0</td><td>00</td><td>0</td><td>00</td><td>0</td></tr><tr><td style="text-align:center">Ori</td><td>01</td><td>000</td><td>0</td><td>0</td><td>00</td><td>01</td><td>010</td><td>0</td><td>00</td><td>0</td><td>01</td><td>1</td></tr><tr><td style="text-align:center">Lw</td><td>00</td><td>000</td><td>0</td><td>0</td><td>00</td><td>01</td><td>000</td><td>0</td><td>00</td><td>0</td><td>00</td><td>1</td></tr><tr><td style="text-align:center">Sw</td><td>00</td><td>000</td><td>0</td><td>0</td><td>00</td><td>01</td><td>000</td><td>1</td><td>00</td><td>0</td><td>00</td><td>0</td></tr><tr><td style="text-align:center">Beq</td><td>00</td><td>001</td><td>0</td><td>0</td><td>00</td><td>00</td><td>000</td><td>0</td><td>00</td><td>0</td><td>00</td><td>0</td></tr><tr><td style="text-align:center">Lui</td><td>00</td><td>000</td><td>0</td><td>0</td><td>00</td><td>01</td><td>101</td><td>0</td><td>00</td><td>0</td><td>01</td><td>1</td></tr><tr><td style="text-align:center">J</td><td>00</td><td>000</td><td>1</td><td>0</td><td>00</td><td>00</td><td>00</td><td>0</td><td>00</td><td>0</td><td>00</td><td>0</td></tr><tr><td style="text-align:center">Jal</td><td>00</td><td>000</td><td>1</td><td>0</td><td>10</td><td>01</td><td>000</td><td>0</td><td>00</td><td>0</td><td>10</td><td>1</td></tr></tbody></table></div><h3 id="2）RiskUnit-冒险处理"><a href="#2）RiskUnit-冒险处理" class="headerlink" title="2）RiskUnit 冒险处理"></a>2）RiskUnit 冒险处理</h3><p>D_Tuse与D_Tnew表格，每次走过一个寄存器，T_new都会减一</p><p>Tuse&lt;Tnew 暂停</p><p>对不需要使用寄存器的Tuse置最大值。</p><p>注意：不转发0</p><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">D_Rs_Tuse</th><th style="text-align:center">D_Rt_Tuse</th><th style="text-align:center">D_Tnew</th></tr></thead><tbody><tr><td style="text-align:center">Add</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Sub</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Jr</td><td style="text-align:center">0</td><td style="text-align:center">M</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Ori</td><td style="text-align:center">1</td><td style="text-align:center">M</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Lw</td><td style="text-align:center">1</td><td style="text-align:center">M</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">Sw</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Beq</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Lui</td><td style="text-align:center">M</td><td style="text-align:center">M</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">J</td><td style="text-align:center">M</td><td style="text-align:center">M</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Jal</td><td style="text-align:center">M</td><td style="text-align:center">M</td><td style="text-align:center">2</td></tr></tbody></table></div><h2 id="4-测试数据"><a href="#4-测试数据" class="headerlink" title="4.测试数据"></a>4.测试数据</h2><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-string">`0x0000000000000000:  34 1C 00 00    ori <span class="hljs-variable">$gp</span>, <span class="hljs-variable">$zero</span>, 0`</span> <br><br><span class="hljs-string">`0x0000000000000004:  34 1D 00 00    ori <span class="hljs-variable">$sp</span>, <span class="hljs-variable">$zero</span>, 0`</span> <br><br><span class="hljs-string">`0x0000000000000008:  34 01 10 10    ori <span class="hljs-variable">$at</span>, <span class="hljs-variable">$zero</span>, 0x1010`</span> <br><br><span class="hljs-string">`0x000000000000000c:  3C 02 87 23    lui <span class="hljs-variable">$v0</span>, 0x8723`</span> <br><br><span class="hljs-string">`0x0000000000000010:  34 03 78 56    ori <span class="hljs-variable">$v1</span>, <span class="hljs-variable">$zero</span>, 0x7856`</span> <br><br><span class="hljs-string">`0x0000000000000014:  3C 04 85 FF    lui <span class="hljs-variable">$a0</span>, 0x85ff`</span> <br><br><span class="hljs-string">`0x0000000000000018:  34 05 00 01    ori <span class="hljs-variable">$a1</span>, <span class="hljs-variable">$zero</span>, 1`</span> <br><br><span class="hljs-string">`0x000000000000001c:  3C 06 FF FF    lui <span class="hljs-variable">$a2</span>, 0xffff`</span> <br><br><span class="hljs-string">`0x0000000000000020:  34 07 FF FF    ori <span class="hljs-variable">$a3</span>, <span class="hljs-variable">$zero</span>, 0xffff`</span> <br><br><span class="hljs-string">`0x0000000000000024:  00 22 08 20    add <span class="hljs-variable">$at</span>, <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v0</span>`</span> <br><br><span class="hljs-string">`0x0000000000000028:  00 23 48 20    add <span class="hljs-variable">$t1</span>, <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v1</span>`</span> <br><br><span class="hljs-string">`0x000000000000002c:  00 22 40 22    sub <span class="hljs-variable">$t0</span>, <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v0</span>`</span> <br><br><span class="hljs-string">`0x0000000000000030:  00 E0 00 22    sub <span class="hljs-variable">$zero</span>, <span class="hljs-variable">$a3</span>, <span class="hljs-variable">$zero</span>`</span> <br><br><span class="hljs-string">`0x0000000000000034:  13 91 00 03    beq <span class="hljs-variable">$gp</span>, <span class="hljs-variable">$s1</span>, 0x44`</span> <br><br><span class="hljs-string">`0x0000000000000038:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x000000000000003c:  10 00 00 15    b   0x94`</span> <br><br><span class="hljs-string">`0x0000000000000040:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x0000000000000044:  10 22 00 13    beq <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v0</span>, 0x94`</span> <br><br><span class="hljs-string">`0x0000000000000048:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x000000000000004c:  34 02 00 0C    ori <span class="hljs-variable">$v0</span>, <span class="hljs-variable">$zero</span>, 0xc`</span> <br><br><span class="hljs-string">`0x0000000000000050:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x0000000000000054:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x0000000000000058:  00 00 00 00    nop`</span> <br><br><span class="hljs-string">`0x000000000000005c:  0C 00 0C 1B    jal 0x306c`</span> <br><br><span class="hljs-string">`0x0000000000000060:  AC 41 00 00    sw  <span class="hljs-variable">$at</span>, (<span class="hljs-variable">$v0</span>)`</span> <br><br><span class="hljs-string">`0x0000000000000064:  10 00 00 0B    b   0x94`</span> <br><br><span class="hljs-string">`0x0000000000000068:  00 22 08 20    add <span class="hljs-variable">$at</span>, <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v0</span>`</span> <br><br><span class="hljs-string">`0x000000000000006c:  00 22 08 20    add <span class="hljs-variable">$at</span>, <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v0</span>`</span> <br><br><span class="hljs-string">`0x0000000000000070:  00 22 08 20    add <span class="hljs-variable">$at</span>, <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v0</span>`</span><br><br> <span class="hljs-string">`0x0000000000000074:  00 22 08 20    add <span class="hljs-variable">$at</span>, <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v0</span>`</span> <br><br><span class="hljs-string">`0x0000000000000078:  AC 5F 00 00    sw  <span class="hljs-variable">$ra</span>, (<span class="hljs-variable">$v0</span>)`</span> <br><br><span class="hljs-string">`0x000000000000007c:  8C 41 00 00    lw  <span class="hljs-variable">$at</span>, (<span class="hljs-variable">$v0</span>)`</span> <br><br><span class="hljs-string">`0x0000000000000080:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x0000000000000084:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x0000000000000088:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x000000000000008c:  00 20 00 08    jr  <span class="hljs-variable">$at</span>`</span> <br><br><span class="hljs-string">`0x0000000000000090:  AC 5F 00 00    sw  <span class="hljs-variable">$ra</span>, (<span class="hljs-variable">$v0</span>)`</span> <br><br><span class="hljs-string">`0x0000000000000094:  10 00 FF FF    b   0x94`</span> <br><br><span class="hljs-string">`0x0000000000000098:  00 00 00 00    nop`</span> <br></code></pre></td></tr></table></figure><h2 id="5-思考题"><a href="#5-思考题" class="headerlink" title="5.思考题"></a>5.思考题</h2><p>1.在D级就直接就直接计算出是否需要跳转，若需要发生跳转，由于NPC是组合逻辑，下一条指令的地址直接传出到PC模块，这样只会多读跳转指令下一条的指令，即使将分支判断提到 D 级，发生跳转的时候，F 级指令依然是需要作废的。但是我们如果约定 F 级指令不作废呢？也就是说，不论判断结果如何，我们都将执行分支或跳转指令的下一条指令。这也就是所谓的“<strong>延迟槽</strong>”。那么指令执行的效率就提高了。</p><p>2.Jal需要将jal下一条指令的位置写入$ra寄存器，由于延迟槽的地址是PC+4，所以实际应该写回PC +8了。</p><p>3.流水线中的各个阶段需要在特定的时钟周期内完成其任务。如果数据来自功能部件，可能会增加流水线的复杂性，导致更难以保持稳定的时序。通过限制数据转发只能来自寄存器，可以简化流水线的设计，提高稳定性。</p><p>4.当前 GPR 被写入的值会即时反馈到读取端上。具体的说，当读寄存器时的地址与同周期写寄存器的地址相同时，我们将读取的内容改为写寄存器的内容，而不是该地址可以索引到的寄存器文件中的值。这也就对应着图中的两个四选一多路选择器。利用冲突单元生成选择信号即可</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">assign</span> D_ForwardA = <br>    (D_Rs == M_Write_Reg &amp;&amp; M_MemtoReg == <span class="hljs-number">2&#x27;b01</span> &amp;&amp; M_Reg_Write == <span class="hljs-number">1&#x27;b1</span> &amp;&amp; M_Write_Reg != <span class="hljs-number">5&#x27;b00000</span>) ? `M_Data_ALU :<br>    (D_Rs == M_Write_Reg &amp;&amp; M_MemtoReg == <span class="hljs-number">2&#x27;b10</span> &amp;&amp; M_Reg_Write == <span class="hljs-number">1&#x27;b1</span> &amp;&amp; M_Write_Reg != <span class="hljs-number">5&#x27;b00000</span>) ? `M_Data_PC8 :<br>    (D_Rs == W_Write_Reg &amp;&amp; W_Reg_Write == <span class="hljs-number">1&#x27;b1</span>  &amp;&amp; W_Write_Reg != <span class="hljs-number">5&#x27;b00000</span>) ? `W_Data :<br>                                                `D_Data ;<br></code></pre></td></tr></table></figure><p>5.需求者：D级：CMP，E级：ALU</p><p>​    提供者：M级：ALU_Result,PC8</p><p>​                    W级：因为已经被选择过，过Writeback_Data就已经可以满足需求</p><p>6.大致可将指令分为三类</p><p>​    1）计算指令，主要对ALU模块进行增加操作，如Add指令</p><p>​    2）跳转指令，可能需要调整ALU模块或者NPC，由于这里是流水线，ALU模块的输出不能直接和单周期一样课上直接连在NPC模块，可能需要考虑在增加D级就增加符合跳转的运算</p><p>​    3）访存指令，DM中已经支持字、半字、字节的存取，根据题意做ALU，NPC等对应的增添即可</p><p>7.采取分散式译码</p><p>译码结果较易观察，且不容易产生bug，不同指令之间完全分离，缺点就是代码冗长。</p><p>选做2，采取交叉式出现</p><h1 id="P6——CPU"><a href="#P6——CPU" class="headerlink" title="P6——CPU"></a>P6——CPU</h1><p>支持指令：<strong>add,</strong> <strong>sub,</strong> <strong>and,</strong> <strong>or,</strong> <strong>slt,</strong> <strong>sltu,</strong> <strong>lui</strong> <strong>addi,</strong> <strong>andi,</strong> <strong>ori</strong> <strong>lb,</strong> <strong>lh,</strong> <strong>lw,</strong> <strong>sb,</strong> <strong>sh,</strong> <strong>sw</strong> <strong>mult,</strong> <strong>multu,</strong> <strong>div,</strong> <strong>divu,</strong> <strong>mfhi,</strong> <strong>mflo,</strong> <strong>mthi,</strong> <strong>mtlo</strong> <strong>beq,</strong> <strong>bne,</strong> <strong>jal,</strong> <strong>jr</strong></p><h2 id="1-模块定义"><a href="#1-模块定义" class="headerlink" title="1.模块定义"></a>1.模块定义</h2><p>增加E_MUDI乘除模块与M_DE模块，删除看F_IM与M_DM模块</p><h4 id="1、M-BE"><a href="#1、M-BE" class="headerlink" title="1、M_BE"></a>1、M_BE</h4><div class="table-container"><table><thead><tr><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">M_BE_A[1:0]</td><td style="text-align:center">I</td><td style="text-align:left">最低两位的地址</td></tr><tr><td style="text-align:center">M_BE_Din[31:0]</td><td style="text-align:center">I</td><td style="text-align:left">输入的 32 位数据</td></tr><tr><td style="text-align:center">M_BE_Op[2:0]</td><td style="text-align:center">I</td><td style="text-align:left">数据扩展控制码 000：<br>无扩展 001：无符号字节数据扩展 <br>010：符号字节数据扩展 <br>011：无符号半字数据扩展 <br>100：符号半字数据扩展</td></tr><tr><td style="text-align:center">M_BE_Dout[31:0]</td><td style="text-align:center">O</td><td style="text-align:left">扩展后的 32 位数据</td></tr></tbody></table></div><h4 id="2、E-MUDI"><a href="#2、E-MUDI" class="headerlink" title="2、E_MUDI"></a>2、E_MUDI</h4><div class="table-container"><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>E_MUDI_clk</td><td>I</td><td>时钟信号</td></tr><tr><td>E_MUDI_reset</td><td>I</td><td>复位信号</td></tr><tr><td>E_MUDI_A [31:0]</td><td>I</td><td>运算数据A</td></tr><tr><td>E_MUDI_B [31:0]</td><td>I</td><td>运算数据B</td></tr><tr><td>E_MUDI_Start</td><td>I</td><td>开始计算信号</td></tr><tr><td>E_MUDI_op [2:0]</td><td>I</td><td>运算选择信号</td></tr><tr><td>E_HI_Write</td><td>I</td><td>高位写信号</td></tr><tr><td>E_LO_Write</td><td>I</td><td>地位写信号</td></tr><tr><td>E_HI [31:0]</td><td>O</td><td>高位寄存器输出结果</td></tr><tr><td>E_LO[31:0]</td><td>O</td><td>低位寄存器输出结果</td></tr><tr><td>E_MUDI_Busy</td><td>O</td><td>计算中信号</td></tr></tbody></table></div><h2 id="2-总示意图"><a href="#2-总示意图" class="headerlink" title="2.总示意图"></a>2.总示意图</h2><p><img src="p6cpu.jpg" alt="&quot;p6cpu.jpg&quot;"></p><h2 id="3-思考题"><a href="#3-思考题" class="headerlink" title="3.思考题"></a>3.思考题</h2><p>1.乘除法运算效率远低于ALU内的各个计算，需要耗费大量时间，放在一起会大大拖慢效率，独立的HI、LO也是为了高效率，因为只有乘除法会用到高位寄存器，低位寄存器，与其他不一致，分开便于控制。</p><p>2.真实的流水线 CPU 使用乘法和除法指令来实现乘除法运算。在执行乘法和除法指令时，CPU会将操作数加载到寄存器中，然后通过一系列的算术逻辑单元(ALU)来进行乘法或除法计算。这些计算通常会在多个时钟周期内完成，因为乘法和除法是比较复杂的运算。乘法：乘法可以通过一系列的加法和移位来实现。处理器中的乘法单元通常包括：部分积生成器（Partial Product Generator）：将两个乘数的每一位相乘，生成部分积。部分积累加器（Partial Product Accumulator）： 将所有部分积相加，得到最终的乘积。这个过程可能需要多个时钟周期，因此在流水线中可能会有多个阶段用于处理不同的部分。除法：除法通常比乘法更为复杂，可能涉及到迭代的过程。处理器中的除法单元通常包括：部分商生成器（Partial Quotient Generator）： 生成每一位的部分商。部分商累加器（Partial Quotient Accumulator）： 将所有部分商相加，得到最终的商。这个过程同样可能需要多个时钟周期，并且可能需要进行多轮迭代来得到最终的结果。</p><p>在流水线中，这些乘法和除法的阶段可能被划分为多个子阶段，以便在每个时钟周期内执行一些部分操作。流水线的设计需要考虑到数据相关性、控制信号的传递以及流水线暂停和刷新等问题，以确保正确且高效地执行指令。</p><p>3.当且仅当Busy且指令为乘除有关的那八条指令时阻塞</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">assign</span> MUDI_Stall = (E_MUDI_Busy == <span class="hljs-number">1&#x27;b1</span>  || E_MUDI_Start == <span class="hljs-number">1&#x27;b1</span>) &amp;&amp; (D_MD_MT_MF == <span class="hljs-number">1&#x27;b1</span>) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br></code></pre></td></tr></table></figure><p>4.清晰性：每个字节的写分开，互不干扰，统一性：各个字节的控制信号仍然来自m_data_byteen[3:0]</p><p>5.不是，如果只实现按字使能，就不得不先读取值再进行更改，这样数据通路就延长了，导致效率下降。</p><p>6.对于选择信号以及条件尽可能实现宏定义来实现，避免出现6‘b100000这种无缘无故的常数，方便查找bug</p><p>7.连续的乘除有关的那八条指令，同3进行阻塞或者转发实现，测试数据</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t1</span> $<span class="hljs-built_in">t1</span> <span class="hljs-number">0x1234</span><br><span class="hljs-keyword">mult </span>$<span class="hljs-built_in">t0</span> $<span class="hljs-built_in">t1</span><br><span class="hljs-keyword">mfhi </span>$<span class="hljs-built_in">s0</span><br></code></pre></td></tr></table></figure><p>8.多增加连续的乘除有关的那八条指令，其余同P5构造</p><p><strong>{</strong>temp_hi<strong>,</strong> temp_lo<strong>}</strong> <strong>&lt;=</strong> <strong>{</strong>hi<strong>,</strong> lo<strong>}</strong> <strong>+</strong> $signed<strong>(</strong>$signed<strong>(64’d0</strong>) <strong>+</strong> $signed<strong>(</strong>rs<strong>)</strong> <strong>*</strong> $signed<strong>(</strong>rt<strong>));</strong></p>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成CO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FirstTest</title>
    <link href="/2023/12/15/FirstTest/"/>
    <url>/2023/12/15/FirstTest/</url>
    
    <content type="html"><![CDATA[<hr><p>这是我的第一篇博客，用于记录自己的学习过程。</p><p>下面是我创建过程中的一些tips</p><h6 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo n -p post <span class="hljs-built_in">dir</span>/post1<br></code></pre></td></tr></table></figure><p>通过这个指令会在<code>source/_post/dir</code>目录下创建<code>post1.md</code></p><h6 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h6><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure><p>这个指令启动本地服务器</p><h6 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h6><ul><li><p>删除已有静态文件：<code>hexo clean</code>（为了避免可能的错误）</p></li><li><p>重新生成静态文件：<code>hexo g</code></p></li><li><p>重新部署：<code>hexo d</code>，稍等一段时间后刷新网页，发现主题生效</p><p></p><p align="right">By Fantasylee</p><p></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Test</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
