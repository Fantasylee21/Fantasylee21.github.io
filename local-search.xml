<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>OS_shell实现文档</title>
    <link href="/2024/06/13/OS-shell%E5%AE%9E%E7%8E%B0%E6%96%87%E6%A1%A3/"/>
    <url>/2024/06/13/OS-shell%E5%AE%9E%E7%8E%B0%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="BUAA-OS-Shell实现文档"><a href="#BUAA-OS-Shell实现文档" class="headerlink" title="BUAA_OS_Shell实现文档"></a>BUAA_OS_Shell实现文档</h1><p>本人代码完成顺序也是按照如下顺序进行</p><h4 id="实现不带-b-后缀指令"><a href="#实现不带-b-后缀指令" class="headerlink" title="实现不带 .b 后缀指令"></a>实现不带 <code>.b</code> 后缀指令</h4><p>这可以说是最简单的部分，只需要在spawn函数中添加特判即可，如果没找到文件，现在在后缀添加.b再次尝试是否可以。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(prog);<br><span class="hljs-keyword">if</span> ((fd = open(prog, O_RDONLY)) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (fd == -E_NOT_FOUND &amp;&amp; (len &lt; <span class="hljs-number">2</span> || prog[len - <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;b&#x27;</span> || prog[len - <span class="hljs-number">2</span>] != <span class="hljs-string">&#x27;.&#x27;</span>)) &#123;<br>        <span class="hljs-type">char</span> prog_bin[MAXPATHLEN];<br>        <span class="hljs-built_in">strcpy</span>(prog_bin, prog);<br>        prog_bin[len] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>        prog_bin[len + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;b&#x27;</span>;<br>        prog_bin[len + <span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        <span class="hljs-keyword">if</span>((fd = open(prog_bin , O_RDONLY)) &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> fd;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> fd;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实现一行多指令"><a href="#实现一行多指令" class="headerlink" title="实现一行多指令"></a>实现一行多指令</h4><p>使用 <code>;</code> 将多条指令隔开从而从左至右依顺序执行每条指令的功能.</p><p>fork出一个子进程，让子进程继续执行，父进程等待子进程执行结束后继续执行<code>；</code>右侧命令，不断递归达到目的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;;&#x27;</span>:<br>r = fork();<br><span class="hljs-keyword">if</span> (r) &#123;<br>wait(r);<br><span class="hljs-keyword">return</span> parsecmd(argv, rightpipe);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> argc;<br>&#125;<br><span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><h4 id="实现引号支持"><a href="#实现引号支持" class="headerlink" title="实现引号支持"></a>实现引号支持</h4><p>类似于OO第一单元，需要将引号内部的内容看作是一个token，针对_gettokken()中的代码，只需要做如下添加并更新p1,p2的位置即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (*s == <span class="hljs-string">&#x27;\&quot;&#x27;</span>) &#123;<br>*s = <span class="hljs-number">0</span>;<br>s++;<br>*p1 = s;<br><span class="hljs-keyword">while</span>(*s != <span class="hljs-number">0</span> &amp;&amp; *s != <span class="hljs-string">&#x27;\&quot;&#x27;</span>) &#123;<br>s++;<br>&#125;<br>*s = <span class="hljs-number">0</span>;<br>s++;<br>*p2 = s;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;w&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实现注释功能"><a href="#实现注释功能" class="headerlink" title="实现注释功能"></a>实现注释功能</h4><p>最简单的部分！！！</p><p>读到<code>#</code>意味着后面可以不读了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (*s == <span class="hljs-number">0</span> || *s == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实现更多指令"><a href="#实现更多指令" class="headerlink" title="实现更多指令"></a>实现更多指令</h4><p>首先类似于lab5-exam，在文件系统中增加create服务。并将fsipc_create（）和create添加到user/lib/lib.h中。并在/user/include/fsreq.h中的enum中增加<code>FSREQ_CREATE</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">void</span> <span class="hljs-title function_">serve_create</span><span class="hljs-params">(u_int envid, <span class="hljs-keyword">struct</span> Fsreq_create *rq)</span>; <span class="hljs-comment">// /fs/serv.c</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsipc_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path, <span class="hljs-type">int</span> f_type)</span>; <span class="hljs-comment">// /user/lib/fsipc.c</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path, <span class="hljs-type">int</span> f_type)</span>; <span class="hljs-comment">// /user/lib/file.c</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fsreq_create</span> &#123;</span><br><span class="hljs-type">char</span> req_path[MAXPATHLEN];<br><span class="hljs-type">int</span> f_type;<br>&#125;; <span class="hljs-comment">// /user/include/fsreq.h</span><br></code></pre></td></tr></table></figure><p>由于<code>mkdir</code>中需要判断对应path下的文件类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">file_get_type</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> File *f)</span>; <span class="hljs-comment">// /ls/serv.h</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> O_GETTYPE 0x0888 <span class="hljs-comment">// /user/include/lib.h </span></span><br></code></pre></td></tr></table></figure><p><code>file_get_type()</code>我的写法如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">file_get_type</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> File *f)</span> &#123;<br><span class="hljs-keyword">if</span> (f-&gt;f_type == FTYPE_REG) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-2237</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f-&gt;f_type = FTYPE_DIR)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1147</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>并且修改serve_open()使得在open时可以通过返回值判断文件类型增加如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (rq-&gt;req_omode &amp; O_GETTYPE) &#123;<br>    <span class="hljs-keyword">if</span> ((r = (file_get_type(f))) &lt; <span class="hljs-number">0</span>) &#123;<br>        ipc_send(envid, r, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>完成上述工作，我耗费了大量时间思考，接下来的工作就比较简单了</p><p><strong>touch.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;lib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;<br>    <span class="hljs-type">int</span> r;<br>    <span class="hljs-keyword">if</span> (!((r = open(argv[<span class="hljs-number">1</span>], O_RDONLY)) &lt; <span class="hljs-number">0</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((r = create(argv[<span class="hljs-number">1</span>], FTYPE_REG)) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;touch: cannot touch &#x27;%s&#x27;: No such file or directory\n&quot;</span>, argv[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>mkdir.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;lib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;<br>    <span class="hljs-type">int</span> r;<br>    <span class="hljs-comment">// printf(&quot;%s man! What can I say !!!&quot;, argv[1]);</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;-p&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!((r = open(argv[<span class="hljs-number">2</span>], O_RDONLY)) &lt; <span class="hljs-number">0</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((r = create(argv[<span class="hljs-number">2</span>], FTYPE_DIR)) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">char</span> *path = argv[<span class="hljs-number">2</span>];<br>            <span class="hljs-type">char</span> p[MAXPATHLEN];<br>            <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(path);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>                <span class="hljs-keyword">if</span> (path[i] == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>                    create(p, FTYPE_DIR);<br>                &#125;<br>                p[i] = path[i];<br>            &#125;<br>            create(p, FTYPE_DIR);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (!((r = open(argv[<span class="hljs-number">1</span>], O_RDONLY)) &lt; <span class="hljs-number">0</span>)) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;mkdir: cannot create directory &#x27;%s&#x27;: File exists\n&quot;</span>, argv[<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((r = create(argv[<span class="hljs-number">1</span>], FTYPE_DIR)) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;mkdir: cannot create directory &#x27;$s&#x27;: No such file or directory\n&quot;</span>, argv[<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>rm.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;lib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fd</span> *<span class="hljs-title">fd</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Filefd</span> *<span class="hljs-title">ffd</span>;</span><br>    <span class="hljs-type">int</span> r;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;-r&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((r = open(argv[<span class="hljs-number">2</span>], O_RDONLY)) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;rm: cannot remove &#x27;%s&#x27;: No such file or directory\n&quot;</span>, argv[<span class="hljs-number">2</span>]);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((r = remove(argv[<span class="hljs-number">2</span>])) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;-rf&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((r = open(argv[<span class="hljs-number">2</span>], O_RDONLY)) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((r = remove(argv[<span class="hljs-number">2</span>])) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> ((r = open(argv[<span class="hljs-number">1</span>], O_RDONLY)) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;rm: cannot remove &#x27;%s&#x27;: No such file or directory\n&quot;</span>, argv[<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        r = open(argv[<span class="hljs-number">1</span>], O_GETTYPE);<br>        <span class="hljs-keyword">if</span> (r == <span class="hljs-number">-1147</span>) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;rm: cannot remove &#x27;%s&#x27;: Is a directory\n&quot;</span>, argv[<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            remove(argv[<span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实现追加重定向"><a href="#实现追加重定向" class="headerlink" title="实现追加重定向"></a>实现追加重定向</h4><p>解决偏移量即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>:<br><span class="hljs-keyword">if</span> (gettoken(<span class="hljs-number">0</span>, &amp;t) != <span class="hljs-string">&#x27;w&#x27;</span>) &#123;<br>debugf(<span class="hljs-string">&quot;syntax error: &gt; not followed by word\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>) &#123;<br>fd=open(t, O_WRONLY | O_CREAT);<br><span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<br>debugf(<span class="hljs-string">&quot;failed to open &#x27;%s&#x27;\n&quot;</span>,t);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stat</span> <span class="hljs-title">st</span>;</span><br>stat(t, &amp;st);<br>seek(fd, st.st_size);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fd=open(t, O_WRONLY | O_CREAT | O_TRUNC);<br><span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<br>debugf(<span class="hljs-string">&quot;failed to open &#x27;%s&#x27;\n&quot;</span>,t);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>dup(fd,<span class="hljs-number">1</span>);<br>close(fd);<br><span class="hljs-comment">//user_panic(&quot;&gt; redirection not implemented&quot;);</span><br><br><span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p><strong>坑点：open时不只有只写操作！！！</strong></p><h4 id="实现反引号"><a href="#实现反引号" class="headerlink" title="实现反引号"></a>实现反引号</h4><p>我的总体处理类似于<code>;</code>处理，不过需要在gettoken时将一对`变成一个，但是这样并不适用于整个所有，个人认为更加有效的处理是将反引号内部运行的结果作为参数传给echo，而不是直接给echo传空值。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">case <span class="hljs-string">&#x27;`&#x27;</span>:<br>r = fork();<br><span class="hljs-keyword">if</span> (r) &#123;<br>wait(r);<br><span class="hljs-keyword">return</span> argc;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> parsecmd(argv, rightpipe);<br>&#125;<br><span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (*s == <span class="hljs-string">&#x27;`&#x27;</span>) &#123;<br><span class="hljs-type">char</span> *p = s;<br>p++;<br><span class="hljs-keyword">while</span> (*p != <span class="hljs-string">&#x27;`&#x27;</span>) &#123;<br>p++;<br>&#125;<br>*p = <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实现指令条件执行"><a href="#实现指令条件执行" class="headerlink" title="实现指令条件执行"></a>实现指令条件执行</h4><p>好难！！！</p><p>根据提示修改exit函数，并通过ipc将flag信号传递给父进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> flag)</span> &#123;<br><span class="hljs-comment">// After fs is ready (lab5), all our open files should be closed before dying.</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(LAB) || LAB &gt;= 5</span><br>close_all();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>syscall_ipc_try_send(envs[ENVX(env-&gt;env_parent_id)].env_parent_id, flag, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>syscall_env_destroy(<span class="hljs-number">0</span>);<br>user_panic(<span class="hljs-string">&quot;unreachable code&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>接下来就是根据返回值进行不同操作，具体如下</p><div class="table-container"><table><thead><tr><th>返回值</th><th>当前符号</th><th>目标</th></tr></thead><tbody><tr><td>0</td><td>\</td><td>\</td><td></td><td>寻找下一个&amp;&amp;后命令</td></tr><tr><td>1</td><td>\</td><td>\</td><td></td><td>指向下一命令判断返回值</td></tr><tr><td>0</td><td>&amp;&amp;</td><td>指向下一命令判断返回值</td></tr><tr><td>1</td><td>&amp;&amp;</td><td>寻找下一个\</td><td>\</td><td>后命令</td></tr></tbody></table></div><p>从env中获取到exit的返回值，在读取到&amp;&amp;和||时进行上述操作即可</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">if ((r <span class="hljs-operator">=</span> (syscall_ipc_recv(<span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)) &#123;<br>    return r<span class="hljs-comment">;</span><br>&#125;<br>    int value <span class="hljs-operator">=</span> env -&gt; env_ipc_value<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>坑点：父进程不用wait子进程！！！！！！！！！！！！！！</strong></p><h4 id="前后台任务"><a href="#前后台任务" class="headerlink" title="前后台任务"></a>前后台任务</h4><p>好难！！！！！！！！！，耗时最长的部分，主要理解一直有误，导致一直卡着</p><p>开始一直在用户空间储存结构体发现不对，才将其放在内核态。着实理解不足</p><p>在<code>env.h</code>中增加结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXJOBS 1000</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">job</span>&#123;</span><br><span class="hljs-type">int</span> job_id;<br><span class="hljs-type">int</span> status; <br>u_int env_id;<br><span class="hljs-type">int</span> killed;<br><span class="hljs-type">char</span> cmd[<span class="hljs-number">100</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p>并为用户态增加如下系统调用达到访问jobs目的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">syscall_fg_job</span><span class="hljs-params">(<span class="hljs-type">int</span> fgId)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">syscall_kill_job</span><span class="hljs-params">(<span class="hljs-type">int</span> killId)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">syscall_print_job</span><span class="hljs-params">()</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">syscall_add_job</span><span class="hljs-params">(u_int envid, <span class="hljs-type">char</span> * cmd)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">syscall_done_job</span><span class="hljs-params">(u_int envid)</span>;<br></code></pre></td></tr></table></figure><p>剩下部分就和往年类似，根据hangup判断是否需要等待</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">r = fork();<br><span class="hljs-keyword">if</span> (r) &#123;<br>    hangup = <span class="hljs-number">1</span>;<br>    syscall_add_job(r, cmd);<br>    <span class="hljs-keyword">return</span> parsecmd(argv, rightpipe);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    hangup = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> argc;<br>&#125;<br><span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>接下来，kill、fg等各参数根据argv中的参数进行各类操作即可，这里我的<code>syscall_fg_job(fgId)</code>起到一个返回对应fg的envid的作用，然后让进程等待该进程则可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">runcmd</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span> &#123;<br>save_history(s);<br><span class="hljs-built_in">strcpy</span>(cmd, s);<br>gettoken(s, <span class="hljs-number">0</span>);<br><br><span class="hljs-type">char</span> *argv[MAXARGS];<br><span class="hljs-type">int</span> rightpipe = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> argc = parsecmd(argv, &amp;rightpipe);<br><span class="hljs-keyword">if</span> (argc == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>argv[argc] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;fg&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-type">int</span> fgId = <span class="hljs-number">0</span>;<br><span class="hljs-type">char</span> *str = argv[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">while</span> (*str &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; *str &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        fgId = fgId * <span class="hljs-number">10</span> + (*str - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        str++;<br>&#125;<br><span class="hljs-comment">// fprintf(1, &quot;%d&quot;, fgId);</span><br><span class="hljs-type">int</span> envid = syscall_fg_job(fgId);<br><span class="hljs-comment">// fprintf(1, &quot;%x&quot; , envid);</span><br>wait(envid);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;kill&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-type">int</span> killId = <span class="hljs-number">0</span>;<br><span class="hljs-type">char</span> *str = argv[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">while</span> (*str &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; *str &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>        killId = killId * <span class="hljs-number">10</span> + (*str - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        str++;<br>&#125;<br><span class="hljs-type">int</span> envid = syscall_kill_job(killId);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span>; <br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;jobs&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>syscall_print_job();<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;history&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br>print_history();<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span>;<br>&#125; <br><span class="hljs-type">int</span> child = spawn(argv[<span class="hljs-number">0</span>], argv);<br>close_all();<br><span class="hljs-keyword">if</span> (child &gt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (hangup == <span class="hljs-number">0</span>) &#123;<br>wait(child);<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>debugf(<span class="hljs-string">&quot;spawn %s: %d\n&quot;</span>, argv[<span class="hljs-number">0</span>], child);<br>&#125;<br><span class="hljs-keyword">if</span> (rightpipe) &#123;<br>wait(rightpipe);<br>&#125;<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意最后在exit时要通过系统调用将进程标记为结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> flag)</span> &#123;<br><span class="hljs-comment">// After fs is ready (lab5), all our open files should be closed before dying.</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(LAB) || LAB &gt;= 5</span><br>close_all();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>syscall_ipc_try_send(envs[ENVX(env-&gt;env_parent_id)].env_parent_id, flag, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>syscall_done_job(env-&gt;env_id);<br>syscall_env_destroy(<span class="hljs-number">0</span>);<br>user_panic(<span class="hljs-string">&quot;unreachable code&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>系统调用内部主要就是各种结构体的赋值，内部参数的输出，较为简单。</p><p>做完之后回看这部分，其实没有想的那么难，把思路理清楚，虽然工作量很大，但做起来很快。</p><h4 id="历史指令"><a href="#历史指令" class="headerlink" title="历史指令"></a>历史指令</h4><p>难点主要在读取上下键极其后续处理上</p><div class="table-container"><table><thead><tr><th>键</th><th>编码</th></tr></thead><tbody><tr><td>上</td><td>27 ‘[‘ ‘A’</td></tr><tr><td>下</td><td>27 ‘[‘ ‘B’</td></tr></tbody></table></div><p>需要完成以下函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">save_history</span><span class="hljs-params">(<span class="hljs-type">char</span> *cmd)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">print_history</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">save_history</span><span class="hljs-params">(<span class="hljs-type">char</span> *cmd)</span> &#123;<br><span class="hljs-type">int</span> fd;<br><span class="hljs-keyword">if</span> ((fd = open(<span class="hljs-string">&quot;.mosh_history&quot;</span>, O_CREAT | O_WRONLY )) &lt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stat</span> <span class="hljs-title">st</span>;</span><br>stat(<span class="hljs-string">&quot;.mosh_history&quot;</span>, &amp;st);<br>seek(fd, st.st_size);<br>write(fd, cmd, <span class="hljs-built_in">strlen</span>(cmd));<br>write(fd, <span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-number">1</span>);<br>close(fd);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_history</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> r;<br><span class="hljs-keyword">if</span> ((r = open(<span class="hljs-string">&quot;.mosh_history&quot;</span>, O_RDONLY)) &lt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">char</span> buf;<br><span class="hljs-keyword">while</span> (read(r, &amp;buf, <span class="hljs-number">1</span>)) &#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;%c&quot;</span>, buf);<br>&#125;<br>close(r);<br>&#125;<br></code></pre></td></tr></table></figure><p>save_history有点类似于重定向，需要处理一下偏移量的问题。</p><p>print_history记得在runcmd()的第一句执行<code>save_history(s)</code>保存以下即可</p>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA_OO_Unit4</title>
    <link href="/2024/06/10/BUAA-OO-Unit4/"/>
    <url>/2024/06/10/BUAA-OO-Unit4/</url>
    
    <content type="html"><![CDATA[<h1 id="BUAA-OO-第四单元总结"><a href="#BUAA-OO-第四单元总结" class="headerlink" title="BUAA_OO_第四单元总结"></a>BUAA_OO_第四单元总结</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>首先，祝贺2206全体同学顺利完成COOOOS！！！正值高考结束，感触良多。</p><p>本单元作业是模拟一个图书馆管理系统，代码难度较低，主要是训练我们的建模架构能力，并运用好UML工具帮助我们更好的理解题目需求。</p><h3 id="本单元架构分析"><a href="#本单元架构分析" class="headerlink" title="本单元架构分析"></a>本单元架构分析</h3><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="uml.png" alt="uml"></p><h4 id="状态图"><a href="#状态图" class="headerlink" title="状态图"></a>状态图</h4><p><img src="state.png" alt="state"></p><h4 id="架构分析"><a href="#架构分析" class="headerlink" title="架构分析"></a>架构分析</h4><p>个人认为本次作业的架构还是十分满意的，基本可以满足“高内聚、低耦合”的要求。</p><p>本单元作业，根据书籍存放的位置，我对应建立<code>Bookshelf</code>、<code>User</code>、<code>BorrowAndReturnedOffice</code>、<code>AppointmentOffice</code>、<code>BookDriftOffice</code>这个五个类，并在内部使用HashMap存放对应书籍,虽然都是HashMap，但是由于各部分负责内容不同，所以具体上还是存在一定差异，例如，在AppointmentOffice中，我采用<code>HashMap&lt;LibraryBookId, HashMap&lt;String, Integer&gt;&gt; appointedBooks</code>，这样就可以记录这么书为谁保留、还剩几天。在User类中，我采用<code>HashMap&lt;LibraryBookId, LocalDate&gt; books</code>的结构，这样可以记录用户借阅的书籍还有几天截止。这五个类中方法大致相同，基本都是是否存在某本书、增加书、删除书，在第三次作业时，在User类中增加了信誉分以及涉及信誉分的查询、是否允许借阅操作。</p><p>此外，我在<code>Library</code>类中实例化了上述几个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Bookshelf bs;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BorrowAndReturnOffice bro;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AppointmentOffice ao;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BookDriftCorner bdc;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashMap&lt;String, User&gt; users;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArrayList&lt;LibraryReqCmd&gt; orderRequests;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;LibraryMoveInfo&gt; info;<br><span class="hljs-keyword">private</span> LocalDate date;<br></code></pre></td></tr></table></figure><p>具体操作方面，我将各种操作写成方法函数，这样每种操作都只对于一个方法:<code>returnBook(request)</code>、<code>borrowBook(request)</code>、<code>queryBook(request)</code>、<code>orderBook(request)</code>，<code>pickBook(request)</code>、<code>renewedBook(request)</code>、<code>donateBook(request)</code>、，并使用一个switch函数，根据操作类型判断使用哪个函数 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">solveRequest</span><span class="hljs-params">(LibraryReqCmd request)</span> &#123;<br>        <span class="hljs-keyword">switch</span> (request.getType()) &#123;<br>            <span class="hljs-keyword">case</span> RETURNED:<br>                returnBook(request);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> BORROWED:<br>                borrowBook(request);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> QUERIED:<br>                queryBook(request);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> ORDERED:<br>                orderBook(request);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> PICKED:<br>                pickBook(request);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> RENEWED:<br>                renewedBook(request);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> DONATED:<br>                donateBook(request);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="正向建模和开发"><a href="#正向建模和开发" class="headerlink" title="正向建模和开发"></a>正向建模和开发</h3><p>正向建模和开发是指从需求出发,通过分析、设计和实现的过程,最终生成满足需求的软件产品。这种方法强调从上到下的思路,先定义需求,然后进行设计和开发。</p><p>本单元其实相对考察正向建模能力的是第一次作业，在第一次作业中，我先是在草稿纸上有了大致的UML图后就开始写代码了，在写完代码后才进行具体的UML图的绘制，后两次作业中，主要都是在对应类中增加方法，和正向建模关系不大，但是这些都是建立在第一次作业的基础上，我在第一次作业时也考虑了后续用户不只学生，可能还包括老师、外校学生等，所以命名没有和官方包一致，有老师、外校学生等用户时直接采用继承。可以说，没有第一次的合理建模，就没有二三次作业的顺利完成。</p><h3 id="四个单元中架构设计思维的演进"><a href="#四个单元中架构设计思维的演进" class="headerlink" title="四个单元中架构设计思维的演进"></a>四个单元中架构设计思维的演进</h3><ul><li>U1中，我学习了层次化的设计，初识词法解析，学习过程举步维艰，更别谈架构，第一次作业主要参考了学长们的架构，一边写一边改进自己的架构，虽然这并不是一个比较好的思路，但对于一个新手来说，这是理解题目和提高自己能力的最好方式，但是最后总体架构较为理想，有了第一次作业的基础，二三次作业的迭代显得没那么困难了。</li><li>U2中，我学习了多线程程序设计，多线程程序设计会产生非常多奇怪的bug，所以我个人认为第二次作业中，体现在架构中最重要的是时序逻辑的设计，本单元中我还是同第一单元相同，一边写一边改进自己的架构，比起一步到达一个比较理想的架构，或许，重构的过程才是学习架构分析最重要的步骤。</li><li>U3中，我学习了JML语言，说实话，这个单元我打心底不太喜欢，或许让我们完成JML语言的书写意义更大，对着JML书写，完全失去了架构设计的学习，我知道针对某一特点函数写出一个效率较好的方法即可，甚至不需要了解题目要求</li><li>U4中，我学习了UML类图、状态图、顺序图的绘制，不得不说，提前做好这些的大致草稿，再写起代码来可以说如有神助，也是这一单元，让我加深了好的架构设计的优越性，二三次作业每次只有一两百行代码的增加。</li></ul><p>完成四个单元的作业后，我开始反思，为什么课程组一再强调架构设计，再看这么课程的名字“面向对象设计与构造”，而不是叫“Java程序设计”，或许这门课用什么语言都无所谓,可以指java,也可以是C++，因为重点始终是如何让我在“面向对象”中达到设计与构造。</p><h3 id="四个单元中测试思维的演进"><a href="#四个单元中测试思维的演进" class="headerlink" title="四个单元中测试思维的演进"></a>四个单元中测试思维的演进</h3><p>我不是一个擅长做全面测试的人，或者说我的测试更偏向于代码没有什么bug让自己心安的一种方式，由于一般完成作业较晚，所以中测数据就成了一个比较重要的部分，此外，针对个人代码，我会捏造一些奇怪的数据。此外测试过程中我也比较偏向于黑盒测试，相对单元测试，构造测试耗费的时间确实比较少，但是覆盖的范围和数据的有效性直接挂钩。</p><ul><li>U1中，数据构造比较简单，随机生成和结果检查都十分简单，评测构造不难，但是貌似意义不大，因为大家都问题基本都集中在效率上，所以还是人造点更靠谱。</li><li>U2中，使用随机策略+多线程，简直是debug的噩梦，bug定位也十分困难。</li><li>U3、U4，bug定位简单问题也主要集中在CPU超时上</li></ul><p>每一单元我的测试大致流程大致如下：</p><ul><li>利用样例和中测数据完成测试</li><li>利用随机生成数据简单轰炸</li><li>和他人手搓恶心数据，用于自己也用于他人（互测）</li></ul><h3 id="课程收获"><a href="#课程收获" class="headerlink" title="课程收获"></a>课程收获</h3><p>八次实验、十六次作业，首先，OO对代码能力的提升是巨大，其次，OO带我们打开了大规模代码架构的大门，或许，OO作业规模的代码不足以体现出架构设计的优越性，但我相信这么课带给我们的在今后的日子里一定会闪着它的光芒。</p>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象OO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA_OS_lab6</title>
    <link href="/2024/05/29/BUAA-OS-lab6/"/>
    <url>/2024/05/29/BUAA-OS-lab6/</url>
    
    <content type="html"><![CDATA[<h1 id="BUAA-OS-lab6学习日记"><a href="#BUAA-OS-lab6学习日记" class="headerlink" title="BUAA_OS_lab6学习日记"></a>BUAA_OS_lab6学习日记</h1><h2 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h2><h4 id="Thinking-6-1"><a href="#Thinking-6-1" class="headerlink" title="Thinking 6.1"></a>Thinking 6.1</h4><p>示例代码中，父进程操作管道的写端，子进程操作管道的读端。如果现在想 让父进程作为“读者”，代码应当如何修改？</p><p>父进程更改写端1，子进程更改读端0。</p><h4 id="Thinking-6-2"><a href="#Thinking-6-2" class="headerlink" title="Thinking 6.2"></a>Thinking 6.2</h4><p>上面这种不同步修改 pp_ref 而导致的进程竞争问题在 user/lib/fd.c 中 的dup 函数中也存在。请结合代码模仿上述情景，分析一下我们的 dup函数中为什么会出 现预想之外的情况</p><p>两个相关的页面map或者unmap的之间发生了时钟中断，会导致不一致的现象。</p><h4 id="Thinking-6-3"><a href="#Thinking-6-3" class="headerlink" title="Thinking 6.3"></a>Thinking 6.3</h4><p> 阅读上述材料并思考：为什么系统调用一定是原子操作呢？如果你觉得不是 所有的系统调用都是原子操作，请给出反例。希望能结合相关代码进行分析说明。</p><p>系统调用一定是原子操作，进程切换是通过定时器产生时钟中断，触发时钟中断切换进程。但是syscall跳转到内核态时，CPU将SR寄存其的IE位置0，关闭了时钟中断。</p><h4 id="Thinking-6-4"><a href="#Thinking-6-4" class="headerlink" title="Thinking 6.4"></a>Thinking 6.4</h4><p> 仔细阅读上面这段话，并思考下列问题</p><ul><li>按照上述说法控制 pipe_close中 fd和 pipeunmap的顺序，是否可以解决上述场 景的进程竞争问题？给出你的分析过程。</li><li>我们只分析了 close时的情形，在 fd.c中有一个 dup函数，用于复制文件描述符。 试想，如果要复制的文件描述符指向一个管道，那么是否会出现与 close类似的问 题？请模仿上述材料写写你的理解</li></ul><p>当对于pipe页面的引用次数小于对两个fd的和的时候，就会出现安全问题，而只要先解除fd再解除pipe，就不会出现上述问题，问题也仅仅只是拉大了二者的差距而已，对于结果没有影响。</p><p>会出现pipe页面的引用次数小于对两个fd的和的问题</p><h4 id="Thinking-6-5"><a href="#Thinking-6-5" class="headerlink" title="Thinking 6.5"></a>Thinking 6.5</h4><ul><li>认真回看Lab5文件系统相关代码，弄清打开文件的过程。 </li><li>回顾Lab1与Lab3，思考如何读取并加载ELF文件。 </li><li>在Lab1 中我们介绍了 data text bss 段及它们的含义，data 段存放初始化过的全 局变量，bss段存放未初始化的全局变量。关于memsize和filesize，我们在Note 1.3.4中也解释了它们的含义与特点。关于Note1.3.4，注意其中关于“bss段并不在文 件中占数据”表述的含义。回顾Lab3并思考：elf_load_seg()和load_icode_mapper() 函数是如何确保加载ELF文件时，bss段数据被正确加载进虚拟内存空间。bss段 在ELF中并不占空间，但ELF加载进内存后，bss段的数据占据了空间，并且初始 值都是0。请回顾elf_load_seg() 和 load_icode_mapper() 的实现，思考这一点 是如何实现的？ </li></ul><p>下面给出一些对于上述问题的提示，以便大家更好地把握加载内核进程和加载用户进程的 区别与联系，类比完成 spawn函数。</p><p>关于第一个问题，在Lab3中我们创建进程，并且通过 ENV_CREATE(…) 在内核态加 载了初始进程，而我们的 spawn函数则是通过和文件系统交互，取得文件描述块，进而找 到ELF 在“硬盘”中的位置，进而读取。 关于第二个问题，各位已经在Lab3中填写了load_icode 函数，实现了ELF 可执行 文件中读取数据并加载到内存空间，其中通过调用elf_load_seg 函数来加载各个程序段。 在Lab3 中我们要填写 load_icode_mapper 回调函数，在内核态下加载 ELF 数据到内存 空间；相应地，在Lab6中spawn函数也需要在用户态下使用系统调用为ELF数据分配空 间。</p><ul><li>在 Lab3 中我们创建进程，并且通过 ENV_CREATE(…) 在内核态加载了初始进程，而我们的 spawn 函数则是通过和文件系统交互，取得文件描述块，进而找到 ELF 在“硬盘”中的位置，进而读取。</li><li>在 Lab3 中填写的 load_icode 函数，实现了 ELF 可执行文件中读取数据并加载到内存空间，其中通过调用 elf_load_seg 函数来加载各个程序段。在 Lab3 中我们要填写 load_icode_mapper 回调函数，在内核态下加载 ELF 数据到内存空间；相应地，在 Lab6 中 spawn 函数也需要在用户态下使用系统调用为 ELF 数据分配空间。</li><li>bss段应该与text段data段连续的放在一起，但是ELF中没有空间，在分配映射页面时，text段与data段没有占满的空间置为0给了bss段，然后再给他另外分配的时候，只使用syscall_mem_alloc而不映射</li></ul><h4 id="Thinking-6-6"><a href="#Thinking-6-6" class="headerlink" title="Thinking 6.6"></a>Thinking 6.6</h4><p>通过阅读代码空白段的注释我们知道，将标准输入或输出定向到文件，需要 我们将其dup到0或1号文件描述符（fd）。那么问题来了：在哪步，0和1被“安排”为 标准输入和标准输出？请分析代码执行流程，给出答案</p><p>在user/init.c中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((r = opencons()) != <span class="hljs-number">0</span>) &#123;<br>  user_panic(<span class="hljs-string">&quot;opencons: %d&quot;</span>, r);<br>&#125;<br><span class="hljs-comment">// stdout</span><br><span class="hljs-keyword">if</span> ((r = dup(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &lt; <span class="hljs-number">0</span>) &#123;<br>  user_panic(<span class="hljs-string">&quot;dup: %d&quot;</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Thinking-6-7"><a href="#Thinking-6-7" class="headerlink" title="Thinking 6.7"></a>Thinking 6.7</h4><p>在 shell 中执行的命令分为内置命令和外部命令。在执行内置命令时shell不 需要fork 一个子 shell，如 Linux 系统中的 cd 命令。在执行外部命令时 shell 需要 fork 一个子shell，然后子 shell 去执行这条命令。 据此判断，在MOS 中我们用到的 shell 命令是内置命令还是外部命令？请思考为什么 Linux 的 cd 命令是内部命令而不是外部命令？</p><ul><li>外部命令</li><li>内部命令</li></ul><h4 id="Thinking-6-8"><a href="#Thinking-6-8" class="headerlink" title="Thinking 6.8"></a>Thinking 6.8</h4><p>在你的 shell 中输入命令 ls.b | cat.b &gt; motd。</p><ul><li>请问你可以在你的shell 中观察到几次spawn？分别对应哪个进程？</li><li>请问你可以在你的shell 中观察到几次进程销毁？分别对应哪个进程？</li></ul><p>答案：</p><ul><li>有两次spawn，分别打开了ls.b，cat.b进程</li><li>有四个进程的销毁，分别是左指令的执行进程，右指令的执行进程，spawn打开的两个执行进程。</li></ul><h3 id="实验感想和总结"><a href="#实验感想和总结" class="headerlink" title="实验感想和总结"></a>实验感想和总结</h3><p>lab6 总体的实验难度不难，函数也比较少，但是可以说是和我们日常最贴近的一次lab，通过实验，我们实现了shell的一些简单功能。</p>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA_OS_lab5</title>
    <link href="/2024/05/14/BUAA-OS-lab5/"/>
    <url>/2024/05/14/BUAA-OS-lab5/</url>
    
    <content type="html"><![CDATA[<h1 id="BUAA-OS-lab5学习日记"><a href="#BUAA-OS-lab5学习日记" class="headerlink" title="BUAA_OS_lab5学习日记"></a>BUAA_OS_lab5学习日记</h1><h2 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h2><h3 id="Thinking-5-1"><a href="#Thinking-5-1" class="headerlink" title="Thinking 5.1"></a>Thinking 5.1</h3><p>如果通过 kseg0 读写设备，那么对于设备的写入会缓存到 Cache 中。这是 一种错误的行为，在实际编写代码的时候这么做会引发不可预知的问题。请思考：这么做 这会引发什么问题？对于不同种类的设备（如我们提到的串口设备和IDE磁盘）的操作会有差异吗？可以从缓存的性质和缓存更新的策略来考虑。</p><p>缓存数据可能不及时导致出现一些不可预知错误，对于串口设备等读写频繁的设备出现的问题可能也对应更频繁。</p><h3 id="Exercise-5-4"><a href="#Exercise-5-4" class="headerlink" title="Exercise 5.4"></a>Exercise 5.4</h3><p>文件系统需要负责维护磁盘块的申请和释放，在回收一个磁盘块时，需要更 改位图中的标志位。如果要将一个磁盘块设置为free，只需要将位图中对应位的值设置 为1即可。请完成fs/fs.c中的free_block函数，实现这一功能。同时思考为什么参数 blockno的值不能为0？</p><p>MOS 操作系统把磁盘最开始的一个磁盘块（4096字节）当作引导扇区和分区表使用，不可以当作常规超级块使用</p><h3 id="Thinking-5-2"><a href="#Thinking-5-2" class="headerlink" title="Thinking 5.2"></a>Thinking 5.2</h3><p>查找代码中的相关定义，试回答一个磁盘块中最多能存储多少个文件控制 块？一个目录下最多能有多少个文件？我们的文件系统支持的单个文件最大为多大？</p><p>File结构体256B对齐，一个磁盘块4KB，可以容纳16个File，一个File最多有1024个指针，最多可以指向16K个文件。</p><p>文件最大为1024*4KB = 4MB</p><h3 id="Thinking-5-3"><a href="#Thinking-5-3" class="headerlink" title="Thinking 5.3"></a>Thinking 5.3</h3><p>DISKMAX = 0x40000000，最多处理1GB</p><h3 id="Thinking-5-4"><a href="#Thinking-5-4" class="headerlink" title="Thinking 5.4"></a>Thinking 5.4</h3><p>fs/serv.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_DIRTY 0x0004 <span class="hljs-comment">// 文件系统块脏位</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECT_SIZE 512  <span class="hljs-comment">//扇区大小</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECT2BLK (BLOCK_SIZE / SECT_SIZE) <span class="hljs-comment">//将扇区转化为磁盘块</span></span><br></code></pre></td></tr></table></figure><p>user/include/fs.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Bytes per file system block - same as page size</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BLOCK_SIZE PAGE_SIZE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BLOCK_SIZE_BIT (BLOCK_SIZE * 8)</span><br><br><span class="hljs-comment">// Maximum size of a filename (a single path component), including null</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXNAMELEN 128</span><br><br><span class="hljs-comment">// Maximum size of a complete pathname, including null</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXPATHLEN 1024</span><br><br><span class="hljs-comment">// Number of (direct) block pointers in a File descriptor</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NDIRECT 10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NINDIRECT (BLOCK_SIZE / 4)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXFILESIZE (NINDIRECT * BLOCK_SIZE)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FILE_STRUCT_SIZE 256</span><br><span class="hljs-comment">// File types</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FTYPE_REG 0 <span class="hljs-comment">// Regular file</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FTYPE_DIR 1 <span class="hljs-comment">// Directory</span></span><br><br><span class="hljs-comment">// File system super-block (both in-memory and on-disk)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FS_MAGIC 0x68286097 <span class="hljs-comment">// Everyone&#x27;s favorite OS class</span></span><br></code></pre></td></tr></table></figure><h3 id="Thinking-5-5"><a href="#Thinking-5-5" class="headerlink" title="Thinking 5.5"></a>Thinking 5.5</h3><p>在Lab4“系统调用与fork”的实验中我们实现了极为重要的fork函数。那 么fork前后的父子进程是否会共享文件描述符和定位指针呢？请在完成上述练习的基础上 编写一个程序进行验证</p><p>确实共享</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;lib.h&quot;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">char</span> *msg = <span class="hljs-string">&quot;This is the NEW message of the day!\n\n&quot;</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> *diff_msg = <span class="hljs-string">&quot;This is a different massage of the day!\n\n&quot;</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">umain</span><span class="hljs-params">()</span><br>&#123;<br>        <span class="hljs-type">int</span> r;<br>        <span class="hljs-type">int</span> fdnum;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>];<br>        <span class="hljs-type">int</span> n;<br><br>        <span class="hljs-keyword">if</span> ((r = open(<span class="hljs-string">&quot;/newmotd&quot;</span>, O_RDWR)) &lt; <span class="hljs-number">0</span>) &#123;<br>            user_panic(<span class="hljs-string">&quot;open /newmotd: %d&quot;</span>, r);<br>        &#125;<br>        fdnum = r;<br>        writef(<span class="hljs-string">&quot;open is good\n&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> ((n = read(fdnum, buf, <span class="hljs-number">511</span>)) &lt; <span class="hljs-number">0</span>) &#123;<br>            user_panic(<span class="hljs-string">&quot;read /newmotd: %d&quot;</span>, r);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(buf, diff_msg) != <span class="hljs-number">0</span>) &#123;<br>            user_panic(<span class="hljs-string">&quot;read returned wrong data&quot;</span>);<br>        &#125;<br>        writef(<span class="hljs-string">&quot;read is good\n&quot;</span>);<br><br>        <span class="hljs-type">int</span> id;<br><br>        <span class="hljs-keyword">if</span> ((id = fork()) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((n = read(fdnum, buf, <span class="hljs-number">511</span>)) &lt; <span class="hljs-number">0</span>) &#123;<br>                user_panic(<span class="hljs-string">&quot;child read /newmotd: %d&quot;</span>, r);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(buf, diff_msg) != <span class="hljs-number">0</span>) &#123;<br>                user_panic(<span class="hljs-string">&quot;child read returned wrong data&quot;</span>);<br>            &#125;<br>            writef(<span class="hljs-string">&quot;child read is good &amp;&amp; child_fd == %d\n&quot;</span>,r);<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fd</span> *<span class="hljs-title">fdd</span>;</span><br>            fd_lookup(r,&amp;fdd);<br>            writef(<span class="hljs-string">&quot;child_fd&#x27;s offset == %d\n&quot;</span>,fdd-&gt;fd_offset);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span>((n = read(fdnum, buf, <span class="hljs-number">511</span>)) &lt; <span class="hljs-number">0</span>) &#123;<br>                user_panic(<span class="hljs-string">&quot;father read /newmotd: %d&quot;</span>, r);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(buf, diff_msg) != <span class="hljs-number">0</span>) &#123;<br>                user_panic(<span class="hljs-string">&quot;father read returned wrong data&quot;</span>);<br>            &#125;<br>            writef(<span class="hljs-string">&quot;father read is good &amp;&amp; father_fd == %d\n&quot;</span>,r);<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fd</span> *<span class="hljs-title">fdd</span>;</span><br>            fd_lookup(r,&amp;fdd);<br>            writef(<span class="hljs-string">&quot;father_fd&#x27;s offset == %d\n&quot;</span>,fdd-&gt;fd_offset);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">main.c: main <span class="hljs-built_in">is</span> start ...<br>init.c: mips_init() <span class="hljs-built_in">is</span> called<br>Physical memory: <span class="hljs-number">65536</span>K available, base = <span class="hljs-number">65536</span>K, extended = <span class="hljs-number">0</span>K<br><span class="hljs-keyword">to</span> memory <span class="hljs-number">80401000</span> <span class="hljs-keyword">for</span> struct page directory.<br><span class="hljs-keyword">to</span> memory <span class="hljs-number">80431000</span> <span class="hljs-keyword">for</span> struct Pages.<br>pmap.c:  mips vm init success<br><span class="hljs-symbol">pageout:</span>        @@@___0x7f3fe000___@@@  ins a page <br><span class="hljs-symbol">pageout:</span>        @@@___0x40d000___@@@  ins a page <br>FS <span class="hljs-built_in">is</span> running<br>FS can <span class="hljs-keyword">do</span> I/O<br><span class="hljs-symbol">pageout:</span>        @@@___0x7f3fe000___@@@  ins a page <br><span class="hljs-symbol">pageout:</span>        @@@___0x407000___@@@  ins a page <br>superblock <span class="hljs-built_in">is</span> good<br><span class="hljs-symbol">diskno:</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">diskno:</span> <span class="hljs-number">0</span><br>read_bitmap <span class="hljs-built_in">is</span> good<br><span class="hljs-symbol">diskno:</span> <span class="hljs-number">0</span><br>alloc_block <span class="hljs-built_in">is</span> good<br>file_open <span class="hljs-built_in">is</span> good<br>file_get_block <span class="hljs-built_in">is</span> good<br>file_flush <span class="hljs-built_in">is</span> good<br>file_truncate <span class="hljs-built_in">is</span> good<br><span class="hljs-symbol">diskno:</span> <span class="hljs-number">0</span><br>file rewrite <span class="hljs-built_in">is</span> good<br>serve_open <span class="hljs-number">00000400</span> ffff000 <span class="hljs-number">0</span>x2<br>open <span class="hljs-built_in">is</span> good<br>read <span class="hljs-built_in">is</span> good<br>father read <span class="hljs-built_in">is</span> good &amp;&amp; father_fd == <span class="hljs-number">0</span><br>father_fd<span class="hljs-comment">&#x27;s offset == 41</span><br>[<span class="hljs-number">00000400</span>] destroying <span class="hljs-number">00000400</span><br>[<span class="hljs-number">00000400</span>] free env <span class="hljs-number">00000400</span><br>i am killed ... <br>child read <span class="hljs-built_in">is</span> good &amp;&amp; child_fd == <span class="hljs-number">0</span><br>child_fd<span class="hljs-comment">&#x27;s offset == 41</span><br>[<span class="hljs-number">00001402</span>] destroying <span class="hljs-number">00001402</span><br>[<span class="hljs-number">00001402</span>] free env <span class="hljs-number">00001402</span><br>i am killed ... <br></code></pre></td></tr></table></figure><h3 id="Thinking-5-6"><a href="#Thinking-5-6" class="headerlink" title="Thinking 5.6"></a>Thinking 5.6</h3><p>请解释File,Fd,Filefd结构体及其各个域的作用。比如各个结构体会在哪些过程中被使用，是否对应磁盘上的物理实体还是单纯的内存数据等。说明形式自定，要求简洁明了，可大致勾勒出文件系统数据结构与物理实体的对应关系与设计框架</p><h3 id="Thinking-5-7"><a href="#Thinking-5-7" class="headerlink" title="Thinking 5.7"></a>Thinking 5.7</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fd</span> &#123;</span><br>u_int fd_dev_id; <span class="hljs-comment">//外设id</span><br>u_int fd_offset; <span class="hljs-comment">//读写偏移量</span><br>u_int fd_omode; <span class="hljs-comment">//打开方式</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Filefd</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fd</span> <span class="hljs-title">f_fd</span>;</span> <span class="hljs-comment">//文件描述</span><br>u_int f_fileid; <span class="hljs-comment">//文件id</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> <span class="hljs-title">f_file</span>;</span>  <span class="hljs-comment">//对应文件的文件控制块</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> &#123;</span><br><span class="hljs-type">char</span> f_name[MAXNAMELEN]; <span class="hljs-comment">// filename</span><br><span class="hljs-type">uint32_t</span> f_size; <span class="hljs-comment">// file size in bytes</span><br><span class="hljs-type">uint32_t</span> f_type; <span class="hljs-comment">// file type</span><br><span class="hljs-type">uint32_t</span> f_direct[NDIRECT]; <span class="hljs-comment">//文件的直接指针数组</span><br><span class="hljs-type">uint32_t</span> f_indirect; <span class="hljs-comment">//间接指针，用来存储指向文件内容的磁盘块的指针</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> *<span class="hljs-title">f_dir</span>;</span> <span class="hljs-comment">// the pointer to the dir where this file is in, valid only in memory. 文件目录指针</span><br><span class="hljs-type">char</span> f_pad[FILE_STRUCT_SIZE - MAXNAMELEN - (<span class="hljs-number">3</span> + NDIRECT) * <span class="hljs-number">4</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *)]; <span class="hljs-comment">//填充块保证256字节对齐</span><br>&#125; __attribute__((aligned(<span class="hljs-number">4</span>), packed));<br></code></pre></td></tr></table></figure><h3 id="Thinking-5-7-1"><a href="#Thinking-5-7-1" class="headerlink" title="Thinking 5.7"></a>Thinking 5.7</h3><p><img src="sxt.png" alt="sxt"></p><p>图中有多种不同形式的箭头，请解释这些不同箭头的差别，并思考我们的操作系统是如何实现对应类型的进程间通信的。</p><ul><li>ENV_CREATE(user_env) 和 ENV_CREATE(fs_serv) 都是异步消息，由 init() 发出创建消息后， init() 函数即可返回执行后续步骤，由 fs 和 user 线程执行自己的初始化工作</li><li>fs线程向user线程ipcsend（fsreq）是同步消息，fs 线程初始化 serv_init() 和 fs_init() 完成后，进入 serv() 函数，被 ipc_receive() 阻塞为ENV_NOT_RUNNABLE ，直到收到 user 线程的 ipc_send(fsreq) 被唤醒。</li><li>user 线程向 fs 线程 ipc_send(fsreq) 发送请求为同步消息，发送后自身进入阻塞ENV_NOT_RUNNABLE 等待被唤醒的fs线程服务结束时 ipc_send(dst_va) ,用户线程接收到数据后继续运行，此后 fs 线程进入阻塞，等待下次被用户唤醒。</li></ul><h2 id="实验难点感想与总结"><a href="#实验难点感想与总结" class="headerlink" title="实验难点感想与总结"></a>实验难点感想与总结</h2><h5 id="内存映射实现I-O串口操作"><a href="#内存映射实现I-O串口操作" class="headerlink" title="内存映射实现I/O串口操作"></a>内存映射实现I/O串口操作</h5><p> sys_write_dev和 sys_read_dev 两个系统调用来实现设备的读写操作</p><p>写的位置分为console和disk，只需要分别在满足地址合理的情况下利用memcpy实现物理地址和虚拟地址之间的读写即可</p><p><strong>I/O磁盘关键寄存器映射</strong></p><p><img src="temp.png" alt="temp"></p><p>设置IDE为读写状态之前需要设置操作扇区号的[7:0]、[15:8]、[23:16]、[27:24]位（用户态）</p><p><strong>文件系统结构</strong></p><p>磁盘空间布局：</p><p><img src="diskLayOut.png" alt="diskLayOut"></p><p>磁盘块只是一个虚拟概念，是操作系统与磁盘交互的最小单位</p><p>文件访问：</p><p>如果直接指针访问不到需要先通过间接指针访问磁盘，才能继续通过bno（磁盘块号）访问到对应的directory block</p><p><strong>块操作</strong></p><p>块地址：<code>return (void *)(DISKMAP + blockno * BLOCK_SIZE);</code></p><p>块映射</p><p>dir_lookup:查找某个目录下是否存在指定的文件</p><p>先找到目录下block的个数在遍历内部的file</p><p><strong>文件系统服务</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> &#123;</span><br><span class="hljs-type">char</span> f_name[MAXNAMELEN]; <span class="hljs-comment">// filename</span><br><span class="hljs-type">uint32_t</span> f_size; <span class="hljs-comment">// file size in bytes</span><br><span class="hljs-type">uint32_t</span> f_type; <span class="hljs-comment">// file type</span><br><span class="hljs-type">uint32_t</span> f_direct[NDIRECT];<br><span class="hljs-type">uint32_t</span> f_indirect;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> *<span class="hljs-title">f_dir</span>;</span> <span class="hljs-comment">// the pointer to the dir where this file is in, valid only in memory.</span><br><span class="hljs-type">char</span> f_pad[FILE_STRUCT_SIZE - MAXNAMELEN - (<span class="hljs-number">3</span> + NDIRECT) * <span class="hljs-number">4</span> - <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span> *)];<br>&#125;<br></code></pre></td></tr></table></figure><p>本次lab以删除文件为例，实现了用户和内核态的文件删除，一定要留意彼此之间的IPC的通信操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    FSREQ_OPEN,<br>    FSREQ_MAP,<br>    FSREQ_SET_SIZE,<br>    FSREQ_CLOSE,<br>    FSREQ_DIRTY,<br>    FSREQ_REMOVE,<br>    FSREQ_SYNC,<br>    MAX_FSREQNO,<br>&#125;;<br></code></pre></td></tr></table></figure><p>总的来说，lab5的实现难度相比前面有所下降，理解好文件和磁盘系统就可以顺利完成</p>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>quantumComputation量子计算</title>
    <link href="/2024/04/27/quantumComputation/"/>
    <url>/2024/04/27/quantumComputation/</url>
    
    <content type="html"><![CDATA[<h1 id="量子计算"><a href="#量子计算" class="headerlink" title="量子计算"></a>量子计算</h1><ul><li>$U = e^{i\alpha} *R_n(\theta)$</li><li>$R_n(\theta) = cos(\theta/2)- isin(\theta /2) <em> (n_x</em>X+n_y<em>Y + n_z</em>Z)$</li><li>$\mid+&gt; = \frac{1}{\sqrt2} (\mid0&gt; + \mid1&gt;)$</li><li>$\mid-&gt; = \frac{1}{\sqrt2} (\mid0&gt; - \mid1&gt;)$</li></ul><p>解决python多版本pip问题</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">python</span> -m pip install qiskit<br><span class="hljs-attribute">py</span> -<span class="hljs-number">3</span>.<span class="hljs-number">5</span> -m pip install numpy<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>科研课堂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA_OS_lab4</title>
    <link href="/2024/04/26/BUAA-OS-lab4/"/>
    <url>/2024/04/26/BUAA-OS-lab4/</url>
    
    <content type="html"><![CDATA[<h1 id="BUAA-OO-lab4学习日记"><a href="#BUAA-OO-lab4学习日记" class="headerlink" title="BUAA_OO_lab4学习日记"></a>BUAA_OO_lab4学习日记</h1><h2 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h2><h3 id="Thinking-4-1"><a href="#Thinking-4-1" class="headerlink" title="Thinking 4.1"></a>Thinking 4.1</h3><p>问：</p><ul><li>内核在保存现场的时候是如何避免破坏通用寄存器的？</li><li>系统陷入内核调用后可以直接从当时的 $a0-$a3 参数寄存器中得到用户调用 msyscall 留下的信息吗？</li><li>我们是怎么做到让 sys 开头的函数“认为”我们提供了和用户调用 msyscall 时同样 的参数的？</li><li>内核处理系统调用的过程对 Trapframe 做了哪些更改？这种修改对应的用户态的变化是什么？</li></ul><p>答：</p><ul><li><p>由stackframe.h文件可以看出，在SAVE_ALL时将各个通用寄存器的值保存在在帧栈（sw），在RESTORE_ALL再将各个寄存器值取出，但是注意压栈和弹栈的顺序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//stackframe.h</span><br>.macro SAVE_ALL<br>sw      $<span class="hljs-number">0</span>, TF_REG0(sp)<br>sw      $<span class="hljs-number">1</span>, TF_REG1(sp)<br><span class="hljs-comment">//……</span><br>    sw      $<span class="hljs-number">30</span>, TF_REG30(sp)<br>sw      $<span class="hljs-number">31</span>, TF_REG31(sp)<br><span class="hljs-comment">//……</span><br>.macro RESTORE_ALL<br>    lw      $<span class="hljs-number">31</span>, TF_REG31(sp)<br>    lw      $<span class="hljs-number">30</span>, TF_REG30(sp)<br><span class="hljs-comment">//……</span><br>lw      $<span class="hljs-number">2</span>, TF_REG2(sp)<br>lw      $<span class="hljs-number">1</span>, TF_REG1(sp)<br>lw      sp, TF_REG29(sp) <span class="hljs-comment">/* Deallocate stack */</span><br></code></pre></td></tr></table></figure></li><li><p>可以， 调用函数时$a0-$a3默认储存前四个参数，用于参数传递，内核中可能有改变，因此再次以这些参数调用其他函数时需要重新以sp为基地址，按相应偏移从用户栈中取用这四个寄存器值</p></li><li><p>借助Trapframe结构体，来获取用户态中传递过来的值</p></li><li><p>改变了reg[2]即v0寄存器的值，就是系统调用函数的返回值，这个返回值可以标志系统调用是否成功，不成功就输出相应的错误码。</p></li></ul><h3 id="Thinking-4-2"><a href="#Thinking-4-2" class="headerlink" title="Thinking 4.2"></a>Thinking 4.2</h3><p>问：</p><p>思考 envid2env 函数: 为什么 envid2env 中需要判断 e-&gt;env_id != envid 的情况？如果没有这步判断会发生什么情况？ </p><p>答：envid具有唯一性，防止取到错误的进程控制块</p><h3 id="Thinking-4-3"><a href="#Thinking-4-3" class="headerlink" title="Thinking 4.3"></a>Thinking 4.3</h3><p>问：</p><p>思考下面的问题，并对这个问题谈谈你的理解：请回顾 kern/env.c 文件 中 mkenvid() 函数的实现，该函数不会返回 0，请结合系统调用和 IPC 部分的实现与 envid2env() 函数的行为进行解释。</p><p>答：</p><p>mkenvid函数不会返回0，所以没有进程的envid为0，但是envid2env的实现我们发现若传入的envid参数为0，我们直接返回当前进程。于是系统调用和IPC可以通过envid为0获取当前进程，于是这部分很重要。</p><h3 id="Thinking-4-4"><a href="#Thinking-4-4" class="headerlink" title="Thinking 4.4"></a>Thinking 4.4</h3><p>问：</p><p>关于 fork 函数的两个返回值，下面说法正确的是： </p><p>A、fork 在父进程中被调用两次，产生两个返回值 </p><p>B、fork 在两个进程中分别被调用一次，产生两个不同的返回值 </p><p>C、fork 只在父进程中被调用了一次，在两个进程中各产生一个返回值 </p><p>D、fork 只在子进程中被调用了一次，在两个进程中各产生一个返回值</p><p>答：</p><p>C</p><p>父进程中调用fork函数，并返回子进程的id</p><h3 id="Thinking-4-5"><a href="#Thinking-4-5" class="headerlink" title="Thinking 4.5"></a>Thinking 4.5</h3><p>问：</p><p>我们并不应该对所有的用户空间页都使用 duppage 进行映射。那么究竟哪些用户空间页应该映射，哪些不应该呢？请结合 kern/env.c 中 env_init 函数进行的页 面映射、include/mmu.h 里的内存布局图以及本章的后续描述进行思考。</p><ul><li>首先肯定映射用户空间的有效页面。</li><li>用户空间中ULIM到USTACKTOP之间的部分，储存的是页表信息，异常处理栈等，或是已经完成了拷贝的（页表），或是父子进程共享的（异常处理栈），或是都不需要用到的。所以不需要映射。</li></ul><p>所以，最终需要被映射的页面只有<code>USTACKTOP</code>之下的有效部分</p><h3 id="Thinking-4-6"><a href="#Thinking-4-6" class="headerlink" title="Thinking 4.6"></a>Thinking 4.6</h3><p>问：</p><p>在遍历地址空间存取页表项时你需要使用到 vpd 和 vpt 这两个指针，请参考 user/include/lib.h 中的相关定义，思考并回答这几个问题：</p><ul><li>vpt 和 vpd 的作用是什么？怎样使用它们？ </li><li>从实现的角度谈一下为什么进程能够通过这种方式来存取自身的页表？</li><li>它们是如何体现自映射设计的？</li><li>进程能够通过这种方式来修改自己的页表项吗？</li></ul><p>答：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> vpt ((const volatile Pte *)UVPT)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> vpd ((const volatile Pde *)(UVPT + (PDX(UVPT) &lt;&lt; PGSHIFT)))</span><br></code></pre></td></tr></table></figure><ul><li>vpt与vpd分别是用户页表与用户页目录的地址，当作数组方式使用即可</li><li>vpd是自映射机制取址</li><li>vpd实现等价于 $UVPT | UVPT &gt;&gt; 10$</li><li>不能，修改只能在内核态下实现</li></ul><h3 id="Thinking-4-7"><a href="#Thinking-4-7" class="headerlink" title="Thinking 4.7"></a>Thinking 4.7</h3><p>问：</p><p>在 do_tlb_mod 函数中，你可能注意到了一个向异常处理栈复制 Trapframe 运行现场的过程，请思考并回答这几个问题：</p><ul><li>这里实现了一个支持类似于“异常重入”的机制，而在什么时候会出现这种“异常重 入”？</li><li>内核为什么需要将异常的现场 Trapframe 复制到用户空间？</li></ul><p>答：</p><ul><li>当用户程序写入了一个<code>COW</code>页，OS就会进入页写入异常的处理程序，最终调用用户态的<code>pgfault</code>函数进行处理。但是，如果在<code>pgfault</code>函数的处理过程中又写入了一个<code>COW</code>页，就会再次进入页写入异常处理程序，然后又调用<code>pgfault</code>函数……这就出现了”中断重入“的现象。因为在这个函数里，我们只对异常处理栈所在的页进行了读写（异常处理程序中的临时变量都保存在异常处理栈），而异常处理栈并非是父子进程共享的，不可能会有<code>COW</code>标志位。所以不会出现</li><li>异常处理是自定义的在用户态下进行，而用户态访问不到内核，所以需要将现场保存到用户空间</li></ul><h3 id="Thinking-4-8"><a href="#Thinking-4-8" class="headerlink" title="Thinking 4.8"></a>Thinking 4.8</h3><p>问：</p><p>在用户态处理页写入异常，相比于在内核态处理有什么优势？ </p><p>答：</p><p>出现错误更少，即使程序崩溃，也不会影响系统的稳定</p><h3 id="Thinking-4-9"><a href="#Thinking-4-9" class="headerlink" title="Thinking 4.9"></a>Thinking 4.9</h3><p>问：</p><p>请思考并回答以下几个问题：</p><ul><li>为什么需要将 syscall_set_tlb_mod_entry 的调用放置在 syscall_exofork 之前？</li><li>如果放置在写时复制保护机制完成之后会有怎样的效果？</li></ul><p>答：</p><ul><li>写时复制异常处理父子进程都需要设置，保证父子进程的异常出口都设置</li><li>父进程在执行完syscall_exofork后就返回了，等到写时复制机制完成后再设置的话，父进程的异常处理就不是写时复制了</li></ul><h2 id="实验难点"><a href="#实验难点" class="headerlink" title="实验难点"></a>实验难点</h2><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><h5 id="异常处理行为"><a href="#异常处理行为" class="headerlink" title="异常处理行为"></a>异常处理行为</h5><ul><li>跳转异常分发代码处</li><li>进入异常分发程序，根据cause寄存器的值判断异常类型并跳转到对应的处理程序</li><li>处理异常，返回</li></ul><p><img src="syscall过程.png" alt="syscall过程"></p><p>系统从用户态切换到内核态后，内核首先需要将原用户进程的 运行现场保存到内核空间（在 kern/entry.S 中通过 SAVE_ALL 宏完成），随后的栈指针则指向 保存的 Trapframe</p><p>进程空间分配（实质是建立映射）</p><h3 id="IPC进程间通信"><a href="#IPC进程间通信" class="headerlink" title="IPC进程间通信"></a>IPC进程间通信</h3><p>会大量使用 srcva 为 0 的调用来表示只传 value 值，而不需要传递物理页面，换句话说，当 srcva 不为 0 时，我们才建立两个进程的页面映射关系</p><p>核心：页表的插入</p><h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h3><p>函数理解</p><p>fork_test实验</p><p><img src="fork_test.png" alt="fork_test"></p><p>父进程返回值不为0，子进程返回值为0</p><p>总之二者对应进程控制块不同</p><h2 id="实验感想"><a href="#实验感想" class="headerlink" title="实验感想"></a>实验感想</h2><p>单纯完成实验并不难，核心在于对各个处理流程的理解</p><p><img src="ipc流程.png" alt="ipc流程"></p><p><img src="流程图.png" alt="流程图"></p>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS理论学习</title>
    <link href="/2024/04/17/OS%E7%90%86%E8%AE%BA/"/>
    <url>/2024/04/17/OS%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="OS复习"><a href="#OS复习" class="headerlink" title="OS复习"></a>OS复习</h1><blockquote><p>这是什么样的微风，我找不到准确的表述语句，只找到一连串的不是，不是杜甫“细草微风岸”的风，不是高骈“水晶帘动微风起”的风，冯延巳的“吹皱一池春水”是因为“风乍起”，过于突然，也不是，更不是“风萧萧兮易水寒”里的风，山谷微风不是壮志凌云之风，不会去送别荆轲，它知道自已普通微小，所以低调，其低调有点像我少年时期在炎热夏天里寻找的穿堂风。</p></blockquote><h2 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h2><p>MIPS工作空间</p><p><img src="tlb-mmu.png" alt="MIPS工作空间"></p><h3 id="概述与启动"><a href="#概述与启动" class="headerlink" title="概述与启动"></a>概述与启动</h3><p><strong>分布式系统</strong></p><p>在整个系统中有一个全局的操作系统</p><p>有网络作为底层支持</p><p>特性</p><ul><li>模块性</li><li>并行性</li><li>自治性</li><li>通信性</li></ul><p>操作系统作用：管理资源，提供硬件访问的统一接口</p><p>操作系统的发展：</p><ul><li>单任务串行 - 多任务并发</li><li>单处理器 - 多处理器 - 分布式网络化</li></ul><p>多任务操作系统基本原理</p><p>分时——多个用户/任务互不干扰地使用资源</p><p>分时的基本方式（隔离手段）</p><p>虚拟：隔离所有资源</p><p>抽象：进程（隔离处理器、储存器）</p><p>TRAP指令：目态 - 管态 （用户 - 内核态）</p><p>异常：陷阱和中断</p><ul><li>中断主要由I/O设备、处理器时钟或定时器等硬件产生，可以被启用和禁用</li><li>陷阱/陷入是用户进程中某一特定指令执行的结果，在相同条件下，异常可以重现。例如内存访问错误、调试指令以及被零除</li><li>系统调用是同步异常</li><li>陷阱帧：完整的线程描述表的自己，用于陷阱保护</li><li>陷阱处理程序处理少量事件，多数转交给其他的内核或 执行体模块处理</li></ul><p><img src="exception.png" alt="异常"></p><p>操作系统特征</p><ul><li>并发</li><li><p>共享（互斥共享（打印机、变量），同时访问（宏观））</p><ul><li>互斥共享：大多数物理设备和其软件使用的栈、变量、表格</li></ul></li><li><p>虚拟</p><ul><li>分时共享</li></ul></li><li><p>异步性</p><ul><li>受资源限制，程序走走停停</li></ul></li></ul><p>用户访问计算机——命令接口和程序接口（系统调用）</p><p>OS功能</p><ul><li>处理机管理——分配CPU时间</li><li>储存器管理——管理缓存、主存、磁盘等所 形成的多级存储架构，为多道程序的并 发提供良好的环境</li><li>设备管理——管理输入/输出设备，屏蔽差 异性，提供并发访问</li><li>文件系统——将磁盘变成一个很容易使用的 存储媒介提供给用户使用</li><li>作业控制——作业调度</li></ul><p><strong>操作系统的基本类型</strong></p><ul><li>工作方式：批处理系统、分时系统、实时系统、混合型</li><li>架构：微内核、宏内核、外内核</li></ul><p>微内核</p><p>内核中只包括中断处理、进程通信（IPC）、 基本调度等</p><p>优点：内核易于实现、可靠性高、可移植性好、配置灵活、 适应分布式环境</p><p>缺点：速度慢</p><p>引导加载程序是系统加电后运行的第一段程序，称为Bootloader</p><p><strong>Bios</strong></p><p>bios设置程序是被固化到电脑主板上的ROM芯片中的一组程序（断电后不会丢失的只读程序）</p><ul><li>硬件自检</li><li>读取启动顺序</li></ul><p>例题：在传统x86体系结构下，计算机引导过程中以下哪项不是 BIOS负责的任务？</p><ul><li>读取MBR并装载到内存特定地址（Bootloader）</li><li>自检系统，当有设备故障时暂停启动过程并告警（Bios）</li><li>选择引导磁盘（Bios）</li><li>装载打印机驱动（没必要）</li><li>启动显示器（Bios）</li><li>解压缩操作系统Kernel（Bootloader）</li></ul><p><strong>系统引导</strong></p><p>MBR（Master Boot Record）：磁盘的第0磁头第0磁道的第一个扇区</p><p>Bootloader：操作系统内核运行前执行的一小段程序</p><p><strong>BootLoader</strong></p><p>操作系统内核运行前的一小段程序</p><p>通常<strong>bootloader可以支持不同CPU架构</strong>，也可以支持不同操作系统的启动。</p><p>C语言中函数压栈顺序：先压最后一个参数</p><p>访问速度</p><p>DRAM &lt; DDR(SDRAM) &lt; SRAM。</p><h3 id="储存与管理"><a href="#储存与管理" class="headerlink" title="储存与管理"></a>储存与管理</h3><p>储存管理至少要解决分配与回收</p><ul><li>地址空间：逻辑地址的集合</li><li>储存空间：逻辑地址的集合</li></ul><p><strong>单道程序的内存管理</strong></p><p>内存中只有两个程序——用户程序和操作系统</p><p>用户程序的地址再运行之前可以运算</p><p>优点：简单</p><p>缺点：比物理内存大的程序无法加载、小程序会造成空间浪费</p><p><strong>多道程序设计</strong></p><p>空间的分配：分区式分配，把内存分为一些大小相等或者不等的分区</p><ul><li>固定式分区分配（静态）：程序适应分区</li><li>可变式分区分配（动态）：分区适应程序</li></ul><p><strong>固定式分区</strong></p><p>系统初始化时，把储存空间划分为若干个任意大小的区域，然后将这些区域分配个每个用户作业。</p><ul><li>分区大小相等：只适用于多个相同程序的并发执行（处理多个类型相同的对象）</li><li>分区大小不等：多个小分区、适量的中等分区、少量 的大分区。根据程序的大小，分配当前空闲的、适当 大小的分区</li></ul><p>优点：易于实现，开销小</p><p>缺点：内碎片造成浪费，分区总数固定，限制并发执行的程序数量</p><ul><li>单一队列的分配方式</li></ul><p>多个用户程序排在一个 共同的队列里面等待分区</p><ul><li>对队列分配方式</li></ul><p>每个分区一个队列，程序按照大小排在相应的队列里，避免给小程序分配大空间</p><p><strong>可变式分区</strong></p><p>分区的边界可以移动，即分区大小可变</p><p>优点：没有内碎片，缺点：有外碎片</p><p><strong>碎片</strong></p><p>内存中无法被利用的储存空间</p><ul><li>内碎片</li></ul><p>分配给作业的储存空间中未被利用的部分，已分配只是未被使用，完成后会得到释放</p><ul><li>外碎片</li></ul><p>分区与分区之间存在的碎片。外部碎片是造成内存系统性能下降的主要原因，外部碎片可以被整理后消除（消除外部碎片的方法：紧凑技术）</p><p><strong>闲置空间的管理</strong></p><ul><li>位图表示法</li></ul><p>字位取值为0表示闲置，为1表示占用</p><p>空间成本固定，时间成本低，没有容错</p><ul><li>链表表示法</li></ul><p>将分配单元链接起来</p><p>空间成本取决于程序的数量，时间成本扫描速度较慢，有一点容错能力</p><p><strong>分配算法</strong></p><ul><li>首次适应（First Fit）</li></ul><p>从空白区域链的始端开始查找，选择第一个满足情况的空白快</p><p>低地址肯留下难以利用的小空间</p><ul><li>下次适应算法（Next Fit）</li></ul><p>从上次查找结束的地方开始，找到一个足够大的空白区将它划分后分配出去</p><p>利用更均衡，可能导致缺乏大空间</p><ul><li>最佳适应算法（Best Fit）</li></ul><p>大小最合适的储存区域</p><p>使得剩下的空闲区非常小，从而留下许多难以利用的碎片</p><ul><li>最坏适应算法（Worst Fit）</li></ul><p>总是寻找最大空白区</p><p>后续可能不能应对大空闲区</p><ul><li><p>索引搜索分配</p></li><li><p>快速适应分配（分类搜索）</p></li></ul><p>按空闲分区的大小进行分类，经常用到长度的空闲区设立单独的空闲区链表。系统为多个空闲链表设立 一张管理索引表。</p><p>优点：查找效率高，不会对任何分区产生分割，能保留大的分区，也不会产生内存碎片</p><p>缺点：算法复杂，分配分区时以进程为单位，一个分区只属于一个进程，造成浪费。</p><p><strong>伙伴系统</strong></p><p>伙伴系统是介于固定分区与可变分区的动态分区技术</p><p>规定：大小均为2的k次幂</p><p>内存释放首先将被释放块与其伙伴合并为一个大的空闲块，直到不能合并。</p><p>注意：如果两个储存快大小相等且地址相邻但不是由一个大块分裂出来的，则不可以被合并起来。</p><p>即会产生内碎片又会产生外碎片</p><p><strong>可重定位分区分配</strong></p><p>定时的或内存紧张时，移动某些已分配区中的信息，把储存空间中所有的空白区合并为一个大的连续区。</p><p>缺点：性能开销大，依赖DMA，间接寻址</p><p><strong>程序处理流程</strong></p><p>编译 - 链接 - 装入</p><p><strong>程序的链接</strong></p><ul><li>静态链接</li></ul><p>用户一个工程中所需的多个程序采用静态链接的方式链接在一起。当我们希望共享库的函数代码直接链接入程序代码中，也采用静态链接方式</p><ul><li>动态链接</li></ul><p>用于链接共享库代码。当程序运行中需要某些目标模块时，才对它们进行链接，具有高效且节省内存空间的优点。但相比静态链接， 使用动态链接库的程序相对慢</p><p><strong>程序装入</strong></p><p>未来保证程序地址可以改变，程序运行时才把相对地址转化为绝对地址</p><p>多重分区分配：一个作业往往由相对独立 的程序段和数据段组成，将这些片断分别 装入到存储空间中不同的区域内的分配方式。</p><ul><li>bss段 存放未初始化的全局变量</li><li>data段 存放已经初始化的全局变量</li><li>text段 代码段</li></ul><p><strong>程序链接</strong></p><p>将.o文件链接在一起，形成最终的可执行文件，链接时会扫描各个文件，将之前未填写的地址填上，形成一个可执行的文件。</p><p><strong>程序的装载与运行</strong></p><ul><li>shell调用fork系统调用</li><li>创建出一个子进程</li><li>子进程调用execve（）加载program</li></ul><p>一个segment在文件中的大小小于等于在内存中的大小</p><p><strong>程序装载过程</strong></p><ul><li>读取ELF头部的魔数确认是ELF文件</li><li>找到段表项</li><li>对于每个段表项解析出各个段应对被加载到虚拟地址、在文件中的偏移，以及在内存中的大小和在文件中的大小（段在文件中的大小小于等于内存中的大小）</li></ul><p>.text保存可执行文件的操作指令，包括局部变量</p><p>.data保存已初始化的全局变量和静态变量。 </p><p>.bss保存未初始化的全局变量和静态变量</p><p><strong>程序、进程和作业</strong></p><ul><li>程序：静止的，存放在磁盘上的可执行文件（静态概念）</li><li>进程：包括程序和程序处理对象，是程序对某个数据集的执行过程，是分配资源的基本单位。进程是竞争计算机系统有限资源的基本单位。 进程更能真实地描述并发，而程序不能。每一个进程由进程控制块PCB、程序和数据集合组成。<ul><li>完成操作系统功能的进程是系统进程</li><li>完成用户功能的是用户进程</li></ul></li><li>作业时计算机所做工作的集合。作业时任务实体，进程是执行实体</li></ul><p>一个程序可以作为多个进程的运行程序，一个进程也可以运行多个程序</p><h4 id="页式储存管理"><a href="#页式储存管理" class="headerlink" title="页式储存管理"></a>页式储存管理</h4><ul><li>页：把每个作业的地址空间分为一些大小相等的片成为页面或页</li><li>储存块：把主存的存储空间也分成与页面相同大小的片，这些片称为存储块，或称为页框。</li></ul><p><strong>纯分页系统</strong></p><p>不具备页面置换功能，必须把它的所有页一次装到主存的页框内；如果当时页框数不足，则该作业必须等待，系统再调度另外作业。</p><p>没有外碎片，每个内碎片不超过页大小</p><p>程序不必连续存放，便于改变程序占用空间大小</p><p><strong>页面大小分析</strong></p><ul><li>大<ul><li>优点：页面数减少，页表长度减少，内存减少，I/O减少</li><li>缺点：内碎片增大，不利于提高内存利用率</li></ul></li><li>小<ul><li>优点：减少页内碎片和总的内存碎片，有利于提高内存利用率</li><li>缺点：页面数增大，页表长度增加，内存增大，I/O增大</li></ul></li></ul><p>逻辑上相邻，物理上不一定相邻</p><ul><li>进程页表，每个进程都有的一个页表，描述进程占用的物理空间和逻辑排列顺序</li><li>物理页面表，整个系统有一个物理页面表，描述物理内存空间的的分配使用情况</li><li>请求表，整个系统有一个请求表描述系统内进程表的位置和大小</li></ul><p> 假定进程平均占用s个字节，页面大小是p个字节，一个页表项约占e字节 </p><ul><li>分页的开销为：<strong>se/p+p/2</strong></li></ul><p><strong>页表机制</strong></p><p>分级越多，内存空间确实使用少了，但访问时间大大增加。于是引入了MMU，组成如下</p><ul><li>页表Cache（TLB）</li><li>页表查找单元</li></ul><p><img src="tlb.png" alt="tlb"></p><p>某些TLB还包括地址空间标识码（ASID）</p><p>哈希页表、反置页表</p><p>反置页表介绍（解决消耗大量物理内存的问题）</p><ul><li>按照物理页号排序，表项的内容是逻辑页号 P 及隶属进程标志符 pid</li><li>大小只与物理内存的大小相关</li></ul><p><img src="reversepage.png" alt="反置页表"></p><p><strong>页保护</strong></p><ul><li>地址越界保护</li><li>设置保护位（只读等）</li></ul><p><strong>页共享</strong></p><p>分段储存管理</p><h4 id="段式储存管理"><a href="#段式储存管理" class="headerlink" title="段式储存管理"></a>段式储存管理</h4><p>页式储存信息的物理单元，段是信息的逻辑单位</p><p><strong>段式地址整体是二维的不连续的，但段内地址是从0开始的连续地址</strong></p><p><strong>信息保护</strong></p><ul><li>页式管理中，一个页面中可能装有 2 个不同的子程序段的指令代码，不能通过页面共享实现共享一个逻辑上完整的子程序或数据块</li><li>段式管理中，可以以信息的逻辑单位进行保护。</li></ul><p>逻辑地址结构：段号 + 位移量W ，但不一定是32位</p><p><img src="segement.png" alt="segement"></p><p><strong>可重入代码</strong></p><p>可重入代码(Reentrant Code) 又称为“纯代码”(Pure Code)，是一种允许多个进程同时访问的代码。为使各个进程所执行的代码完全相同， 绝对不允许可重入代码在执行中有任何改变。因此，可重入代码是一 种不允许任何进程对它进行修改的代码。</p><p>优点：分段系统已于实现段的共享，对段的保护也十分简单</p><p>缺点：地址转换耗时，空间问题</p><h4 id="段页式储存管理"><a href="#段页式储存管理" class="headerlink" title="段页式储存管理"></a>段页式储存管理</h4><p>分段和分页结合</p><p>先把用户程序分为若干个段，再把每个段分为若干页</p><p>格式：段号 - 段内页号 - 页内地址</p><p><strong>X86的段页式地址映射</strong></p><p>段映射机制，将逻辑地址映射到线性地址</p><p>页映射机制，将线性地址映射到物理地址</p><p>段描述结构都放在一个表 （Descriptor Table）中（GDT或LDT等）</p><p><strong>X86的控制寄存器</strong></p><ul><li>CR0中含有控制处理器操作模式和状态的系统控制标志；</li><li>CR1保留不用</li><li>CR2含有导致页错误的线性地址</li><li>CR3中含有页目录表物理内存基地址（PDBR）</li></ul><p><strong>虚拟内存管理</strong></p><ul><li>覆盖（时间，时间上扩展）</li></ul><p>把程序执行时并不要求同时装入主存的覆盖组成一组，称其为覆盖段，这个覆盖段被分配到同一个存储区域。这个存储区域称之为覆盖区，它与覆盖段一一对应。</p><ul><li>交换（借用，空间上扩展）</li></ul><p>是把暂时不用的某个（或某些）程序及其数据的部分或全部从主存移到辅存中去，以便腾出必要的存储空间</p><p><strong>局部性原理</strong></p><ul><li>时间局部性</li></ul><p>一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短时期内</p><ul><li>空间局部性</li></ul><p>即当前指令和邻近的几条指令， 当前访问的数据和邻近的数据都集中在一个较小区域内</p><p><strong>虚拟内存</strong></p><ul><li>按需装入</li><li>缺页装入</li><li>不用调出</li></ul><p>特征</p><ul><li>离散性</li><li>多次性</li><li>对换性</li><li>虚拟</li></ul><p>虚拟性以多次性和对换性为基础， 多次性和对换性必须以离散分配为基础</p><p>优点：</p><ul><li>较小的内存中执行较大的用户程序</li><li>容纳更多程序并发执行</li></ul><p>代价：牺牲CPU</p><p>限制：虚拟内存的最大容量有计算机的地址结构决定（32位-4G）</p><p><strong>实存与虚存</strong></p><p>实存</p><ul><li>分区</li><li>分页</li><li>分段</li><li>段页式</li></ul><p>虚存</p><ul><li>请求分页</li><li>请求分段</li><li>请求段页式</li></ul><p><strong>请求式分页</strong></p><p>虚拟存储系统：控制自动页面交换而用户页面意识不到的那个机构</p><p>进程的虚拟地址空间为进程在内存中存放的逻辑视图，因此一个进程的虚拟地址空间的大小和该进程的虚拟储存空间相同。（从0开始的编址的虚拟储存空间又称虚拟内存空间）</p><p>调入问题</p><ul><li><p>什么程序和数据调入</p><ul><li>OS的核心部分的程序和数据</li><li>正在运行的用户程序相关的程序和数据</li></ul></li><li><p>何时调入</p><ul><li><p>OS系统启动时调入</p></li><li><p>用户程序调用取决与策略</p><ul><li>预调页（pre-paging）</li></ul><p>预调页同时 将所需要的所有页一起调入内存，从而阻止 了大量的页错误</p><ul><li>按需调页</li></ul><p>当且仅当需要某页时才将该页调入内存的技术称为按需调页，使用懒惰交换（lazy swapper），按需调页需要使用备份存储，保存不在内存中的 页，通常为快速磁盘，用于和内存交换页的部分空间称为交换空间</p></li></ul></li><li><p>如何调入</p><ul><li>缺页错误处理机制</li></ul></li></ul><p><strong>缺页错误处理机制</strong></p><p><img src="pageFault.png" alt="pageFault"></p><p>处理过程</p><ul><li>陷入内核，保护现场</li><li>查找页面</li><li>权限检查，发生保护错误则杀死进程</li><li>查找空闲页框，如果没有则需要通过页面置换算法找到一个需要换出的页框</li><li>如果找到页框被修改了，则需要将修改的内容保护到磁盘上</li><li>页面干净后，操作系统将保存在磁盘上的页面内容复制到该页框</li><li>当磁盘中的页面内容全部装入页框后，<strong>向操作系统发送一个中断</strong>。操作系统更新内存中的页表项，将虚拟页面映射的页框号更新为写入的页框，并将页框标记为正常状态。（更新页表）</li><li>恢复进程</li><li>继续执行</li></ul><p><strong>页面置换策略</strong></p><ul><li>最优置换（OPT算法）</li></ul><p>置换未来最久不被使用的，最完美但是不现实</p><ul><li>先进先出（FIFO）</li></ul><p>性能较差，会出现Belady现象</p><p>FIFO算法的置换特征与进程访问内存的动态特征是矛盾的</p><ul><li>改进FIFO（Second Chance）</li></ul><p>每个页面增加一个访问位，A是FIFO队列中最旧的页面，且其放入队列后没有被再次访问，则A被立刻淘汰否则如果放入队列后被访问过，则将A移到FIFO队列头，并且将访问标志位清除。如果所有的页面都被访问过，则经过一次循环后就会按照FIFO的原则淘汰。</p><ul><li>改进FIFO（Clock），最近未使用算法</li></ul><p>使用环形队列</p><p>产生缺页错误时，当前指针指向C，如果C被访问过，则清除C的访问标志，并将指针指向D；如果C没有被访问过，则将新页面放入到C的位置，置访问标志， 并将指针指向D</p><ul><li>最近最少使用（LRU）</li></ul><p>性能接近最优算法，设置一个特殊的栈，保存当前使用的各个页面的页面号。每当进程访问某页面时，便将该页面的页面号从栈中移出，将它压入栈顶。栈底始终是最近最久未使用页面的页面号</p><ul><li>老化算法（AGING）</li></ul><p>为每个页面设置一个移位寄存器，并设置一位访问位R， 每隔一段时间，所有寄存器右移1位，并将R值从左移入。</p><p><strong>Belady现象</strong></p><p>分配的页面增多，缺页率反而提高的现象</p><p>进程的工作集：当前正在使用的页面集合</p><p>进程的驻留集：虚拟存储系统中，每个进程驻留在内存的页面集合或进程分到的物理页框集合</p><p><strong>抖动</strong></p><p>随着驻留内存的进程数目增加，或者说进程并发水平的上升，处理器利用率先是上升，然后下降。(常驻集减少，缺页率增加，频繁调页)</p><ul><li>局部置换策略</li><li>引入工作集算法</li><li>预留部分页面</li><li>挂起若干进程</li></ul><p><strong>写时复制（copy-on-write）</strong></p><p>资源的复制只有在需要写入的时候才进行。</p><p><strong>自映射</strong>！！！</p><p>详见作业3类似于不动点</p><p>可节省4KB的虚拟地址空间</p><h3 id="进程与并发程序"><a href="#进程与并发程序" class="headerlink" title="进程与并发程序"></a>进程与并发程序</h3><p><strong>并发与并行</strong></p><p>并发：直要都在各自起点与重点之间就是并发执行，程序的并发执行是指若干个程序（或程序段） 同时在系统中运行，这些程序（或程序段）的 执行在时间上是重叠的。</p><p>并行：两程序在同一时间量度下同时运行在不同的处理机上，则称这两个程序是并行执行的</p><p>并发可能是伪并行</p><p>顺序执行</p><ul><li>顺序性</li><li>封闭性</li><li>可再现性</li></ul><p>并发执行</p><ul><li>间断性</li><li>非封闭性</li><li>不可再现性</li></ul><p><strong>Bernstein条件</strong></p><p>以下条件同时成立时，S1与S2可并发</p><ul><li>$R(S1) \cap W(S2) = \emptyset$</li><li>$W(S1) \cap R(S2) = \emptyset$</li><li>$W(S1) \cap W(S2) = \emptyset$</li></ul><p><strong>进程</strong></p><p>进程是程序的一次执行</p><ul><li>动态性</li><li>并发性</li><li>独立性</li><li>异步性（进程之间相互制约）</li></ul><p>结构特征：程序段、数据段、进程控制块（PCB）</p><p><strong>PCB的内容</strong></p><ul><li>进程标识符</li><li>程序和数据的地址</li><li>现行状态</li><li>现场保留区</li><li>同步与互斥机制（用于实现同步互斥的信号量）</li><li>优先级</li><li>资源清单</li><li>链接字</li><li>其他信息</li></ul><p><strong>进程控制</strong></p><p>主要任务：创建和撤销进程，实现进程的状态转化（内核实现）</p><p>进程控制实现：原语（由若干条指令所组成的指令序列，来 实现某个特定的操作功能）</p><ul><li>指令序列执行是连续的不可分割</li><li>操作系统核心组成部分</li><li>必须在管态执行，且常驻内存</li></ul><p><strong>Fork（）函数</strong></p><p>在fork函数执行完毕后，如果创建新进程成功，则出 现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断 当前进程是子进程还是父进程。</p><p>fork被调用一次，但返回两次</p><p><strong>进程的状态</strong></p><ul><li>就绪：等待分配处理机资源</li><li>执行：占用处理机资源</li><li>阻塞：放弃处理机处于暂停状态</li></ul><p><img src="stateChange.png" alt="stateChange"></p><p>运行 $\rightarrow$ 就绪</p><ul><li>运行进程用完时间片</li><li>运行进程被中断，因为一高优先级进程处于就绪状态</li></ul><p>运行 $\rightarrow$ 阻塞</p><ul><li>进程所需资源必须等待</li><li>OS尚未完成服务</li><li>对一资源访问不能进行</li><li>初始化I/O必须等待</li><li>等待某一进程提供输出</li></ul><p>原语：由若干条指令所组成的指令序列，来实现某个特定的操作功能</p><ul><li>指令序列执行是连续的，不可分割</li><li>是操作系统核心组成部分</li><li>必须在管态（内核态）下执行，且常驻内存</li></ul><p><strong>线程</strong></p><p>进程包括了两个概念：资源拥有者和可执行单元</p><p>资源拥有者为进程，可执行单元为线程</p><p>线程：将资源与计算分离，提高并发效率</p><ul><li>减小线程切换开销</li><li>提高进程内的并发程度</li><li>共享资源</li></ul><p>线程是进程中的一个实体，是一个CPU调度和分配的单元</p><p>容易创建和撤销</p><p>一个进程可以拥有多个线程，而一个线程同时只能被一 个进程所拥有</p><p><strong>进程是资源分配的基本单位，线程是处理机调度的基本单位</strong></p><p><strong>线程安全</strong></p><p>多个线程调用同一个对象的行为都可以获得正确的结果</p><p>可重入不一定线程安全，线程安全不一定可重入</p><p><strong>Linux下的线程创建</strong></p><p>fork用于创建普通进程，clone可用于创建线程</p><p>fork和clone都调用do_fork函数执行创建进程的操作</p><p><strong>用户级线程</strong></p><ul><li>线程切换与内核无关，易优化，例子：java threads，但是易阻塞</li></ul><p><strong>内核级线程</strong></p><ul><li>内核级线程就是kernel有 好几个分身,一个分身可 以处理一件事</li><li>内核可以在多个处理器上调度一个进程的多个线程实现同步并执行，但切换过程会降低效率</li></ul><p><strong>线程模型</strong>（王道P45）</p><ul><li>Many-to-One </li></ul><p>将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。线程管理在用户空间进行，效率较高，但某个线程在使用内核服务被阻塞时i，整个进程都会被阻塞</p><ul><li>One-to-One</li></ul><p>将每个用户级线程映射到一个内核级线程。并发能力抢，但创建线程开销大，没创建一个内核级线程都需要创建一个内核级线程与其对应</p><ul><li>Many-to-Many</li></ul><p>将 n 个用户级线程映射到 m 个内核级线程上，要求 m &lt;= n。</p><p><strong>临界资源与临界区</strong></p><p>临界资源：一次仅允许一个线程访问的资源称为临界资源</p><p>临界区：每个进程中访问临界资源的那段代码</p><p><strong>互斥与同步</strong></p><ul><li>进程互斥，间接制约关系，访问是无序访问，两个或两个以上的进程，不能同时进入关于同一组共享变量的临界区域</li><li>进程同步，直接制约关系，通过机制实现有序访问</li></ul><p><strong>互斥区管理条件</strong></p><ul><li>没有进程在临界区是，想进入临界区的进程可以进入</li><li>任何两个进程不能同时进入临界区</li><li>当一个进程在它的临界区外面外面时，不能妨碍其他进程进入临界区</li><li>任何一个进程进入临界区的要求应该在有限的时间内得到满足</li></ul><p><strong>设计原则</strong></p><ul><li>空闲让进</li><li>忙则等待</li><li>有限等待</li><li>让权等待</li></ul><p><strong>面包店算法</strong></p><p>设置一个发号器，按由小到大的次序发放号码。进程进入临界区前先抓取一个号码，然后按号码从小到大的次序依次进入临界区。若多个进程抓到相同的号码则按进程编号依次进入</p><p><strong>硬件方案</strong></p><ul><li>中断屏蔽</li></ul><p>使用“开关中断”，简单但不适用于多CPU系统，可能会造成很大的性能损失</p><ul><li>test and set指令</li></ul><p>在多进程可同时 存取内存的情况下，如果一个进程正在执行检查并设置， 在它执行完成前，其它的进程不可以执行检查并设置</p><ul><li>swap指令</li></ul><p>和ts类似会循环交换两个变量</p><p><strong>以上软硬件方案共性问题</strong></p><ul><li>忙等待：浪费CPU</li><li>优先级反转：低优先级进程先进入临界区，高优先级进程一直忙等</li></ul><p><strong>信号量</strong></p><p>信号量只能通过初始化和两个标准的原语来访问，作为OS核心代码执行， 不受进程调度的打断</p><ul><li>必须置一次且只能置一次初值</li><li>只能由P、V操作来改变</li></ul><p>物理意义</p><ul><li>S.value为正时表示资源的个数</li><li>S.value为负时表示等待进程的个数</li><li>P操作分配资源，如果无法分配则阻塞</li><li>V操作释放资源，如果有等待进程则唤醒</li></ul><p>简单，且表达能力强大（PV操作可解决任何同步互斥问题），但是不够安全，P.V操作使用不当会出现死锁；遇到复杂同步互斥问题时实现复杂</p><p><strong>信号量级机制</strong></p><ul><li>AND信号量级机制</li></ul><p>将进程需要的所有共享资源一次全部分配给它；待该进程使用完后再一起释放。</p><p><strong>管程</strong></p><p>管程：把分散的临界区集中起来，为每个可共享资源设计一个专门机构来统一管理各进程对该资源的访问，这个专门机构称为管程</p><p>一个管程是由过程、变量及数据结构等组成的一个集合，它们组成一个特殊的模块或者软件包</p><p>互斥：任一时刻，管程中只能有一个活跃进程</p><p>管程是一种语言概念，由编译器负责实现互斥</p><ul><li>操作原语（互斥）：对控制变量和临界资源进行操作的一组原语过程（程序代码），是访问该管程的唯一途径。</li><li>条件变量（同步）：每个独立的条件变量是和进程需要等待的某种原因相联系的，当定义一个条件变量x时，系统就建立一个相应的等待队列</li></ul><p>条件变量与信号量的区别</p><ul><li>条件变量的值不可增减，P-V操作的信号量值可增减</li><li>访问条件变量必须拥有管程的锁</li></ul><p><strong>进程通信</strong></p><ul><li>低级通信</li></ul><p>只能传递状态和整数值（控制信息），包括进程互斥和同步所采用的信号量和管程机制。传递信息量少，编程复杂</p><ul><li>高级通信</li></ul><p>适用于分布式系统，基于共享内存的多处理机系统，单处理机系统，能够传送任 意数量的数据，可以解决进程的同步问题和通信问题，主要包括三类：管道、共享内存、消息系统</p><p><strong>优先级继承</strong></p><p>也就是，高优先级进程TH在等待低优先级的线程TL继承占用的竞争资源时，为了使TH能够尽快获得调度运行，由操作系统把TL的优先级提高到TH的优先级，从而让TL以TH的优先级参与调度，尽快让TL执行并释放调TH欲获得的竞争资源，然后TL的优先级调整到继承前的水平，此时TH可获得竞争资源而继续执行。</p><p><strong>信号量集</strong></p><p>SP(S, d, d)：表示每次申请d个资源， 当资源数量少于d个时，便不予分配。</p><p>SP(S, 1, 1)：表示互斥信号量。</p><p>SP(S, 1, 0)：可作为一个可控开关(当S≥1 时，允许多个进程进入临界区；当S=0时禁止 任何进程进入临界区)</p><p><strong>共享内存</strong></p><p>最有用的进程之间的通信方式，也是最快的，同一块物理地址映射到A、B各自的地址进程空间，但是收到同步机制约束</p><p><strong>无名管道</strong></p><p>半双工的（只能沿着一个方向）</p><p>只能用于父子进程或者兄弟进程（有亲缘关系的进程）</p><p><strong>有名管道</strong></p><p>即使与FIFO的创建进程不存在 亲缘关系的进程，只要可以访问该路径，就能 够彼此通过FIFO相互通信（能够访问该路径 的进程以及FIFO的创建进程之间），因此， 通过FIFO不相关的进程也能交换数据。解决了无名管道相关的问题。</p><h4 id="经典同步互斥问题"><a href="#经典同步互斥问题" class="headerlink" title="经典同步互斥问题"></a><strong>经典同步互斥问题</strong></h4><p><strong>生产者-消费者模型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c">Semaphore full = <span class="hljs-number">0</span>;<br>Semaphore empty = n;<br>Semaphore mutex = <span class="hljs-number">1</span>;<br>ItemType buffer[<span class="hljs-number">0.</span>.n<span class="hljs-number">-1</span>];<br><span class="hljs-type">int</span> in = <span class="hljs-number">0</span>, out =<span class="hljs-number">0</span>;<br>producer() &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        生产产品nextp;<br>        P(empty);<br>        P(mutex);<br>        buffer[in] = nextp;<br>        in = (in + <span class="hljs-number">1</span>) MOD n;<br>        V(mutex);<br>        V(full);<br>    &#125;<br>&#125;<br><br>consumer() &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        P(full);<br>        P(mutex);<br>        nextc = buffer[out];<br>        out = (out + <span class="hljs-number">1</span>) MOD n;<br>        V(mutex);<br>        V(empty);<br>        消费nextc中的产品<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>读写者问题</strong></p><p>读写公平</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>semaphore mutex = <span class="hljs-number">1</span>;<br>semaphore rw = <span class="hljs-number">1</span>;<br>semaphore w = <span class="hljs-number">1</span>;<br>writer () &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        P(w);<br>        P(rw);<br>        write;<br>        V(rw);<br>        V(w);<br>&#125;<br>&#125;<br>reader() &#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        P(w);<br>        P(mutex);<br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>            P(rw);<br>        &#125;<br>        count ++;<br>        V(mutex);<br>        V(w);<br>        read;<br>        P(mutex);<br>        count--;<br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>            V(rw);<br>        &#125;<br>        V(mutex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>读者优先</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;                  <span class="hljs-comment">//⽤用于记录当前的读者数量量 </span><br><br>semaphore mutex = <span class="hljs-number">1</span>;            <span class="hljs-comment">//⽤用于保护更更新count变量量时的互斥 semaphore rw = 1;               //⽤用于保证读者和写者互斥地访问⽂文件 </span><br><br>writer () &#123;                     <span class="hljs-comment">//写者进程</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;        <br>        P(rw);                  <span class="hljs-comment">//互斥访问共享⽂文件        </span><br>        Writing;                <span class="hljs-comment">//写⼊入        </span><br>        V(rw);                 <span class="hljs-comment">//释放共享⽂文件    </span><br>    &#125;<br>&#125;<br><br>reader () &#123;                     <span class="hljs-comment">// 读者进程</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        P(mutex);               <span class="hljs-comment">//互斥访问count变量量        </span><br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;       <span class="hljs-comment">//当第⼀一个读进程读共享⽂文件时 </span><br>            P(rw);              <span class="hljs-comment">//阻⽌止写进程写 </span><br>        &#125;<br>        count++;                <span class="hljs-comment">//读者计数器器加1        </span><br>        V(mutex);               <span class="hljs-comment">//释放互斥变量量count        </span><br>        reading;                <span class="hljs-comment">//读取        </span><br>        P(mutex);               <span class="hljs-comment">//互斥访问count变量量       </span><br>        count--;                <span class="hljs-comment">//读者计数器器减1        </span><br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;       <span class="hljs-comment">//当最后⼀一个读进程读完共享⽂文件 </span><br>            V(rw);              <span class="hljs-comment">//允许写进程写  </span><br>        &#125;<br>        V(mutex);               <span class="hljs-comment">//释放互斥变量量count </span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>写者优先</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> readercount = <span class="hljs-number">0</span>;            <span class="hljs-comment">//⽤用于记录当前的读者数量量 </span><br><span class="hljs-type">int</span> writercount = <span class="hljs-number">0</span>;            <span class="hljs-comment">//⽤用于控制rsem信号量量 </span><br><br>semaphore rmutex = <span class="hljs-number">1</span>;           <span class="hljs-comment">//⽤用于保护更更新readercount变量量时的互斥 semaphore wmutex = 1;           </span><br><span class="hljs-comment">//⽤用于保护更更新writercount变量量时的互斥</span><br>semaphore rw = <span class="hljs-number">1</span>;               <span class="hljs-comment">//⽤用于保证读者和写者互斥地访问⽂文件 </span><br>semaphore rsem = <span class="hljs-number">1</span>;             <span class="hljs-comment">//当⾄至少有⼀一个写者申请写数据时互斥新的读者进⼊入读数据</span><br><br>writer() &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        P(wmutex);<br>        <span class="hljs-keyword">if</span> (writercount == <span class="hljs-number">0</span>) &#123;            <br>            P(rsem);        <br>        &#125;       <br>        writercount++;        <br>        V(wmutex);        <br>        P(rw);        <br>        writing;        <br>        V(rw);        <br>        P(wmutex);        <br>        writercount--;        <br>        <span class="hljs-keyword">if</span> (writercount == <span class="hljs-number">0</span>) &#123;            <br>            V(rsem);       <br>        &#125;        <br>        V(wmutex);    <br>    &#125; <br>&#125;<br>   <br>reader() &#123;   <br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123; <br>        P(rsem);        <br>        P(rmutex);        <br>        <span class="hljs-keyword">if</span> (readercount == <span class="hljs-number">0</span>) &#123;            <br>            P(rw);       <br>        &#125;        <br>        readercount++;       <br>        V(rmutex);        <br>        V(rsem);        <br>        reading;        <br>        P(rmutex);        <br>        readercount--;       <br>        <span class="hljs-keyword">if</span> (readercount == <span class="hljs-number">0</span>) &#123;           <br>            V(rw);        <br>        &#125;         <br>        V(rmutex);   <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><p><strong>什么是CPU调度</strong></p><p>CPU 调度的任务是控制、协调多个进程对CPU 的竞争。也就是按照一定的策略（调度算法），从就绪队列中选择一个进程，并把CPU 的控制权交给被选中的进程。</p><p><strong>调度种类</strong></p><ul><li>高级调度（宏观调度、作业调度）：从用户工作流程的角度，一次提交的若干个作业，对每一个作业进行调度，时间上通常是分钟、小时或者天。</li><li>中级调度（内外存交换）：由于指令和数据必须在内存里才可以被CPU直接访问，从存储器资源的角度，将进程的部分或全部换出到外存上，将当前所需部分换入到内存</li><li>低级调度（微观调度，进程调度，线程调度）：从CPU资源的角度，执行的单位，时间上通常是毫秒。因为执行频繁，要求实现时要达到高效率（进行调度的时机有：进程被创建时（执行新进程还是继续执行父进程）、结束时、阻塞时(I/O或者信号量阻塞)、主动让出CPU时、时钟中断发生时，进行系统调用时，发生陷阱时……）<ul><li>非抢占式</li><li>抢占式<ul><li>时间片原则</li><li>优先权原则</li><li>短作业优先原则</li></ul></li></ul></li></ul><p><strong>切换操作</strong></p><ul><li>保留处理器上下文，包括程序计数器和其他寄存器</li><li>更新当前PCB</li><li>将进程移到合适队列（就绪，阻塞）</li><li>选择另一要执行进程</li><li>更新被选中的PCB</li><li>装入CPU</li></ul><p><strong>性能指标</strong></p><p>周转时间：作业从提交到完成（得到结果） 所经历的时间</p><p>响应时间：：用户输入一个请求（如击键）到 系统给出首次响应（如屏幕显示）的时间－ 分时系统</p><p>截至时间：类似于周转时间</p><p>吞吐量：单位时间内完成的作业数和作业本身特性和调度算法都有关系——批处理系统</p><p>处理机利用率：忙碌时间/总时间</p><p><strong>进程分类</strong></p><ul><li>资源需求<ul><li>CPU密集型</li><li>I/O密集型</li></ul></li><li>交互性<ul><li>批处理进程<ul><li>无需交互，在后台进行</li><li>不需要很快的响应</li><li>编译器、科学计算都是典型的批处理程序</li></ul></li><li>交互式进程<ul><li>交互频繁，需要等待用户输入</li><li>相应时间要快，平均延迟要低于50-150ms</li><li>典型：Word，触控GUI</li></ul></li><li>实时进程<ul><li>有实时要求</li><li>响应时间短且稳定</li><li>典型：视频，控制类</li></ul></li></ul></li></ul><h5 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a><strong>调度策略</strong></h5><p><strong>批处理系统的调度策略</strong></p><ul><li>先来先服务（FCFS）：典型FIFO，比较有利于长作业，不利于短作业，利于CPU繁忙的作业，不利于I/O繁忙的作业</li><li>短作业优先（SJF/SPN）：对长作业不利，未能按照作业紧迫程度进行</li><li>最短剩余时间优先（SRTF）：改为了抢占式，缺点：源源不断的短任务到来可能使得长任务长时间不得运行从而导致“饥饿”</li><li>最高响应比（HRRF）：响应比RP(响应优先级) = $1 + 已等待时间/要求等待时间$ ，    保证了饥饿现象不会出现，但是计算响应比会有一定开销</li></ul><p><strong>交互式系统的调度策略</strong></p><ul><li>时间片轮转（Round Robin）：排队-轮转-中断-抢占-出让<ul><li>时间片过长，退化为FCFS，过短上下文切换次数增加，响应时间长</li><li>响应时间 = 进程数目 * 时间片</li><li>应当使用户输入通常在一个时 间片内能处理完，否则会使响应时间、平均周转 时间和平均带权周转时间延长</li></ul></li><li>优先级算法<ul><li>静态优先级，创建进程时就确定</li><li>动态优先级：在创建进程时赋予的优先级，在进程运行 过程中可以自动改变，以便获得更好的调度性能，如<ul><li>就绪队列中等待时间时间延长则优先级提高</li><li>进程每执行一个时间片就降低优先级</li></ul></li></ul></li><li>多级队列：引入多个就绪队列，通过各队列的区别对待达到一个综合调度<ul><li>不同队列可有不同的优先级、时间片长度、调度 策略等；在运行过程中还可改变进程所在队列。 如：系统进程、用户交互进程、批处理进程等</li><li>I/O进程：让其进入最高优先级队列，以及时响 应I/O交互。通常执行一个小时间片，要求可处理 完一次I/O请求的数据，然后转入到阻塞队列。</li><li>计算型进程：每次都执行完时间片，进入更低级队 列。最终采用最大时间片来执行，减少调度次数。</li><li>优先级倒置（优先级：A&gt;B&gt;C，A，C共享临界区，C被B抢占CPU，A也只能被迫等着）的解决——优先级置顶（C继承A的优先级）</li></ul></li></ul><h4 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h4><p>资源利用率较低</p><p>一种时间起着主导作用的系统，计算机必须在一个确定的时间范围内恰当作出反应</p><ul><li>硬实时系统（汽车、飞机控制系统）</li><li>软实时系统（偶尔可以不满足，视频/音频）</li></ul><p><strong>实时调度</strong></p><ul><li>要求更详细的调度信息</li><li>采用抢先式调度</li><li>快速中断响应</li><li>快速任务分派</li></ul><p>前提：任务集已知</p><ul><li>静态固定分配</li><li>单调速率调度（优先级静态固定分配），静态、抢先式调度</li></ul><p>优先级与周期成反比</p><ul><li><p>最早截止期优先EDF，任务的绝对截至时间越早，优先级越高</p></li><li><p>最低松弛度优先算法LLF，任务的紧急度越高，其优先级越高，并使之优先执行。松弛度（Laxity） = 进程截至时间-本身剩余运行时间-当前时间</p></li></ul><p><strong>多处理机调度</strong></p><p>相比单处理机更加重视整体运行调度，有着更多样的调度算法，调度单位广泛采用线程</p><p><strong>非对称多处理系统（AMP）</strong></p><p>各个处理器的地位不一样，有潜在的不可靠性</p><ul><li>神威·太湖之光超级计算机</li><li>国产申威SW26010</li></ul><p><strong>对称式多处理系统（SMP）</strong></p><p>各个处理器地位相同</p><p>调度算法分为集中控制（静态和动态分配）和分散控制（自调度）</p><ul><li><p>静态分配，每个CPU设立一个就绪队列，进程从开始到结束都在同一个CPU上，调度算法开销小但是容易出现忙闲不均</p></li><li><p>动态分配：所有CPU 采用一个公共就绪队列，队首进程每次分派到当前空闲的CPU上执行。可防止系统中多个处理器忙闲不均</p></li><li>自调度：整个系统采用一个公共就绪队列，每个处理机都可 以从队列中选择适当进程来执行，不需要专门的处理机从事任务分配，但是存在队列同步开销、缓存更新开销、线程协作开销</li><li>成组调度： 将一个进程中的一组线程，每次分派时同时到一组 处理机上执行，在剥夺处理机时也同时对这一组线 程进行。提高了并行度。</li><li>专用处理机调度：为进程中的每个线程都固定分配一个CPU， 直到该线程执行完成。适用于：CPU数量众多的高度并行系统， 单个CPU利用率已不太重要。</li></ul><p><strong>Linux调度</strong></p><ul><li>Linux 2.4：O(n)调度器 (Linus) </li><li>Linux 2.6.0：O(1)调度器 每个CPU维护一个自己的运行队列</li><li>Linux 2.6.23：CFS（Completely  Fair Scheduler，完全公平调度器）</li></ul><p><strong>死锁专题</strong></p><p>定义：一组进程中，每个进程都无限等待被该组进程中其他进程所占有的资源，在无外力接入条件下，将因永远无法分配到资源而无法运行的现象</p><p>发生原因：资源竞争，并发执行的顺序不当</p><ul><li>可剥夺资源：CPU、内存等</li><li>非可剥夺资源：磁带机，打印机</li><li>临时性资源：由一个进程产生被另一个进程使用，段时间后便无用的资源，也叫消耗性资源，如消息，中断等</li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>两个以上的进程相互等待一个永远不可能发生的条件，形成僵持局面</p><p><strong>死锁产生的四个必要条件</strong></p><ul><li>互斥条件：进程对资源的排他性使用</li><li>请求且占有条件：进程已经占有至少一个资源但又有新的资源请求</li><li>不可剥夺条件：进程已获得的资源未使用完前不可以被剥夺</li><li>环路等待条件：发生死锁时必然存在一个进程— —资源的环形链</li></ul><p>活锁：任务没有被阻塞但是某一条件不满足，一直重复尝试、失败</p><p>饥饿：某些进程由于资源分配策略不公平导致的长时间等待</p><p><strong>死锁预防</strong></p><ul><li>打破互斥条件：允许进程同时访问某些资源</li><li>打破申请且占有条件，只有当系统能够满足当前进程 的全部资源需求时，才一次性地将所申请 的资源全部分配给该进程，此方法资源利用率低，进程并发率低</li><li>打破不可剥夺条件</li><li>打破循环等待条件，把资源事先分类编号，按号分配，使进程在申请， 占用资源时不会形成环路，造成的开销大</li></ul><p><strong>死锁避免</strong></p><p>死锁预防是静态策略，死锁避免是动态策略。</p><p>在分配资源时判断是否会出现死锁，有则加以避免</p><p><strong>安全序列</strong></p><p>一个进程序列是安全的，是指若对于每一个 进程Pi，它需要的附加资源可以被系统中当 前可用资源加上所有进程Pj（j &lt; i）当前占 有资源之和所满足，则为一个安全序列</p><p>如果系统不存在这样的一个不安全状态，系统就是不安全状态，不安全状态就可能产生死锁</p><p><strong>银行家算法</strong></p><p>可利用资源向量Available：m维向量</p><p>最大需求矩阵Max：n*m矩阵</p><p> 分配矩阵Allocation： n*m矩阵</p><p>需求矩阵Need：n*m矩阵</p><p>Need(i, j)= Max(i, j)-Allocation(i, j)    </p><ul><li>设置变量</li><li>找到满足条件进程</li><li>进程获得资源，完成后则释放</li><li>如果最后所有进程都可以Finish，则系统处于安全状态</li></ul><p><strong>死锁检测</strong></p><p>主要是检查是否有循环等待</p><p><strong>资源分配图（RAG）算法</strong></p><p>从进程P 到资源R的边表示P正因请求R而处于等待状态</p><p>根据图是否有环路判断</p><p>封锁进程：某个进程由于请求了超过了系统中现有的未分配资源数目的资源，而被系统封锁的进程。</p><p>如果RAG中存在封锁进程可以进行以下化简</p><p>将请求边变为分配边，最后不断删去分配边不断进行使其成为孤立节点</p><p><strong>死锁定理</strong></p><p>系统中某个时刻t为死锁状态的充要条件是t时刻系统的资源分配图是不可完全化简的</p><p><strong>死锁解除</strong></p><ul><li>撤销进程</li><li>剥夺资源</li></ul><h3 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h3><p>类型</p><ul><li>传输速度：低速、中速、高速</li><li>信息交换单位：<strong>块设备</strong>和<strong>字符设备</strong></li><li>共享属性：独占设备、共享设备、虚拟设备</li></ul><p>设备与控制器之间的接口</p><ul><li>数据信号</li><li>控制信号</li><li>状态信号</li></ul><p><strong>设备</strong></p><ul><li>设备固有属性：独享、共享、虚拟设备</li><li>设备独立性<ul><li>用户设备：用户程序用户程序使用逻辑设备名，系统实际执 行时，映射到物理设备名</li><li>除了直接与设备打交道的低层软件外，其 余部分软件不依赖于设备，可提高设备管理软件效率</li></ul></li></ul><p><strong>设备控制器</strong></p><ul><li>接受和识别CPU命令</li><li>用于实现CPU对I/O设备的控制</li></ul><p>I/O控制技术</p><ul><li>程序控制I/O：又称轮询或查询方式I/O，向CPU发指令使其进入忙等状态</li><li>中断驱动，好处在于CPU不必等待，可以处理不确定事件，但是浪费CPU时间</li><li>DMA：直接储存器访问方式，由一个专门的控制器来完成数据从内存到设备或设备到内存的传输工作</li></ul><p>由若干寄存器完成内存和外设之间的成批的数据交换，CPU只需干预I/O操作的开始和结束，但是数据的传输方向、存放地址等都需要CPU控制，占用CPU时间，而且每个设备都占用一个DMA控制器，每增加一个设备都需要新的DMA控制器中断适用于对异常事件的处理，而DMA适用于对数据库的传输</p><ul><li>通道：类似于DMA</li></ul><p>通道传输将对一个数据块的读写干预减少为对一组数据块的干预，一个通道可以同时控制多种设备，与DMA相比降低了CPU干预，但是费用较高</p><p>字节多路通路、选择通路、成组多路通路……</p><p><strong>缓冲技术</strong></p><p>匹配CPU与外设不同处理速度、减少对CPU的中断次数、提高CPU与I/O设备之间的并行性</p><ul><li>单缓冲</li><li>双缓冲，CPU和外设处理速度可以相差较大</li><li>缓冲池，整体利用率较高<ul><li>空闲缓冲区</li><li>输入缓冲区</li><li>输出缓冲区</li></ul></li></ul><p><strong>设备分配</strong></p><p>解决外设资源有限问题</p><ul><li>进程之间切换使用外设，如键盘和鼠标</li><li>使用虚拟设备隔开外设和应用程序，只允许虚拟设备使用外设</li></ul><ul><li>设备控制表（DCT）：每个设备一张描述设备特性和状态，控制器的连接情况</li><li>控制器控制表（COCT）：每个设备控制器一张，描述I/O控制器的配置和状态</li><li>通道控制器（CHCT），每个通道一张，描述通道工作状态</li><li>系统设备表（SDT），系统内一张描述设备资源的状态</li></ul><p><strong>考虑因素</strong></p><ul><li>设备属性：独享、共享、虚拟设备</li><li>设备分配算法：</li><li>设备分配中的安全性问题：死锁问题<ul><li>安全分配（同步），CPU和I/O串行工作，效率低</li><li>不安全分配（异步）：需要进行安全性检查，但进程执行效率相对较高</li></ul></li><li>设备独立性：用户设备独立性、I/O软件的设备独立性</li></ul><p><strong>设备分配</strong></p><ul><li>单通路：一个设备对应一个控制器，一个控制器对应一个通道</li><li>多通路：一个设备与几个控制器相连，一个控制器与几个通道相连</li></ul><p>分配设备 $\rightarrow$ 分配设备控制器 $\rightarrow$ 分配通道</p><p><strong>假脱机技术（SPOOLing）</strong></p><p><strong>把独享设备转化为具有共享特征的虚拟设备从而提高设备利用率</strong></p><p>应用程序实际上是从SPOOLing程序的缓冲池中读出数据或把数据送入缓冲池，而不是跟实际的外设进行I/O操作</p><p><img src="spooling.png" alt="spooling"></p><p>SPOOLing程序接受应用程序的输出数据并加以缓冲，在以后适当的时候输出到外设</p><p>又被称为虚拟I/O</p><p>应用程序的虚拟I/O比实际I/O速度提高</p><p><strong>设备驱动程序的组成</strong></p><ul><li>自动配置和初始化子程序：检测硬件设备是否存在，是否正常</li><li>服务于I/O请求的子程序：调用该子程序是系统调用的结果，执行该部分程序时，系统仍认为是和调用进程属同一个进程，只是由用户态变成核心态</li><li>中断服务子程序：系统来接收硬件中断，再由系统调用中断服 务子程序。因为设备驱动程序一般支持同一类型的若干设备， 所以一般在系统调用中断服务子程序的时候，都带有一个或多个参数，以唯一标识请求服务的设备</li></ul><p><strong>设备驱动的共性</strong></p><ul><li>核心代码：设备驱动是内核的一部分</li><li>核心接口：必须为内核提供一个标准接口</li><li>核心机制和服务：可以使用标准的内核服务如内存分配、 中断发送和等待队列等</li><li>动态可加载：在内核模块发出加载请求时加载；在不再使用时卸载，内核能有效地利用系统资源</li><li>动态性：系统启动及设备驱动初始化时将查找它所控制的 硬件设备。若某个设备的驱动为一个空过程时，不会对系统造成危害，只是会占用少量系统内存</li></ul><p><strong>缓存I/O</strong></p><p>系统缓冲区管理结构</p><ul><li>系统缓冲区</li><li>字符队列</li></ul><p><strong>块设备的缓冲区管理</strong></p><p>缓存块是缓存使用的基本单位， 与外设数据块对应；每个缓存块由两部分组成：缓冲控制块和缓冲数据区。前者用于缓冲区管理，而后者用于存放数据</p><ul><li>缓冲控制块：</li></ul><p>也称为缓冲首部(buffer header)。 内容包括：逻辑设备号，物理块号，缓冲区状态 （如空闲、延迟写、锁定等标志），指向缓冲数据 区的指针，哈希队列的前后向指针，空闲队列的前后向指针。</p><p><strong>缓冲区检索和置换方式</strong></p><ul><li>设备缓冲区队列为Hash队列：加快检索的速度</li><li>缓存块可同时链入设备缓冲区队列和空闲缓冲队列：一个缓存块在分配给一个外设后，一直与该外设相关 (既使该缓存块在空闲缓冲队列中)，直到分配给另一 外设</li></ul><p><strong>缓冲区的数据读写</strong></p><ul><li>外设和核心缓冲区<ul><li>一般读和预先读：一般读是指从外设读入指定的数据块；预先读是在一般读的基础上异步读入另一块以提高读取速度</li><li>一般写（立即启动I/O并等待完成）、异步写（立即启动I/O而不等待完成以提高写速度）、延迟写（不立即启动I/O以减少不必要的I/O操作，但系统故障时会产生数据错误）</li></ul></li><li>核心缓冲区和进程的用户区：使用DMA方式在缓存与用户进程间进行内存到内存的数据传送，可以节约CPU时间，但要占用总线</li></ul><p><strong>字符设备的缓冲区管理</strong></p><p>字符缓冲区采用缓冲池结构，构成一个字符队列(Character Queue)，它不同于块设 备缓冲区的多次读写，缓冲区中每个字符只能读一次，读后被破坏（用C语言的知识很容易理解）每个缓冲区大小为70字节</p><p><img src="cblock.png" alt="cblock"></p><p><strong>流机制</strong></p><ul><li>流的引入：流的引入是为了<strong>解决内核与驱动程序抽象层次过高</strong>，而引起的驱动程序功能大量重复。 它可提供一个完全基于消息的模块化的驱动程序 编写方法。</li><li>流的定义：流是一组系统调用、内核资源和创建、 使用及拆除流的例程的集合，构成一个数据传输 通道，两端为读队列和写队列。</li><li>流的结构：上行流和下行流</li></ul><p><strong>NT的I/O系统结构</strong></p><p>I/O子系统：实现文件化的I/O函数</p><ul><li>通常的打开、关闭和读写函数；</li><li>异步I/O：应用进程在发出I/O请求后，不需等待I/O完成，可继续其它工作；</li><li>映射文件I/O：把文件作为进程虚拟空间的一 部分进行直接访问；</li><li>快速I/O：不通过I/O管理器，直接向驱动程序 发出I/O请求</li></ul><p>采用分层驱动思想</p><ul><li>文件系统驱动程序：实现文件I/O请求到物理设备I/O请求的转换；</li><li>文件系统过滤器驱动程序：截取文件系统驱动程序产生的I/O 请求，执行另外处理，并发出相应的低层I/O请求。如：容错 、磁动程序；</li><li>类驱动程序(class driver)：实现对特定类型设备的I/O请求 处理。如：磁盘、磁带、光盘等；</li><li>端口驱动程序(port driver)：实现对特定类型I/O端口的I/O 请求处理。如：SCSI接口类型； </li><li>小端口驱动程序：把对端口类型的一般I/O请求映射到适配器类型；硬件设备驱动程序(hardware device driver)：直接控制和访问硬件设备；</li></ul><p><strong>设备驱动程序的组成</strong></p><ul><li>初始化例程：I/O管理器在加载驱动程序时，利用 初始化例程创建系统对象；</li><li>调度例程集：实现设备的各种I/O操作。如：打开、 关闭、读取、写入等；</li><li>启动I/O例程：初始化与设备间的数据传输； </li><li>中断服务例程(ISR)：设备(软)中断时的调用例程； 要求快速简单； </li><li>中断服务延迟过程调用(DPC)例程：以内核线程方 式执行ISR执行后的中断处理工作</li></ul><h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a><strong>磁盘管理</strong></h3><p><img src="diskStruct.png" alt="diskStruct"></p><p>目前的磁盘采用的比较多的有顺序映射，绝大多数磁盘都存在一些缺陷扇区，因此映射必须用其他空闲扇区来代替这些缺陷扇区</p><p>对于磁盘，每个磁道的扇区数不是常量</p><p> <strong>访问时间</strong></p><ul><li>寻道时间 = m*n +s(s是磁盘启动世界，n是移动了n条磁道)</li><li>旋转延迟时间 = 1/（2*r）,r为旋转速度</li><li>传输时间= b/（r*N），b是每周期读取字节数</li><li>总访问时间 = 寻道时间 + 旋转延迟时间 + 传输时间</li></ul><p><strong>磁盘调度算法</strong></p><ul><li>先来先服务（FCFS）</li><li>最短寻道时间优先算法（SSTF）</li><li>扫描算法（SCAN）</li><li>循环扫描算法（C-SCAN）</li><li>LOOK算法</li></ul><p><strong>Flash Disk 闪存专题</strong></p><p>NAND：地址分为块号、块内页号、页内字节号</p><p>NOR：地址线多且储存单元并列排布，可以实现一次性的直接寻址</p><p>Flash Disk：低功耗、大容量、数据访问速度高</p><p>但是可靠性不佳</p><p><strong>RAID</strong></p><p>数据冗余技术提高磁盘可靠性</p><p>成本低、功耗小、传输速率高、容错高</p><p><strong>数据并行交叉存取</strong></p><p>把文件分成多个条带写到多个硬盘，每个条带大小可以按需调整</p><p><strong>RAID0</strong></p><p>仅提供并行交叉存取，无校验功能</p><p>逻辑块 = 物理块的就简单组合</p><p><strong>RAID1</strong></p><p>镜像磁盘冗余阵列，将数据块重复存入镜像磁盘，但有效容量降低了</p><p><strong>RAID 0+1 和 RAID 1+0</strong></p><p><img src="0+1.png" alt="0+1"></p><p><strong>RAID2</strong></p><p>采用海明码纠错的磁盘阵列，将数据位交叉写入 几个磁盘中。按位条带化。</p><ul><li>奇偶校验</li><li>海明码</li></ul><p>要多个磁盘来存放海明校验码信息，冗 余磁盘数量与数据磁盘数量的对数成正比</p><p>四位数据要有至少三个校验位</p><p>$2^P &gt;= P + D+ 1$</p><p><strong>RAID3</strong></p><p>数据位交叉，阵列中只有一个校验位</p><p>将磁盘分组采用字节级别的条带，读写需要访问组中所有盘，每组一个盘作为校验盘</p><p>先将分布在各个数据盘上的一组数 据加起来，将和存放在冗余盘上。一旦某一个 盘出错，只要将冗余盘上的和减去所有正确盘 上的数据，得到的差就是出错的盘上的数据。 </p><p>但恢复时间较长</p><p><strong>RAID4</strong></p><p>并行处理磁盘序列</p><p>数据块交叉</p><p>冗余代价和RAID3相同</p><p>在RAID3中，一次磁盘访问将对磁盘阵中的所有磁盘进行（同步）操作。</p><p>随机读快，随机写满（竞争同一个校验盘）</p><p><strong>RAID5</strong></p><p>采用数据块交叉和分布的冗余校验，将数据和校验都分布 在各个磁盘中，没有专门的奇偶校验驱动器</p><p><strong>RAID6</strong></p><p>双维校验独立存取盘阵列，数据以块（块 大小可变）交叉方式存于各盘，检、纠错信息均匀分布在所有磁盘上。</p><ul><li>写入数据需要访问一个数据盘、两个冗余盘</li><li>可以容忍双盘出错</li></ul><p><strong>RAID小结</strong></p><ul><li>条带化：一个字节块存在多个数据盘上</li></ul><p>并行存取、性能好、磁盘负载均衡，但不同可靠性不太好、不同请求需要排队</p><ul><li>镜像：数据完全拷贝</li></ul><p>保证可靠性的同时增大了储存开销</p><ul><li>校验</li></ul><p>作用同上</p><p><img src="RAID.png" alt="RAID"></p><p><strong>缓存——提高I/O</strong></p><ul><li><p>优化物理块排布，尽可能连续摆放</p></li><li><p>优化索引节点分布</p></li><li><p>顺序访问，提前读</p></li><li>延迟写</li><li>虚拟盘</li></ul><p>增加分区并不可以改善</p><p>分区的类型分为主分区、扩展分区和逻辑驱动器。</p><p><strong>数据库结构</strong></p><ul><li>私有头</li><li>内容表：16个扇区大小</li><li>记录区</li></ul><p>对简单卷来说，通过把卷的偏移量加上卷在磁盘中的起始地址，卷管理器可以保证卷的偏移量被 转换成盘的偏移量</p><p><strong>多重分区管理</strong></p><ul><li>跨分区卷：将多个磁盘的未划分空间合并在一个卷中，并赋予驱动器号</li><li>条带卷：通过将多个磁盘的空间组合在一起（至少2 个磁盘，最多支持32个磁盘），形成条带卷</li><li>镜像卷（RAID-1）：将两个磁盘合成一个卷来使用，镜像卷是唯一一种支持系统卷和引导卷的多分区卷</li><li>RADI-5：先将磁盘划分成带区，在向 RAID-5卷保存数据时，会先利用数学算法算出校验码 同时写入硬盘中</li></ul><p><strong>码距</strong></p><p>码矩越大，纠错越强</p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p><strong>三个基本要求</strong></p><ul><li>储存大量数据</li><li>长期保存</li><li>共享数据</li></ul><p>文件作为数据的储存和访问单位，逻辑上是有完整意义的信息项的序列</p><p>用户视角：使用逻辑文件</p><p>操作系统视角：组织管理物理文件</p><p><strong>文件类型</strong></p><ul><li>性质和用途：系统文件、库文件、用户文件</li><li>按数据形式：源文件、目标文件、可执行文件</li><li>保护级别区分：只读文件、读写文件、执行文件、不保护文件</li><li>逻辑结构：有结构文件、无结构文件</li><li>文件中物理结构：顺序文件、链接文件、索引文件</li></ul><p><strong>文件的储存介质</strong></p><ul><li>磁盘、磁带、光盘</li><li>物理块：数据储存、传输和分配的单位</li></ul><p><strong>多级目录特点</strong></p><ul><li>层次清晰</li><li>可解决文件重名问题</li><li>查找速度快</li><li>目录级别过多时可能会增加目录检索时间</li></ul><p><strong>文件控制快</strong></p><ul><li>基本信息<ul><li>文件名</li><li>物理位置</li><li>文件逻辑结构（记录文件 or 流式结构）<ul><li>流式文件：构成文件的基本单位是字符，文件是有逻辑意义无结构的一串字符的集合</li><li>记录式文件：文件由若干记录组成：可以按记录进行读写查找</li></ul></li><li>文件物理结构</li></ul></li><li>访问控制信息<ul><li>文件所有者</li><li>访问权限</li></ul></li><li>使用信息<ul><li>创建时间</li></ul></li></ul><p><strong>磁盘结构</strong></p><ul><li>顺序结构（连续结构）</li></ul><p>结构简单，适用于变化不大的顺序访问</p><ul><li>串联（链接）文件</li></ul><p>空间利用率高，随机存取效率低</p><ul><li>索引结构</li></ul><p>索引表位于文件目录或者开头</p><p>索引文件在存储区中占两个区：索引区和数据区。索引区存放索引表，数据区存放数据文件本身</p><p>访问索引文件的两步操作</p><ul><li>查文件索引号，由逻辑块号查得物理块号</li><li>由此磁盘物理块号而获得所要求的信息</li></ul><p>索引表虽然好但是带来了系统开销</p><p><strong>长文件名处理</strong></p><ul><li>固定255个字符，但是太浪费了</li><li>每个目录项长度可变，分为目录项长度、文件属性信息、文件名（长度可变）文件被删除后该目录项占用的空间不太好回收</li><li>目录项长度可变，长度可变的文件名放在目录文件结尾、</li></ul><p><strong>磁盘空间管理</strong></p><ul><li>空闲表法</li><li>空闲链表法</li><li>位示图</li><li>成组链接法：空白块号登记不占用额外空间节约时间</li></ul><p><strong>保护文件</strong></p><ul><li>建立副本</li><li>定时转储</li><li>规定文件权限——用于审定用户权限</li></ul><p><strong>文件访问</strong></p><ul><li>并发访问控制</li><li>文件锁定：协调文件指定区域的互斥访问</li><li>进程通信协调文件访问</li></ul><p>设计文件系统尽可能减少磁盘访问次数</p><p>解决办法：目录项（FCB）分解、当前目录、磁盘碎片整理、块高速缓存、磁盘调度、提前读取、合理分配磁盘空间、信息的优化分布、RAID技术</p><p><strong>块高速缓存</strong></p><p>是指在内存中为磁盘块设置的一个缓冲区，保存了磁盘中某些块的副本。当对文件系统进行操作的时候检查所有的读请求，看所需块是否在块高速缓冲中– 如果在，则可直接进行读操作；否则，先将数据块读入块高速缓存，再拷贝到所需的地方。由于访问的局部性原理，当一数据块被读入块高速缓存以满足一个IO请求时，很可能将来还会再次访问到这一数据块。</p><p><strong>FAT文件系统</strong></p><p>簇是我文件管理的最小单元</p><ul><li>主引导记录MBR</li><li>分区引导扇区DBR</li><li>文件分配表FAT<ul><li>FAT表：两个镜像，互为备份，文件卷中每个簇均对应一个FAT表项，文件分配采用链式分配方法<ul><li>0：该簇空闲</li><li>FF7h：物理坏簇</li><li>FF8h-FFFh：表示该簇是文件的最后一个簇</li><li>其他值：表示该簇被文件占用，而且表项中的值是文件下一个簇的编号</li></ul></li><li>FAT表大小占文件卷容量的比例：簇编号位数/（8*512*每个簇的扇区数）</li></ul></li></ul><p><strong>ext2文件系统</strong></p><p>利用索引节点（inode）来描述文件系统的拓扑结构</p><p>磁盘划分为大小相同的块（1KB），然后组成若干块组</p><p>每个组有若干相应的描述符</p><p><img src="ext.png" alt="ext"></p><p>inode结构</p><p><img src="inode.png" alt="inode"></p><p>模式：包含对象类型等</p><p>时间戳：索引节点创建时间及最后改动时间</p><p>文件系统的超块（Superblock）包含了文件系统的基本大小和形式</p><p><strong>文件共享</strong></p><p>进程间的线程共享的资源有: </p><ol><li>​    堆 ：由于堆是在进程空间中开辟出来的，所以它是理所当然地被共享的；因此new出来的都是共享的（16位平台上分全局堆和局部堆，局部堆是独享的）      </li><li>​    全局变量：它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的      </li><li>​    静态变量：虽然对于局部变量来说，它在代码中是“放”在某一函数中的，但是其存放位置和全局变量一样，存于堆中开辟的.bss和.data段，是共享的      </li><li>​    文件等公用资源：这个是共享的，使用这些公共资源的线程必须同步。Win32 提供了几种同步资源的方式，包括信号、临界区、事件和互斥体。</li></ol><p><strong>虚拟文件系统VFS</strong></p><p><strong>基于日志结构的文件系统LFS</strong></p><h3 id="知识填空"><a href="#知识填空" class="headerlink" title="知识填空"></a>知识填空</h3><ol><li><p>操作系统为用户提供三种类型的使用接口，它们是命令方式和系统调用和图形用户界面。</p></li><li><p>主存储器与外围设备之间的数据传送控制方式有程序直接控制、中断驱动方式、DMA方式和通道控制方式。</p></li><li><p>在响应比最高者优先的作业调度算法中，当各个作业等待时间相同时，运行时间短的作业将得到优先调度；当各个作业要求运行的时间相同时，等待时间长的作业得到优先调度。</p></li><li><p>当一个进程独占处理器顺序执行时，具有两个特性：封闭性和可再现性。</p></li><li><p>程序经编译或汇编以后形成目标程序，其指令的顺序都是以零作为参考地址，这些地址称为逻辑地址。</p></li><li><p>进程由程序、数据和FCB组成。</p></li><li><p>对信号量S的操作只能通过原语操作进行，对应每一个信号量设置了一个等待队列。</p></li><li><p>操作系统是运行在计算机裸机系统上的最基本的系统软件。</p></li><li><p>虚拟设备是指采用SPOOLING技术，将某个独享设备改进为供多个用户使用的的共享设备。</p></li><li><p>文件系统中，用于文件的描述和控制并与文件一一对应的是文件控制块。</p></li><li><p>段式管理中，以段为单位，每段分配一个连续区。由于各段长度不同，所以这些存储区的大小不一，而且同一进程的各段之间不要求连续。</p></li><li><p>在采用请求分页式存储管理的系统中，地址变换过程可能会因为缺页和越界等原因而产生中断。</p></li><li><p>段的共享是通过共享段表实现的。</p></li><li><p>文件的物理结构分为顺序文件、索引文件和索引顺序文件。</p></li><li><p>所谓设备控制器，是一块能控制一台或多台外围设备与CPU并行工作的硬件。</p></li><li><p>UNIX的文件系统空闲空间的管理是采用成组链接法。</p></li><li>分页管理储管理方式能使存储碎片尽可能少，而且使内存利用率较高，管理开销小。</li><li>计算机操作系统是方便用户、管理和控制计算机软硬件资源的系统软件。</li><li>操作系统目前有五大类型：批处理操作系统、分时操作系统（分时是指多个用户分享使用同一台计算机。多个程序分时共享硬件和软件资源）、实时操作系统、网络操作系统和分布式操作系统。</li><li><p>按文件的逻辑存储结构分，文件分为有结构文件，又称为记录式文件和无结构文件，又称流式文件。</p></li><li><p>主存储器与外围设备之间的信息传送操作称为输入输出操作。</p></li><li><p>在设备管理中，为了克服独占设备速度较慢、降低设备资源利用率的缺点，引入了虚拟分配技术，即用共享设备模拟独占设备。</p></li><li>常用的内存管理方法有分区管理、页式管理、段式管理和段页式管理。</li><li>动态存储分配时，要靠<strong>硬件地址变换机构</strong>实现重定位。</li><li>在存储管理中常用<strong>虚拟存储器方</strong>式来摆脱主存容量的限制。</li><li><p>在请求页式管理中，当硬件变换机构发现所需的页不在内存时，产生缺页中断信号，中断处理程序作相应的处理。</p></li><li><p>置换算法是在内存中没有空闲页面时被调用的，它的目的是选出一个被淘汰的页面。如果内存中有足够的空闲页面存放所调入的页，则不必使用置换算法。</p></li><li><p>在段页式存储管理系统中，面向用户的地址空间是段式划分，面向物理实现的地址空间是页式划分。（段映射机制，将逻辑地址映射到线性地址；页映射机制，将线性地址映射到物理地址）</p></li><li><p>文件的存储器是分成大小相等的物理块，并以它为单位交换信息。</p></li><li><p>虚拟设备是通过SPOOLing技术把独占设备变成能为若干用户共享的设备。</p></li><li><p>缓冲区的设置可分为单缓冲、双缓冲、多缓冲和缓冲池。</p></li><li><p>在多道程序环境中，用户程序的相对地址与装入内存后的实际物理地址不同，把相对地址转换为物理地址，这是操作系统的地址重地位功能。</p></li><li><p>在操作系统中，进程是一个资源分配的基本单位，也是一个独立运行和调度的基本单位。</p></li><li><p>在信号量机制中，信号量S &gt;0时的值表示可用资源数目；若S &lt; 0，则表示等待该资源的进程数，此时进程应阻塞。</p></li><li><p>操作系统提供给编程人员的唯一接口是系统调用。</p></li><li>设备从资源分配角度可分为独占设备，共享设备和虚拟设备。</li><li>设备管理的主要任务是控制设备和CPU之间进行I/O操作。</li><li>常用的文件存取方法有顺序存取法，随机存取法和按键存取法。 </li><li>在页面置换算法中最有效的一种称为LRU算法。</li><li>地址变换机构的基本任务是将虚地址空间中的逻辑地址变换为内存中的物理地址。</li><li><p>在 UNIX 系统中采用的页面置换算法是页面缓冲算法。</p></li><li><p>现代操作系统的两个重要特征是并发和共享。</p></li><li><p>操作系统的基本类型有批处理操作系统，分时操作系统和实时操作系统三种。</p></li><li><p>采用对换方式在将进程换出时，应首先选择处于阻塞且优先权低的进程换出内存。</p></li><li><p>能方便实现信息共享的存储管理办法有段式和段页式。</p></li><li>选择距当前磁头最近，且方向一致的磁盘调度算法循环扫描算法。</li><li>在页面置换算法中可实现的最有效的一种称为LRU。</li><li><p>在成组链结法中，将第一组的空闲块号和该组的空闲块数目记入到内存的工作栈中，作为当前可供分配的空闲盘块号。</p></li><li><p>现代操作系统的两个重要特征是并发和共享。</p></li><li>在动态分区式内存分配算法中，倾向于优先使用低地址部分空闲区的算法是首次适应算法  ；能使内存空间中空闲区分布较均匀的算法是循环首次适应算法。</li><li>在分时系统中，当用户数目为100时，为保证响应时间不超过2秒，此时时间片最大应为20ms。分时系统采用的调度方法是时间片轮转调度算法。</li><li>常用的进程通信方式有管道、共享存储区、消息机制和邮箱机制。</li><li>正在执行的进程等待I/O操作，其状态将由执行状态变为阻塞状态。</li><li><p>页是信息的物理单位，进行分页是出于系统管理 的需要；段是信息的逻辑单位，分段是出于用户的需要。</p></li><li><p>分段保护中的越界检查是通过段表寄存器  中存放的段表长度  和段表中的段长 等数据项。</p></li><li><p>在请求调页系统中的调页策略有预调入策略，它是以预测为基础的；另一种是请求调入，由于较易实现，故目前使用较多。</p></li><li><p>若干个事件在同一时刻发生称为并行，若干个事件在同一时间间隔内发生称为并发。</p></li><li><p>使用缓冲区能有效地缓和I/O设备和CPU之间速度不匹配的矛盾。</p></li><li><p>用户编写的程序与实际使用的物理设备无关，而由操作系统负责地址的重定位，我们称之为设备无关性（设备独立性）。</p></li><li><p>用户是通过命令方式或者程序接口向计算机发出请求的。</p></li><li><p>在操作系统中的异步性主要是指在系统中进程推进的顺序是走走停停。</p></li><li><p>进程间通信的方式有管道、共享存储区和消息传递方式。</p></li><li><p>计算机操作系统是方便用户、管理和控制计算机系统资源的系统软件。</p></li><li><p>在多道程序环境中，用户程序的相对地址与装入内存后的实际物理地址不同，把相对地址转换为物理地址，这是操作系统的地址重地位功能。 </p></li><li><p>操作系的动态分区管理内存分配算法有首次适应算法、循环首次适应算法、和最佳适应算法。</p></li><li><p>动态存储分配时，要靠硬件地址变换机构实现重定位。</p></li><li><p>在存储管理中常用虚拟存储器方式来摆脱主存容量的限制。</p></li><li><p>在请求页式管理中，当硬件变换机构发现所需的页不在内存时，产生缺页中断信号，中断处理程序作相应的处理。</p></li><li><p>置换算法是在内存中没有空闲页面时被调用的，它的目的是选出一个被</p></li><li><p>淘汰的页面。如果内存中有足够的空闲页面存放所调入的页，则不必使用置换算法。</p></li><li><p>在段页式存储管理系统中，面向用户的地址空间是段式划分，面向物理实现的地址空间是页式划分。</p></li><li>文件的存储器是分成大小相等的物理块，并以它为单位交换信息。</li><li>通道是一个独立于CPU的专管I/O的处理机，它控制设备与内存之间的信息交换。</li><li><p>缓冲区的设置可分为单缓冲、双缓冲、循环缓冲和缓冲池。其中关于缓冲池的操作有提取输入、提取输出、收容输入和收容输出。</p></li><li><p>操作系统为用户编程所提供的接口是系统调用。</p></li><li><p>文件的逻辑结构分为流式文件、顺序文件、索引文件和索引顺序文件。</p></li><li><p>进程由程序、数据和PCB组成。</p></li><li><p>在生产者—消费者问题中，消费者进程的两个wait原语的正确顺序为Wait(full)；和wait(mutex);。</p></li><li><p>段式管理中，提供二维的地址结构。以段为单位进行空间分配，每段分配一个连续内存区。</p></li><li><p>逻辑设备表（LUT）的主要功能是实现逻辑设备到物理设备的映射。</p></li><li><p>进程间通信的类型有：共享存储区、管道机制、消息队列和信箱机制。</p></li><li><p>在响应比最高者优先的作业调度算法中，当各个作业等待时间相同时，运行时间短的作业将得到优先调度；当各个作业要求运行的时间相同时，等待时间长的作业得到优先调度。</p></li><li><p>若干个等待访问磁盘者依次要访问的磁道为20，44，40，4，80，12，76，移动臂当前位于40号柱面，则先来先服务算法的平均寻道长度为292； 最短寻道时间优先算法的平均寻道长度为120；扫描算法（当前磁头移动的方向为磁道递增）的平均寻道长度为116。</p></li><li><p>有三个同时到达的作业J1，J2和J3，它们的执行时间分别是T1，T2和T3，且T1&lt;T2&lt;T3。系统按单道方式运行且采用短作业优先算法，则平均周转时间是(3<em>T1+2</em>T2+T3)/3。　</p></li><li><p>位示图是利用二进制的一个位来表示磁盘中一个盘块的使用情况。</p></li><li><p>在SPOOLing系统中，进程执行输出的过程是：将进程产生的数据送到磁盘的输出井输出程序再将数据提出，通过内存的输出缓冲区送往输出设备。</p></li><li><p>在请求分页系统中，假如一个作业的页面走向为1，2，3，4，1，2，5，1，2，3，4，5，当分配给该作业的物理块数M为3，采用先进先出页面置换算法时，访问过程中发生的缺页次数为：9；采用最佳页面置换算法时，缺页次数为7；采用LRU页面置换算法时，缺页次数为：10。（假定开始时，物理块中为空）</p></li><li><p>将数据从设备送入缓冲池称为：读取 ；将数据从缓冲池送入设备称为： 写入  ；</p></li><li><p>如果信号量的当前值为3，表示可用的资源数目为3，如果信号量的当前值为-3，则表示   有3个等待进程       。</p></li><li>I/O控制的方式有程序直接控制方式、中断控制方式、DMA方式和通道方式。</li><li>在首次适应算法中，要求空闲分区按地址递增顺序链接成空闲分区链；在最佳适应算法中是按空闲分区从小到大顺序形成空闲分区链。</li><li>文件的物理结构有顺序文件、链接文件文件和索引文件三种。</li><li>现代操作系统的特征是并发、共享、虚拟和异步性。</li><li><p>产生死锁的四个必要条件是互斥条件和请求和保持，不剥夺条件和环路条件。</p></li><li><p>操作系统的五大功能是CPU管理、存储管理、设备管理、文件系统和用户接口。</p></li><li><p>在操作系统中进程和线程的区别是：拥有资源。</p></li><li><p>文件系统的基本任务是实现按名存取。</p></li><li><p>静态链接是在程序编译时进行，动态链接是在执行时进行。</p></li><li><p>文件的保护是通过存取控制表来实现的。</p></li><li><p>文件共享的方式有基于索引结点的方式和利用符号链。</p></li><li><p>一次只允许一个进程访问的资源叫临界资源。</p></li><li><p>在操作系统中进程是一个拥有资源的单位，也是一个调度和执行的基本单位。</p></li><li><p>如果信号量的当前值为4，则表示 可用资源数目为4，如果信号量的当前值为-4，则表示有4个等待进程 。</p></li><li><p>在批处理兼分时的系统中，往往由分时系统控制的作业称为前台作业，而由批处理系统控制的作业称为后台作业。</p></li><li><p>操作系统为用户提供两种类型的使用接口，它们是操作员（或用户）接口和程序员（或程序）接口。</p></li><li><p>操作系统中，进程可以分为系统进程和用户进程两类。</p></li><li><p>用户调用建立和打开（可交换次序）文件操作来申请对文件的使用权。</p></li><li><p>主存储器与外围设备之间的信息传送操作称为输入输出操作。</p></li><li><p>当一个进程独占处理器顺序执行时，具有两个特性：封闭性和可再现性。</p></li><li><p>操作系统是运行在计算机基本硬件（或：硬件）系统上的最基本的系统软件。</p></li><li><p>程序经编译或汇编以后形成目标程序，其指令的顺序都是以零作为参考地址，这些地址称为相对地址（或：逻辑地址、虚拟地址）。</p></li><li><p>文件的逻辑结构分字符流式文件和记录式文件二种。</p></li><li><p>Windows NT操作系统结构由两个部分构成：一是保护子系统，另一是执行体。</p></li><li><p>目前硬盘中最常使用的两种接口是IDE接口和SCSI接口。</p></li><li><p>用户要求计算机系统所做的工作的集合称为作业。</p></li><li><p>进程由程度、数据集合、进程控制块及相关表格组成。</p></li><li><p>对信号量S的操作只能通过P、V操作进行，对应每一个信号量设置了一个等待队列。</p></li><li><p>在存贮器可变式分区管理中，对内存状态的记录和分配管理通常可采用表格法、位图法和链表法。</p></li><li><p>虚拟设备是指采用某种I／O技术，将某个独占设备改进为多个用户可共享的设备。</p></li><li><p>文件系统中，用于文件的描述和控制并与文件一一对应的是文件控制块（或FCB）。</p></li><li><p>所谓通道，是一块能控制一台或多台外围设备与CPU并行工作的硬件。</p></li><li><p>用户是通过命令接口或者程序接口向计算机发出请求的。</p></li><li><p>操作系统的主要设计目标是方便用户使用或界面友好和系统能高效工作或资源利用率高。</p></li><li>当一个进程完成了特定的任务后，系统收回这个进程所占的工作区或主存空间或资源和取消该进程的进程控制块(PCB)就撤消了该进程。单个分区存储管理仅适用于个人计算机(单用户)和专用计算机(单道，单作业)系统。</li><li>每个索引文件都必须有一张索引表，其中每个登记项用来指出一个逻辑记录的存放位置或指针或首地址。</li><li>实现SPOOL系统时必须在磁盘上辟出称为输入井和输出井 (可交换次序)的专门区域，以存放作业信息和作业执行结果。</li><li>一个理想的作业调度算法应该是既能提高系统效率或吞吐量高 及时得到计算结果又能使进入系统的作业周转时间短等。</li></ol><h2 id="易错点记录"><a href="#易错点记录" class="headerlink" title="易错点记录"></a>易错点记录</h2><ol><li>计算逻辑地址0x01234567对应的页目录项的逻辑地址 = PDbase + （PDE(va) &lt;&lt; 22）&gt;&gt; 2，右移2位代表页表项的大小（32位，4字节）</li><li>计算机从内存向缓存传输数据的单位是cache line。</li><li>段式地址整体是二维的不连续的，但段内地址是从0开始的连续地址</li><li>文件系统中源程序是有结构的记录式文件。（×）</li><li>缺页中断返回后执行产生中断的指令，一般中断返回后执行下一条指令。</li><li>地址转换功能工作是由硬件完成。</li><li>外存（如磁盘）上存放的程序和数据不能直接被CPU存取或调入寄存器，因为CPU只能直接访问内存中的程序和数据。程序和数据必须首先被加载到内存中，CPU才能执行程序或访问数据</li><li>通道的主要目的是为了建立独立的I/O操作，不仅使数据的传送能独立于CPU，而且也希望有关I/O操作的组织，管理及结束也尽量独立，以保证CPU有更多的时间去进行数据处理。是一种I/O专用处理机</li><li>磁盘通常被认为是块设备，而不是字符设备。字符设备和块设备是两种不同类型的硬件设备，它们在操作系统中处理数据的方式不同：<ol><li><strong>字符设备</strong>：字符设备是按照字符流来处理数据的设备。这意味着它们一次处理一个字符，并且通常不支持随机访问。字符设备的例子包括键盘、鼠标和串行端口。</li><li><strong>块设备</strong>：块设备是按照数据块来处理数据的设备。它们支持随机访问，这意味着它们可以快速地跳转到文件系统中的任意位置。块设备的例子包括硬盘驱动器、固态硬盘(SSD)和USB闪存驱动器。</li></ol></li><li>DMA在所要求传送的一批数据全部传送结束时中断CPU；中断在每个数据传送完后中断CPU</li><li>重定位：把作业的地址空间中的相对地址转换成内存空间的物理地址的调整过程，在程序运行时，凡遇到访问内存的操作，就由硬件机制自动把用户程序的相对地址加上重定位寄存器的内容，其和就是实际访问内存的有效地址（所以重定位是通过硬件实现的）</li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><strong>给进程大小求解最优页面大小</strong></p><p>设进程平均大小为s,页面大小为p，页面项大小为e，则分页开销为$\frac{s*e}{p} + \frac{p}2$</p><p>要使得开销最小则让两项相等即可，前一项表示进程空间所需页表项的占用空间（页表项*大小），后一项表示进程的最后一页平均由有一半是碎片</p>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA_OS_lab3</title>
    <link href="/2024/04/05/BUAA-OS-lab3/"/>
    <url>/2024/04/05/BUAA-OS-lab3/</url>
    
    <content type="html"><![CDATA[<h1 id="BUAA-OS-lab3学习日记"><a href="#BUAA-OS-lab3学习日记" class="headerlink" title="BUAA_OS_lab3学习日记"></a>BUAA_OS_lab3学习日记</h1><h2 id="Thinking思考题"><a href="#Thinking思考题" class="headerlink" title="Thinking思考题"></a>Thinking思考题</h2><h3 id="Thinking-3-1"><a href="#Thinking-3-1" class="headerlink" title="Thinking 3.1"></a>Thinking 3.1</h3><p>问：请结合 MOS 中的页目录自映射应用解释代码中 e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_V 的含义。 </p><p>答：</p><p>User VPT中存放了1024个页表，由于自映射的关系，这个页表里又包括了页目录的页表，每一个页表中又有1024个页表项，UVPT：用户页表的起始处的内核虚拟地址</p><p>PDX(UVPT)：UVPT所处的页目录号（即 UVPT 处于第 PDX(UVPT) 个页目录项所映射的4MB空间。PDX获得的是这个虚拟地址的页目录号。</p><p>e-&gt;env_pgdir：进程 e 的页目录的内核虚拟地址</p><p>PADDR(e-&gt;env_pgdir)：进程 e 的页目录的物理地址</p><p>PADDR(e-&gt;env_pgdir) | PTE_V：页目录的物理基地址，加上权限位（只读权限）</p><p>自映射的意义即是只需要知道二级页表的初始地址，就能构造出页目录的初始地址以及指向页目录自身的PDE，这样，方便我们访问管理页表与页目录。</p><h3 id="Thinking-3-2"><a href="#Thinking-3-2" class="headerlink" title="Thinking 3.2"></a>Thinking 3.2</h3><p>问：elf_load_seg 以函数指针的形式，接受外部自定义的回调函数 map_page。 请你找到与之相关的 data 这一参数在此处的来源，并思考它的作用。没有这个参数可不可 以？为什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">elf_load_seg</span><span class="hljs-params">(Elf32_Phdr *ph, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *bin, <span class="hljs-type">elf_mapper_t</span> map_page, <span class="hljs-type">void</span> *data)</span>;<br></code></pre></td></tr></table></figure><p>data 是传入的进程控制块指针，在 load_icode_mapper 和 load_icode 函数中被调用，在 load_icode 函数中 data 被赋予进程控制块的指针 e。</p><p>作用：在增加虚拟地址到物理地址映射的时候提供env_pgdir和env_asid；如果没有data，load_icode_mapper就不能知道当前进程空间的页目录基地址和asid，所以必须要有这个参数。</p><h3 id="Thinking-3-3"><a href="#Thinking-3-3" class="headerlink" title="Thinking 3.3"></a>Thinking 3.3</h3><p>问：结合 elf_load_seg 的参数和实现，考虑该函数需要处理哪些页面加载的情 况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">elf_load_seg</span><span class="hljs-params">(Elf32_Phdr *ph, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *bin, <span class="hljs-type">elf_mapper_t</span> map_page, <span class="hljs-type">void</span> *data)</span> &#123;<br>u_long va = ph-&gt;p_vaddr;<br><span class="hljs-type">size_t</span> bin_size = ph-&gt;p_filesz;<br><span class="hljs-type">size_t</span> sgsize = ph-&gt;p_memsz;<br>u_int perm = PTE_V;<br><span class="hljs-keyword">if</span> (ph-&gt;p_flags &amp; PF_W) &#123;<br>perm |= PTE_D;<br>&#125;<br><br><span class="hljs-type">int</span> r;<br><span class="hljs-type">size_t</span> i;<br>u_long offset = va - ROUNDDOWN(va, PAGE_SIZE);<br><span class="hljs-keyword">if</span> (offset != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> ((r = map_page(data, va, offset, perm, bin,<br>  MIN(bin_size, PAGE_SIZE - offset))) != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> r;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/* Step 1: load all content of bin into memory. */</span><br><span class="hljs-keyword">for</span> (i = offset ? MIN(bin_size, PAGE_SIZE - offset) : <span class="hljs-number">0</span>; i &lt; bin_size; i += PAGE_SIZE) &#123;<br><span class="hljs-keyword">if</span> ((r = map_page(data, va + i, <span class="hljs-number">0</span>, perm, bin + i, MIN(bin_size - i, PAGE_SIZE))) !=<br>    <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> r;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/* Step 2: alloc pages to reach `sgsize` when `bin_size` &lt; `sgsize`. */</span><br><span class="hljs-keyword">while</span> (i &lt; sgsize) &#123;<br><span class="hljs-keyword">if</span> ((r = map_page(data, va + i, <span class="hljs-number">0</span>, perm, <span class="hljs-literal">NULL</span>, MIN(sgsize - i, PAGE_SIZE))) != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> r;<br>&#125;<br>i += PAGE_SIZE;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>函数判断va是否页对齐，如果不对齐，需要将多余的地址记为offset，我们将最开头不对齐的部分 “剪切” 下来，先映射到内存的页中。</li><li>将段内所有页映射到物理空间</li><li>最后我们处理段大小大于数据大小的情况。在这一部分，我们不断创建新的页，但是并不向其中加载任何内容。</li></ul><h3 id="Thinking-3-4"><a href="#Thinking-3-4" class="headerlink" title="Thinking 3.4"></a>Thinking 3.4</h3><p>问：这里的 env_tf.cp0_epc 存储的是物理地址还是虚拟地址?</p><p>根据上学期计组P7的知识，因为epc存储的是发生错误时CPU所处的指令地址，对于CPU来说，在程序中引用访存的地址都是虚拟地址，因此env_tf.cp0_epc毫无疑问存储的是虚拟地址.</p><h3 id="Thinking-3-5"><a href="#Thinking-3-5" class="headerlink" title="Thinking 3.5"></a>Thinking 3.5</h3><p>问：试找出 0、1、2、3 号异常处理函数的具体实现位置。8 号异常（系统调用） 涉及的 do_syscall() 函数将在 Lab4 中实现。</p><p>备注： C 的拓展语法 [first … last] = value 来对数组某个区间上的 元素赋成同一个值</p><p>查找结果如下：</p><p>kern/genex.S:20:NESTED(handle_int, TF_SIZE, zero)<br>kern/genex.S:29:END(handle_int)</p><p>handle_int在genex.S文件中</p><p>handle_mod和handle_tlb，handle_sys藏得比较深，三者都是通过genex.S文件中的宏函数BUILD_HANDLER实现的，代码如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">BUILD_HANDLER </span>tlb do_tlb_refill<br><br><span class="hljs-comment">#if !defined(LAB) || LAB &gt;= 4</span><br><span class="hljs-keyword">BUILD_HANDLER </span>mod do_tlb_mod<br><span class="hljs-keyword">BUILD_HANDLER </span>sys do_syscall<br><span class="hljs-comment">#endif</span><br><br><span class="hljs-keyword">BUILD_HANDLER </span>reserved do_reserved<br></code></pre></td></tr></table></figure><h3 id="Thinking-3-6"><a href="#Thinking-3-6" class="headerlink" title="Thinking 3.6"></a>Thinking 3.6</h3><p>问：阅读 entry.S、genex.S 和 env_asm.S 这几个文件，并尝试说出时钟中断 在哪些时候开启，在哪些时候关闭。</p><p>entry.S</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">LEAF(env_pop_tf)<br><span class="hljs-meta">.set</span> reorder<br><span class="hljs-meta">.set</span> <span class="hljs-built_in">at</span><br><span class="hljs-keyword">mtc0 </span>   <span class="hljs-built_in">a1</span>, CP0_ENTRYHI<br><span class="hljs-keyword">move </span>   <span class="hljs-built_in">sp</span>, <span class="hljs-built_in">a0</span><br>RESET_KCLOCK<br><span class="hljs-keyword">j </span>      ret_from_exception<br>END(env_pop_tf)<br></code></pre></td></tr></table></figure><p>genex.S</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">NESTED(handle_int, TF_SIZE, <span class="hljs-built_in">zero</span>)<br><span class="hljs-keyword">mfc0 </span>   <span class="hljs-built_in">t0</span>, CP0_CAUSE<br><span class="hljs-keyword">mfc0 </span>   <span class="hljs-built_in">t2</span>, CP0_STATUS<br><span class="hljs-keyword">and </span>    <span class="hljs-built_in">t0</span>, <span class="hljs-built_in">t2</span><br><span class="hljs-keyword">andi </span>   <span class="hljs-built_in">t1</span>, <span class="hljs-built_in">t0</span>, STATUS_IM7<br><span class="hljs-keyword">bnez </span>   <span class="hljs-built_in">t1</span>, timer_irq<br><span class="hljs-symbol">timer_irq:</span><br>li      <span class="hljs-built_in">a0</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">j </span>      <span class="hljs-keyword">schedule</span><br><span class="hljs-keyword"></span>END(handle_int)<br></code></pre></td></tr></table></figure><p>当中断屏蔽位位为1且，CP0_CAUSE为时钟中断，且CP0_STATUS正常相应，体现为这几个寄存器储存的值做与运算的结果不为0，时钟中断开始，调度完成后结束。</p><h3 id="Thinking-3-7"><a href="#Thinking-3-7" class="headerlink" title="Thinking 3.7"></a>Thinking 3.7</h3><p>问：阅读相关代码，思考操作系统是怎么根据时钟中断切换进程的。</p><p>再调度函数中，如果满足切换条件（<code>yield || count &lt;= 0 || e == NULL || e-&gt;env_status != ENV_RUNNABLE</code>），如果当前进程没有就绪，将其移到调度链表尾部，反之则不用，接着选中调度链表头部进程达到调度目的。</p><h2 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h2><h3 id="Exercise-3-1"><a href="#Exercise-3-1" class="headerlink" title="Exercise 3.1"></a>Exercise 3.1</h3><p>实现进程控制快的初始化功能，具体实现参考注释即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* Step 1: Initialize &#x27;env_free_list&#x27; with &#x27;LIST_INIT&#x27; and &#x27;env_sched_list&#x27; with</span><br><span class="hljs-comment"> * &#x27;TAILQ_INIT&#x27;. */</span><br><span class="hljs-comment">/* Exercise 3.1: Your code here. (1/2) */</span><br>LIST_INIT(&amp;env_free_list);<br>TAILQ_INIT(&amp;env_sched_list);<br><span class="hljs-comment">/* Step 2: Traverse the elements of &#x27;envs&#x27; array, set their status to &#x27;ENV_FREE&#x27; and insert</span><br><span class="hljs-comment"> * them into the &#x27;env_free_list&#x27;. Make sure, after the insertion, the order of envs in the</span><br><span class="hljs-comment"> * list should be the same as they are in the &#x27;envs&#x27; array. */</span><br><span class="hljs-keyword">for</span> (i = NENV - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>envs-&gt;env_status = ENV_FREE;<br>LIST_INSERT_HEAD(&amp;env_free_list,&amp;envs[i], env_link);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Exercise-3-2"><a href="#Exercise-3-2" class="headerlink" title="Exercise 3.2"></a>Exercise 3.2</h3><p>段地址的初始化使用 map_segment 函数在该页表中将内核数组 pages 和 envs 映射到了用户空间的 UPAGES 和 UENVS 处</p><p>map_segment功能是在一级页表基地址 pgdir 对应的两级页表结构中做段地址映射，将虚拟地 址段 [va,va+size) 映射到物理地址段 [pa,pa+size)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">page_insert(pgdir, asid, pa2page(pa + i), va + i, perm);<br></code></pre></td></tr></table></figure><h3 id="Exercise-3-3"><a href="#Exercise-3-3" class="headerlink" title="Exercise 3.3"></a>Exercise 3.3</h3><p>env_setup_vm函数：初始化新进程的地址空间</p><p>步骤如下：</p><ul><li>申请一块页表，并将页表转化为kernel地址赋值给e-&gt;env_pgdir</li><li>制了 <code>UTOP</code> 到 <code>UVPT</code> 的虚拟地址空间对应的页表项</li><li>我们将 <code>UVPT</code> 虚拟地址映射到页目录本身的物理地址，并设置只读权限。这样的话，页目录中的项所对应的，就不只是二级页表，还包含有一个一级页表，也就是页目录自身。这就是自映射。</li></ul><h3 id="Exercise-3-4"><a href="#Exercise-3-4" class="headerlink" title="Exercise 3.4"></a>Exercise 3.4</h3><p>步骤如下：</p><ul><li>获取从空进程块表中获取到一个进程块</li><li>初始化新进程的地址空间</li><li>将进程块的各属性赋值（env_user_tlb_mod_entry、env_runs、env_tf.cp0_status……），手工初始化进程控制块。</li><li>将该进程块从空进程块表移除</li></ul><h3 id="Exercise-3-5"><a href="#Exercise-3-5" class="headerlink" title="Exercise 3.5"></a>Exercise 3.5</h3><p>load_icode_mapper函数</p><p>需要分配所需的物理页面，并在页表中建立映射。若 src 非空，你还需要将该处的 ELF 数据拷贝到物理页面中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Step 1: Allocate a page with &#x27;page_alloc&#x27;. */</span><br><span class="hljs-comment">/* Exercise 3.5: Your code here. (1/2) */</span><br><span class="hljs-keyword">if</span> ((r = page_alloc(p)) != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> r;<br>&#125;<br><span class="hljs-comment">/* Step 2: If &#x27;src&#x27; is not NULL, copy the &#x27;len&#x27; bytes started at &#x27;src&#x27; into &#x27;offset&#x27; at this</span><br><span class="hljs-comment"> * page. */</span><br><span class="hljs-comment">// Hint: You may want to use &#x27;memcpy&#x27;.</span><br><span class="hljs-keyword">if</span> (src != <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-comment">/* Exercise 3.5: Your code here. (2/2) */</span><br><span class="hljs-built_in">memcpy</span>((<span class="hljs-type">void</span> *)(page2kva(p) + offset), src, len);<br>&#125;<br><br><span class="hljs-comment">/* Step 3: Insert &#x27;p&#x27; into &#x27;env-&gt;env_pgdir&#x27; at &#x27;va&#x27; with &#x27;perm&#x27;. */</span><br><span class="hljs-keyword">return</span> page_insert(env-&gt;env_pgdir, env-&gt;env_asid, p, va, perm);<br></code></pre></td></tr></table></figure><h3 id="Exercise-3-6"><a href="#Exercise-3-6" class="headerlink" title="Exercise 3.6"></a>Exercise 3.6</h3><p>步骤：</p><ul><li>elf_from做类型转化并检查是否为正确的ELF文件头</li><li>接下来使用ELF_FOREACH_PHDR_OFF遍历所有程序表头，在循环中，取出对应的程序头，如果其中的 <code>p_type</code> 类型为 <code>PT_LOAD</code>，说明其对应的程序需要被加载到内存中。我们调用 <code>elf_load_seg</code> 函数来进行加载</li><li>将进程控制块中 trap frame 的 epc cp0 寄存器的值设置为 ELF 文件中设定的程序入口地址</li></ul><h3 id="Exercise-3-7"><a href="#Exercise-3-7" class="headerlink" title="Exercise 3.7"></a>Exercise 3.7</h3><p>直接创建进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">struct</span> Env *<span class="hljs-title function_">env_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *binary, <span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> priority)</span> &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">e</span>;</span><br><span class="hljs-comment">/* Step 1: Use &#x27;env_alloc&#x27; to alloc a new env, with 0 as &#x27;parent_id&#x27;. */</span><br><span class="hljs-comment">/* Exercise 3.7: Your code here. (1/3) */</span><br>env_alloc(&amp;e, <span class="hljs-number">0</span>);<br><span class="hljs-comment">/* Step 2: Assign the &#x27;priority&#x27; to &#x27;e&#x27; and mark its &#x27;env_status&#x27; as runnable. */</span><br><span class="hljs-comment">/* Exercise 3.7: Your code here. (2/3) */</span><br>e-&gt;env_pri = priority;<br>e-&gt;env_status = ENV_RUNNABLE;<br><span class="hljs-comment">/* Step 3: Use &#x27;load_icode&#x27; to load the image from &#x27;binary&#x27;, and insert &#x27;e&#x27; into</span><br><span class="hljs-comment"> * &#x27;env_sched_list&#x27; using &#x27;TAILQ_INSERT_HEAD&#x27;. */</span><br><span class="hljs-comment">/* Exercise 3.7: Your code here. (3/3) */</span><br>load_icode(e, binary, size);<br>TAILQ_INSERT_HEAD(&amp;env_sched_list, e, env_sched_link);<br><span class="hljs-keyword">return</span> e;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Exercise-3-8"><a href="#Exercise-3-8" class="headerlink" title="Exercise 3.8"></a>Exercise 3.8</h3><ul><li>保存当前进程的上下文信息。 </li></ul><p>寄存器保存的地方是KSTACKTOP以下的一个sizeof（TrapFrame）大小的区域中，达到保存上下文的目的</p><ul><li>切换 curenv 为即将运行的进程。</li><li>设置全局变量 cur_pgdir 为当前进程页目录地址，在 TLB 重填时将用到该全局变量。</li><li>调用 env_pop_tf 函数，恢复现场、异常返回。</li></ul><h3 id="Exercise-3-9"><a href="#Exercise-3-9" class="headerlink" title="Exercise 3.9"></a>Exercise 3.9</h3><p>完成异常分发代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">SAVE_ALL<br>#使用 SAVE_ALL 宏将当前上下文保存到内核的异常栈中。<br>mfc0    t0, CP0_STATUS<br>and     t0, t0, ~(STATUS_UM | STATUS_EXL | STATUS_IE)<br>mtc0    t0, CP0_STATUS<br>mfc0t0, CP0_CAUSE<br>andit0, <span class="hljs-number">0x7c</span><br>#获得 Cause 寄存器中的 <span class="hljs-number">2</span>~<span class="hljs-number">6</span> 位，也就是对应的异常码，这是区别不同异常的重要标志<br>lwt0, exception_handlers(t0)<br>jrt0<br></code></pre></td></tr></table></figure><h3 id="Exercise-3-10"><a href="#Exercise-3-10" class="headerlink" title="Exercise 3.10"></a>Exercise 3.10</h3><p>.text.exc_gen_entry 段和 .text.tlb_miss_entry 段需要被链接器放到特定的位置。</p><p>CPU 发生异常（除了用户态地址的 TLB Miss 异常）后，就会自动跳转 到地址 0x80000180 处；发生用户态地址的 TLB Miss 异常时，会自动跳转到地址 0x80000000 处。开始执行。</p><h3 id="Exercise-3-11"><a href="#Exercise-3-11" class="headerlink" title="Exercise 3.11"></a>Exercise 3.11</h3><p>时钟中断</p><p>将CP0_COUNT和CP0_COMPARE赋予适当的值</p><p>RESET_KCLOCK 宏将 Count 寄存器清零并将 Compare 寄存器配置为我们所期望的计时器周 期数，这就对 Timer 完成了配置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">mtc0t0,CP0_COMPARE<br>lit0,<span class="hljs-number">0</span><br>mtc0t0,CP0_COUNT<br></code></pre></td></tr></table></figure><h3 id="Exercise-3-12"><a href="#Exercise-3-12" class="headerlink" title="Exercise 3.12"></a>Exercise 3.12</h3><p>进程调度——时间片轮转的算法</p><p>无需进行切换时，我们只需要将剩余时间片长度 count 减去 1，然后调用 env_run 函数，继 续运行当前进程 curenv。在发生切换的情况下，我们还需要判断当前进程是否仍然就绪，如果 是则将其移动到调度链表的尾部。之后，我们选中调度链表首部的进程来调度运行，将剩余时间 片长度设置为其优先级。</p><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><h4 id="进程初始化与分配"><a href="#进程初始化与分配" class="headerlink" title="进程初始化与分配"></a>进程初始化与分配</h4><p>初始化：</p><p>map_segment 函数 $\rightarrow$ env_init 函数</p><p>分配</p><p>env_setup_vm函数：初始化新进程的地址空间 $\rightarrow$ env_alloc函数</p><h4 id="加载二进制镜像"><a href="#加载二进制镜像" class="headerlink" title="加载二进制镜像"></a>加载二进制镜像</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">load_icode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *binary, <span class="hljs-type">size_t</span> size)</span>; <br><span class="hljs-comment">//负责加载可执行文件 binary 到进程 e 的内存中。它调用的 elf_from 函数完成了解析 ELF 文件头的部分，elf_load_seg 负责将 ELF 文件的一个 segment 加载到内存。</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">load_icode_mapper</span><span class="hljs-params">(<span class="hljs-type">void</span> *data, u_long va, <span class="hljs-type">size_t</span> offset, u_int perm, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *src, <span class="hljs-type">size_t</span> len)</span><br><span class="hljs-comment">//成作为回调函数的 load_icode_mapper 函数，需要分配所需的物理页面，并在页表中建立映射。若 src 非空，需要将该处的 ELF 数据拷贝到物理页面中</span><br></code></pre></td></tr></table></figure><h4 id="进程创建与切换运行"><a href="#进程创建与切换运行" class="headerlink" title="进程创建与切换运行"></a>进程创建与切换运行</h4><p>创建：分配一个新的 Env 结构体，设置进程控制块，并将程序 载入到该进程的地址空间</p><p>进程切换的时候，为了保证下一次进入这个进程 的时候我们不会再“从头来过”，而是有记忆地从离开的地方继续往后走，我们要保存一些信息， 那么，需要保存什么信息呢？事实上，我们只需要保存进程的上下文信息，包括通用寄存器、HI、 LO 和 CP0 中的 Status，EPC，Cause 和 BadVAddr 寄存器。进程控制块除了 env_tf 其他的字 段在进程切换后还保留在原本的进程控制块中，并不会改变，因此不需要保存。（发生进程调度，或当陷入内 核时，会将当时的进程上下文环境保存在 env_tf 变量中（Trapframe结构体））</p><h4 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h4><p>时间片：比如设定某个进程的时间片的长度为 200 倍的 TIMER_INTERVAL（时钟中断间隔），那么当 MOS 记录到该进程的执行中发生了 200 个时钟中断 时，MOS 就知晓该进程的时间片结束了。</p><p>最后留下一段有意思的空间分配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">o      KSTACKTOP-----&gt; +----------------------------+----|------<span class="hljs-number">-0x8040</span> <span class="hljs-number">0000</span>-------end<br>o                      |       Kernel Stack         |    | KSTKSIZE            /|\<br>o                      +----------------------------+----|------                |<br>o                      |       Kernel Text          |    |                    PDMAP<br>o      KERNBASE -----&gt; +----------------------------+----|------<span class="hljs-number">-0x8002</span> <span class="hljs-number">0000</span>    |<br>o                      |      Exception Entry       |   \|/                    \|/<br>o      ULIM     -----&gt; +----------------------------+-----------<span class="hljs-number">-0x8000</span> <span class="hljs-number">0000</span>-------<br>o                      |         User VPT           |     PDMAP                /|\<br>o      UVPT     -----&gt; +----------------------------+-----------<span class="hljs-number">-0x7fc0</span> <span class="hljs-number">0000</span>    |<br>o                      |           pages            |     PDMAP                 |<br>o      UPAGES   -----&gt; +----------------------------+-----------<span class="hljs-number">-0x7f80</span> <span class="hljs-number">0000</span>    |<br>o                      |           envs             |     PDMAP                 |<br>o  UTOP,UENVS   -----&gt; +----------------------------+-----------<span class="hljs-number">-0x7f40</span> <span class="hljs-number">0000</span>    |<br></code></pre></td></tr></table></figure><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>本次作业围绕进程的创建、初始化、分配、映射、运行、切换等展开，难度有所提示，但大部分的操作和页表部分类似。</p>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA_OO_Unit2</title>
    <link href="/2024/03/29/BUAA-OO-Unit2/"/>
    <url>/2024/03/29/BUAA-OO-Unit2/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="BUAA-OO-Unit2第二单元总结"><a href="#BUAA-OO-Unit2第二单元总结" class="headerlink" title="BUAA_OO_Unit2第二单元总结"></a>BUAA_OO_Unit2第二单元总结</h1><h2 id="一、第一次作业"><a href="#一、第一次作业" class="headerlink" title="一、第一次作业"></a>一、第一次作业</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本次作业完成没有耗费多少时间，但由于对多线程的锁的了解不够深刻，将近花了两天时间来debug，中测也是交了五六次才通过。相比第一单元的作业，第二单元作业在代码复杂度，或者说代码量上存在明显下降，但是理解难度却有了更大的提升，以及由于加入了时间戳的原因，对于某些数据需要耗费大量时间在等待结果上。</p><h3 id="UML图架构"><a href="#UML图架构" class="headerlink" title="UML图架构"></a>UML图架构</h3><p><img src="UML2_1.png" alt="UML2_1"></p><p>本次作业中实现了三个线程类：<code>InputThread（输入线程）</code>，<code>Dispather（调度线程）</code>，<code>Elevator（电梯线程）</code></p><p>此外，<code>RequestTable</code>需求表类作为共享对象，所以内部方法全部加上<code>synchronized</code>关键字修饰，Strategy作为Elvator的附属类位电梯提供建议（按照作业提示，虽然本人觉得有点多余，但是确实代码理解起来简单）。</p><p>作业核心思路是<code>Inputread</code>读取到请求就加入到请求表中，接下来再由调度器将其分配加入各个电梯的分请求表中，当输入线程读取到EOF时电梯线程结束并将调度器Over标志设为true，当调度器的请求表为空且Over表示为true时调度器进程结束并将电梯进程Over标志设为true，对于某个电梯如果其分请求表为空且Over标志位为true时则电梯进程结束。</p><p>LOOK算法：电梯接收开门、沿着原方向运行一层、结束、等待、调转五种建议首先判断是否需要开门，如果需要开门则电梯执行开关门</p><p>然后，如果电梯内部还有人则电梯沿着原方向运行一层，反之，就判断请求表是否为空，如果请求表为空，如果请求表同时Over标志为true则该电梯进程结束，否则该电梯等待请求表填入，如果请求表不为空，则判断是否需要调整运行方向，不需要调整方向则沿着原方向运行一层。</p><p>分配关系如下</p><p><img src="Dispatch.png" alt="Dispatch"></p><h3 id="作业体会"><a href="#作业体会" class="headerlink" title="作业体会"></a>作业体会</h3><h4 id="锁的理解"><a href="#锁的理解" class="headerlink" title="锁的理解"></a>锁的理解</h4><p>由于本次作业对锁理解不够深入，于是我再次学习了相关知识：</p><p>java中有方法锁、对象锁、类锁、静态锁，核心都是为了达到访问的有序。</p><p>对象锁：JVM 在创建对象的时候，默认会给每个对象一把唯一的对象锁，一把钥匙</p><p>类锁：每一个类都是一个对象，每个对象都拥有一个对象锁。</p><p>静态锁： 在静态方法前面加上synchronized方法表示锁定此类，当多个线程调用这个类中的静态方法时会阻塞。</p><p>实例锁： 在实例方法前面加上synchronized方法表示锁定类的单个实例，当多个线程调用一个类申明的同一个实例的实例方法是会阻塞。</p><p>当多个线程用一个对象锁，各个线程可以达到同步的作用，如果每个线程都用自己的对象锁，那么synchronized就失去了同步的作用，如下代码将不起作用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedExample</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">numberOff</span><span class="hljs-params">(Object lock)</span> &#123;<br><span class="hljs-keyword">synchronized</span> (lock) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>num++;<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + SynchronizedExample.num);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><span class="hljs-type">SynchronizedExample</span> <span class="hljs-variable">se</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedExample</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">3</span>; i++) &#123;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>( ()-&gt;  &#123;se.numberOff(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());&#125;, <span class="hljs-string">&quot;队列&quot;</span>+i).start();<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>静态锁是针对静态方法而言，当一个静态方法中有synchronized关键字时，默认的是使用当前类字节码对象作为锁。</p><p>最后理解好哪些调用会互斥：</p><p>1、调用同一个对象中非静态同步方法的线程是互斥的。如果是不同对象，则每个线程有自己的对象的锁，线程间彼此互不干预。</p><p>2、调用同一个类中的静态同步方法的线程将是互斥的，它们都是锁定在相同的Class对象上。</p><p>3、静态同步方法和非静态同步方法将永远不是互斥的，因为静态方法锁定在Class对象上，非静态方法锁定在该类的对象上。</p><p>4、对于同步代码块，要看清楚什么对象已经用于锁定。在同一个对象上进行同步的线程将是互斥的，在不同对象上锁定的线程将永远不会互斥。</p><h3 id="debug过程"><a href="#debug过程" class="headerlink" title="debug过程"></a>debug过程</h3><p>花费最长时间在始终有一个进程无法唤醒，最后发现，最初架构时将电梯Over和调度器Over标志一起设置为true，这就导致了电梯进程结束了而调度器进程还没结束进而导致最后调度器进程无法结束。</p><h3 id="数据生成"><a href="#数据生成" class="headerlink" title="数据生成"></a>数据生成</h3><p>还是采用随机数生成的方法，并采用官方包进行输入输出，然后对输出结果进行如下统计分析：</p><ol><li>是否有人没上电梯</li><li>是否有人没下电梯</li><li>乘客乘坐电梯编号是否正确</li></ol><h3 id="互测"><a href="#互测" class="headerlink" title="互测"></a>互测</h3><p>本次互测通过数据生成hack成功一位TLE的同学。</p><p>和一条hack所有人的数据（当然呢，不合法！！！愚人节图一乐，后续被助教撤回）</p><h2 id="二、第二次作业"><a href="#二、第二次作业" class="headerlink" title="二、第二次作业"></a>二、第二次作业</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>本次作用增加了维修指令，在维修时要将电梯内部人员“赶”下来，同时撤回已分配请求，同时需要输出receive指令，从而要求我们具有一定的分配策略（但是，由于本人技艺不足，没有选择影子电梯，而选择了随机数大法），总的来说本次作业增加代码较少，完成起来较为顺利（可能是假期的原因）。</p><h3 id="UML图架构-1"><a href="#UML图架构-1" class="headerlink" title="UML图架构"></a>UML图架构</h3><p><img src="UML2_2.png" alt="UML2_2"></p><p>本次作业，由于采用的调度方法（随机数法）较为简单，所以相比上次只增加了一个<code>Constant</code>常数类用于维护电梯各项参数，暂时只维护了一些简单参数，从而实现了电梯内部无任何常数，代码的抽象层次更高。</p><h3 id="作业体会-1"><a href="#作业体会-1" class="headerlink" title="作业体会"></a>作业体会</h3><p>本次作业，由于电梯开始reset时，如果内部还存在乘客则将乘客“赶下来”（将targetMap中的乘客重新撤回到等已分配状态的RequestTable），然后已经分配的需求撤回到未分配队列，并清空该电梯的请求表。于是就产生了以下情况：</p><p><img src="Structure.png" alt="Structure"></p><p>即待分配队列有两个输入来源：输入线程和每个电梯，这样，如何让线程正确结束成了我亟待解决的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//调度器Dispatcher的run方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (requestTable.isOver()) &#123;<br>                <span class="hljs-keyword">for</span> (RequestTable requestTable : requestTables) &#123;<br>                    requestTable.setOver(<span class="hljs-literal">true</span>);<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!requestTable.hasNext()) &#123;<br>                requestTable.waitRequest();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                allocate();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (missionComplete()) &#123; <span class="hljs-comment">//任务完成</span><br>                requestTable.setOver(<span class="hljs-literal">true</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>当输入结束时，将输入结束标志变为true，当任务全部完成时（输入结束，且待分配队列和六个已分配队列都为空且不处于reset状态），则将总表的结束标志变为true，当总表的输入标志为true时，则把所有电梯表标为结束，调度器线程结束。</p><h3 id="Debug过程"><a href="#Debug过程" class="headerlink" title="Debug过程"></a>Debug过程</h3><p><strong><code>ConcurrentModifyException</code>问题的解决</strong></p><p><code>getPersonRequestMap()</code>方法调用时可能出现ConcurrentModifyException问题（由于上图所展示的循环导致），解决方法：由于getPersonRequestMap()加锁，所以可以通过，将所有涉及元素增减的都通过调用getPersonRequestMap()方法</p><p>互测被刀惨了，由于本人架构采用不给在维修中的电梯分配请求，于是下列方式构造的数据就把我狠狠刀住</p><ol><li>首先将某个电梯速度设为最慢，容量设为最少</li><li>在49.0s作业将其他五部电梯维修，同一时刻加入64条由11层到1层的请求，这样请求就全部加给了同一部电梯了，达到卡tle的作用</li></ol><p>解决方式：电梯分配数量加入考虑因素，当然，这不是一个好的解决方案，于是第三次作业中我换了一种方式</p><h2 id="三、第三次作业"><a href="#三、第三次作业" class="headerlink" title="三、第三次作业"></a>三、第三次作业</h2><h3 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h3><p>本次的有丝分裂电梯着实令人头疼，想了很多办法依旧没能达到很好的架构，只能不断在原来的代码的基础上一点一点叠，最后真的惨不忍睹，bug也是de完一个又来一个，到周六才大概达到一个自己满意的测试结果</p><h3 id="UML图架构-2"><a href="#UML图架构-2" class="headerlink" title="UML图架构"></a>UML图架构</h3><p><img src="UML2_3.png" alt="UML2_3"></p><p>本次总体架构相比上次无较大的改动，主要多了一个TranferFloor作为上下电梯的共同对象。代码增长主要体现在Elevator电梯类和Strategy策略类</p><p>最开始计划将双轿厢电梯作为一个新的类处理，但一直没想好处理方式加上重构面积较大，由于题目中规定了第一类reset后不会出现第二类reset，所以我，最终采取了在电梯类中增加两个Elevator类<code>upElevator</code>和<code>downElevator</code>，接收到第二类reset时，完成reset后启动改电梯的这两个线程并将其加入线程池中。</p><h3 id="作业体会-2"><a href="#作业体会-2" class="headerlink" title="作业体会"></a>作业体会</h3><p>针对上次出现的保持一个电梯不在reset，随后同时加入大量请求出现的超时bug，在bug修复中我采用的是限制单个电梯的加入到请求的数量，但是感觉还是不是特别靠谱，于是我采取调度器直接分配的方式，如果处于reset状态，就加入wait2Recive队列，reset结束后再将请求加入RequestTable中。</p><h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h3><p>先谈谈自己debug中遇到的经典问题：</p><p><strong>NullPointerException</strong></p><p>由于双轿厢电梯和普通电梯的策略类以及各种行为的方法相同，所以一不小心涉及getUpElevator之类的方法时就会涉及NullPointerException，当然这一类的bug相对来说比较容易发现</p><p><strong>防止电梯对撞问题</strong></p><p>如何防止电梯出现撞梯现象，是本次作业的核心，也是比较难处理的部分，我采用的是抢共享类中的方法锁和标志位的方式</p><ul><li><p>在决策类中，如果发现当前楼层进行move操作后到达换乘楼层，且当前换乘楼层被占用，就执行stop操作（sleep一小段时间）</p></li><li><p>当上下两电梯同时要到达换乘楼层时（下方电梯在换乘楼层的下一层且方向向上，上方电梯在换乘楼层的上一层且方向向下），就需要采用抢锁的方式了，具体如下的共享类Transferfloor的try2Move方法，当某个线程调用该方法时，将被占用位设为true，另一线程需要等另一线程的该方法结束，再调用该方法的时候就只能等待了，直到换乘楼层不再被占用才被唤醒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">try2Move</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (isFull) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        setFull(<span class="hljs-literal">true</span>);<br>        notifyAll();<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>等待换乘楼层不被占用的线程被唤醒后立即就会arrive，所以可能会出现虽然时间戳相同，但该线程的输出可能会先输出，于是我被迫采取休息1ms的方式解决这个问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">if</span> (isDoubleCar) &#123;<br>            <span class="hljs-keyword">if</span> (currentFloor == (transferFloor.getFloor() - <span class="hljs-number">1</span>) &amp;&amp; direction.equals(Direction.UP)) &#123;<br>                transferFloor.try2Move();<br>                rest(<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (currentFloor == (transferFloor.getFloor() + <span class="hljs-number">1</span>)<br>                    &amp;&amp; direction.equals(Direction.DOWN)) &#123;<br>                transferFloor.try2Move();<br>                rest(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="总体总结"><a href="#总体总结" class="headerlink" title="总体总结"></a>总体总结</h2><h3 id="前言以及相关图"><a href="#前言以及相关图" class="headerlink" title="前言以及相关图"></a>前言以及相关图</h3><p>由于本人对影子电梯的理解不够，选择的是实现起来极其简单收益也尚可的随机数法，所以代码规模相比使用影子电梯的同学要少，但是最让自己都无法接受的就是电梯类中参杂了太多的因素——既有电梯自身的属性，又有作为线程所包括的各种运行方法，还实现了第二类reset后的线程相关的线程启动，包含了大量的if，着实不是一个好的架构。</p><p><img src="codeLines.png" alt="codeLines"></p><p>总体代码时序图：<img src="SequenceDiagram.svg" alt="SequenceDiagram"></p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>从第一次作业到第三次作业，每次花费时间最多的就是de线程安全的bug，直到最终版本，代码依旧存在极小概率的bug</p><p>其中下面这个bug是我感悟最深。</p><p>我们知道，在我们采用增强for循环遍历时若删除对象是线程不安全的，于是我们引进了迭代器删除的方法，但是在多线程中，对于共享对象即使采用迭代器删除仍然需要采用对对象加锁的方式保证线程安全，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (requestTable) &#123; <span class="hljs-comment">//同步</span><br>                Iterator&lt;PersonRequest&gt; iterator = personRequests.iterator();<br>                <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                    <span class="hljs-comment">/**/</span><br><span class="hljs-comment">                        iterator.remove();</span><br><span class="hljs-comment">                        requestTable.subRequestNum();</span><br><span class="hljs-comment">                    &#125;</span><br><span class="hljs-comment">                &#125;</span><br><span class="hljs-comment">            &#125;</span><br></code></pre></td></tr></table></figure><p>而不加入对象锁时，运行结果可能正确，而且输入可能需要多次运行才能复现bug。</p><p>总的来说，单纯的方法锁和对象锁不足以满足后续更加复杂的情况，于是我们也又有了互斥锁（一次最多只能有一个线程持有的锁）、读写锁，可重入锁（可重复可递归调用的锁，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者class））与不可重入锁……</p><h3 id="层次化设计"><a href="#层次化设计" class="headerlink" title="层次化设计"></a>层次化设计</h3><p><strong>线程设计</strong></p><ul><li>输入线程</li><li>调度线程</li><li>轿厢线程</li></ul><p>总体来说，经过总结思考，把轿厢而不是电梯作为线程更加可靠，也更加能够适应第三次作业，我的架构仅支持第二类reset后无任何reset，但是倘若可以来回reset，将轿厢作为线程，并将单轿厢电梯和双轿厢电梯作为两个类保证其自身特性可以更适应后续迭代（倘若有的话）</p><p><strong>共享类设计</strong></p><ul><li>请求表</li><li>换乘楼层</li></ul><p>将请求表作为共享类毫无争议，第三次作业中将换乘楼层作为双轿厢的共享类着实方便，可以通过抢锁十分方便的实现避免撞梯。</p><p><strong>枚举类</strong></p><ul><li>方向</li><li>电梯策略</li></ul><p>将方向作为枚举是我考虑到可能会出现上下左右乱移动设计的（可惜没有），虽然便于理解代码，但是远不如+-1代表方向来的方便。电梯策略作为枚举十分有必要，处理不同策略，用英文枚举着实提高可阅读性。</p><p>经过一个单元的学习，让我对多线程知识的了解增进了不少，从简单的方法锁对象锁的使用到抢锁实现交互的实现，对并行程序的书写不仅让我的OO水平狠狠提高（虽然预判的迭代都失败了，但是希望下届可以有hhh），对OS的帮助也是多多。</p>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象OO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA_OO_Unit3</title>
    <link href="/2024/03/29/BUAA-OO-Unit3/"/>
    <url>/2024/03/29/BUAA-OO-Unit3/</url>
    
    <content type="html"><![CDATA[<h1 id="BUAA-OO-第三单元总结"><a href="#BUAA-OO-第三单元总结" class="headerlink" title="BUAA_OO_第三单元总结"></a>BUAA_OO_第三单元总结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JML的使用让作业的思维难度大大降低，如果仅考虑完成任务上，只需要照葫芦画瓢根据JML写出代码即可，不需要在整体的架构上有自己独一无二的思考。但是，正是由于这一点，给了我五一假期偷懒的机会，导致我在第二次作业的性能上狠狠丢失分数，实乃得不偿失啊。</p><h2 id="代码层次总结"><a href="#代码层次总结" class="headerlink" title="代码层次总结"></a>代码层次总结</h2><h3 id="JML架构图"><a href="#JML架构图" class="headerlink" title="JML架构图"></a>JML架构图</h3><p><img src="UML3.png" alt="UML3"></p><p>这次架构有了官方包的约束，大家几乎相同，主要差异体现在性能差异上</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><h4 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h4><p>由于没有假期，测试做的比较足，性能也相对较好</p><h5 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h5><p>搜索了很多有关可维护并查集的介绍，但都不太能够达到自己想要的结果，最终干脆按照最常见的思路加上重建解决删边问题。</p><p>实现上还是并查集的核心思路：路径压缩+按秩合并来保证查询效率，同时引入cnt记录连通块个数用于后续查询，但是由于并查集并不适用于删除边的操作，但是我又舍不得并查集对是否连接以及连通块个数极其快速的查询效率，于是我又引入了重建并查集的方法，采取缓查询的方法（只有查询连通块个数时才需要判断是否需要重建）</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DisjointSetUnion</span> &#123;<br>    <span class="hljs-keyword">private</span> HashMap&lt;Integer, Integer&gt; fa;<br>    <span class="hljs-keyword">private</span> HashMap&lt;Integer, Integer&gt; rank;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> need2Rebuild;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cnt;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">getCnt</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> id1, <span class="hljs-type">int</span> id2)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">isCircle</span><span class="hljs-params">(<span class="hljs-type">int</span> id1, <span class="hljs-type">int</span> id2)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">rebuild</span><span class="hljs-params">(HashMap&lt;Integer, MyPerson&gt; persons)</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>性能方面主要涉及以下三个方法</p><ul><li><h5 id="public-boolean-isCircle-int-id1-int-id2"><a href="#public-boolean-isCircle-int-id1-int-id2" class="headerlink" title="public boolean isCircle(int id1, int id2)"></a>public boolean isCircle(int id1, int id2)</h5></li></ul><p>由于实现了并查集，我采用了二者结合，如果并查集没有没有被破坏，直接使用并查集判断id1和id2是否在一起，否则，则采取dfs方式判断路径是否可达（需要重建时，dfs的效率更高）。</p><ul><li><h5 id="public-int-queryBlockSum"><a href="#public-int-queryBlockSum" class="headerlink" title="public int queryBlockSum()"></a>public int queryBlockSum()</h5></li></ul><p>有了并查集实现就相对简单了，不需要重建时直接实现O（1）的时间复杂度可以说是相当快了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">dsu.rebuild(persons);<br><span class="hljs-keyword">return</span> dsu.getCnt();<br></code></pre></td></tr></table></figure><ul><li><h5 id="public-int-queryTripleSum"><a href="#public-int-queryTripleSum" class="headerlink" title="public int queryTripleSum()"></a>public int queryTripleSum()</h5></li></ul><p>直接暴力O（n^3）的时间复杂度</p><p>于是我采用在加边和删边时采用动态维护</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//加边</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> id : person1.getAcquaintance().keySet()) &#123;<br>    <span class="hljs-keyword">if</span> (isLinked(id, id2) &amp;&amp; id != id2 &amp;&amp; id != id1 &amp;&amp; id1 != id2) &#123;<br>        tripleSum++;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//删边</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> id : person1.getAcquaintance().keySet()) &#123;<br>    <span class="hljs-keyword">if</span> (isLinked(id, id2) &amp;&amp; id != id2 &amp;&amp; id != id1) &#123;<br>        tripleSum--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h4><p>性能主要涉及以下方面</p><ul><li><h5 id="public-int-getValueSum"><a href="#public-int-getValueSum" class="headerlink" title="public int getValueSum()"></a>public int getValueSum()</h5></li></ul><p>推荐写法如下，内部遍历person1的所有acquaintance而不是直接遍历Tag里的所有person，当tag里是完全图时，明显前面的时间复杂度更低（O（n*log（n）和 O（n^2））），我也栽在了这里</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getValueSum</span>()</span> &#123;<br>    <span class="hljs-built_in">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> id1 : persons.keySet()) &#123;<br>        MyPerson person1 = persons.<span class="hljs-keyword">get</span>(id1);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> id2 : person1.getAcquaintance().keySet()) &#123;<br>            <span class="hljs-keyword">if</span> (persons.containsKey(id2)) &#123;<br>                sum += person1.queryValue(persons.<span class="hljs-keyword">get</span>(id2));<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><h5 id="public-int-queryBestAcquaintance-和public-int-queryCoupleSum"><a href="#public-int-queryBestAcquaintance-和public-int-queryCoupleSum" class="headerlink" title="public int queryBestAcquaintance()和public int queryCoupleSum()"></a>public int queryBestAcquaintance()和public int queryCoupleSum()</h5></li></ul><p>归根到底是动态维护一个bestAcquaintanceid</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">if</span> (!needUpdate || value.<span class="hljs-property">isEmpty</span>()) &#123;<br>    <span class="hljs-keyword">return</span> bestAcquaintanceId;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-built_in">max</span> = <span class="hljs-number">-0xfffffff</span>;<br><span class="hljs-type">int</span> ba = <span class="hljs-variable">this</span>.<span class="hljs-property">bestAcquaintanceId</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-built_in">key</span> : value.<span class="hljs-property">keySet</span>()) &#123;<br>    <span class="hljs-keyword">if</span> (value.<span class="hljs-property">get</span>(<span class="hljs-built_in">key</span>) &gt; <span class="hljs-built_in">max</span> || (value.<span class="hljs-property">get</span>(<span class="hljs-built_in">key</span>) == <span class="hljs-built_in">max</span> &amp;&amp; <span class="hljs-built_in">key</span> &lt; ba)) &#123;<br>        <span class="hljs-built_in">max</span> = value.<span class="hljs-property">get</span>(<span class="hljs-built_in">key</span>);<br>        ba = <span class="hljs-built_in">key</span>;<br>    &#125;<br>&#125;<br><span class="hljs-variable">this</span>.<span class="hljs-property">bestAcquaintanceId</span> = ba;<br>needUpdate = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span> ba;<br></code></pre></td></tr></table></figure><p>其次queryCoupleSum（）也不能暴力for循环，加一个visited数组，然后判断两个人的bestAcquaintanceId是否各为对方的bestAcquaintanceId。</p><h4 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h4><p>没啥新意，对应建立父类子类关系以及调用接口关系即可，但是JML长的可怕——只得细细品味了。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>到最后一次作业，总共设计十二个异常处理，区别仅仅在于输出和计数，我实现了一个Counter类进行对每一类异常都进行了计数，现在一想，完全可以抽象为两个方法，但是可读性就没有那么好了。</p><p>注意：Counter类一定要是静态变量</p><h3 id="Juint测试总结"><a href="#Juint测试总结" class="headerlink" title="Juint测试总结"></a>Juint测试总结</h3><p>我采用是的和实验中相同的思路——利用随机数生成指定组随机数据，受限于官方包和评测，由于个人几乎都是用的是HashMap，容器的深克隆只能够通过在构造数据时实现一个一模一样的对象实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Java">i<span class="hljs-meta">@RunWith(Parameterized.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyNetworkTest</span> &#123;<br>    <span class="hljs-keyword">private</span> MyNetwork myNetwork;<br>    <span class="hljs-keyword">private</span> MyNetwork clone;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyNetworkTest</span><span class="hljs-params">(MyNetwork myNetwork, MyNetwork clone)</span> &#123;<br>        <span class="hljs-built_in">this</span>.myNetwork = myNetwork;<br>        <span class="hljs-built_in">this</span>.clone = clone;<br>    &#125;<br><br>    <span class="hljs-meta">@Parameters</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Collection <span class="hljs-title function_">prepareData</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">seed</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(seed);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">testNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        Object[][] object = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[testNum][];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; testNum; i++) &#123;<br>            <span class="hljs-comment">//……</span><br>            object[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;myNetwork, clone&#125;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Arrays.asList(object);<br>    &#125;<br><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteColdEmojiTest</span><span class="hljs-params">()</span> ;<br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">queryCoupleSum</span><span class="hljs-params">()</span> ;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>数据生成思路</p><p>由于仅仅用于测试，数据生成较为简单。</p><p>第一次和第二次作业数据生成思路大致相同，尽可能生成完全图，按照生成人、随机加关系、随机改关系的步骤进行。</p><p>第三次作业由于只需测试<code>deleteColdEmojiTest()</code>方法，所以只需要建立两个人，按照随机生成信息，若是表情包则储存，在两个人之间不断发送信息（但是不把信息全部发完）</p><p>测试思路主要是根据JML语言设置</p><ul><li>方法是否安全</li><li>返回值是否正确</li><li>……</li></ul><p><strong>怎么在Junit测试中实现规格一致性</strong></p><p>以<code>deleteColdEmojiTest()</code>方法为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*@ public normal_behavior</span><br><span class="hljs-comment">     @ assignable emojiIdList, emojiHeatList, messages;</span><br><span class="hljs-comment">     @ ensures (\forall int i; 0 &lt;= i &amp;&amp; i &lt; \old(emojiIdList.length);</span><br><span class="hljs-comment">     @          (\old(emojiHeatList[i] &gt;= limit) ==&gt;</span><br><span class="hljs-comment">     @          (\exists int j; 0 &lt;= j &amp;&amp; j &lt; emojiIdList.length; emojiIdList[j] == \old(emojiIdList[i]))));</span><br><span class="hljs-comment">     @ ensures (\forall int i; 0 &lt;= i &amp;&amp; i &lt; emojiIdList.length;</span><br><span class="hljs-comment">     @          (\exists int j; 0 &lt;= j &amp;&amp; j &lt; \old(emojiIdList.length);</span><br><span class="hljs-comment">     @          emojiIdList[i] == \old(emojiIdList[j]) &amp;&amp; emojiHeatList[i] == \old(emojiHeatList[j])));</span><br><span class="hljs-comment">     @ ensures emojiIdList.length ==</span><br><span class="hljs-comment">     @          (\num_of int i; 0 &lt;= i &amp;&amp; i &lt; \old(emojiIdList.length); \old(emojiHeatList[i] &gt;= limit));</span><br><span class="hljs-comment">     @ ensures emojiIdList.length == emojiHeatList.length;</span><br><span class="hljs-comment">     @ ensures (\forall int i; 0 &lt;= i &amp;&amp; i &lt; \old(messages.length);</span><br><span class="hljs-comment">     @          (\old(messages[i]) instanceof EmojiMessage &amp;&amp;</span><br><span class="hljs-comment">     @           containsEmojiId(\old(((EmojiMessage)messages[i]).getEmojiId()))  ==&gt; \not_assigned(\old(messages[i])) &amp;&amp;</span><br><span class="hljs-comment">     @           (\exists int j; 0 &lt;= j &amp;&amp; j &lt; messages.length; messages[j].equals(\old(messages[i])))));</span><br><span class="hljs-comment">     @ ensures (\forall int i; 0 &lt;= i &amp;&amp; i &lt; \old(messages.length);</span><br><span class="hljs-comment">     @          (!(\old(messages[i]) instanceof EmojiMessage) ==&gt; \not_assigned(\old(messages[i])) &amp;&amp;</span><br><span class="hljs-comment">     @           (\exists int j; 0 &lt;= j &amp;&amp; j &lt; messages.length; messages[j].equals(\old(messages[i])))));</span><br><span class="hljs-comment">     @ ensures messages.length == (\num_of int i; 0 &lt;= i &amp;&amp; i &lt; \old(messages.length);</span><br><span class="hljs-comment">     @          (\old(messages[i]) instanceof EmojiMessage) ==&gt;</span><br><span class="hljs-comment">     @           (containsEmojiId(\old(((EmojiMessage)messages[i]).getEmojiId()))));</span><br><span class="hljs-comment">     @ ensures \result == emojiIdList.length;</span><br><span class="hljs-comment">     @*/</span><br></code></pre></td></tr></table></figure><p>JML规格描述中一共存在8个ensure，我们就要尽可能去检查每个ensure，某些在实现中已经默认保证的就无需检查，以下是我的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">limit</span> <span class="hljs-operator">=</span> random.nextInt(<span class="hljs-number">10</span>) + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> [] emojiIdList1 = myNetwork.getEmojiIdList();<br>        <span class="hljs-type">int</span> [] emojiHeatList1 = myNetwork.getEmojiHeatList();<br>        HashMap &lt;Integer, Integer&gt; ha = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; emojiIdList1.length; i++) &#123;<br>            ha.put(emojiIdList1[i], emojiHeatList1[i]);<br>        &#125;<br>        Message [] messageList1 = myNetwork.getMessages();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> messageList1.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">emojiMessagecnt1</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; messageList1.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (messageList1[i] != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (messageList1[i].getClass().getName().equals(<span class="hljs-string">&quot;MyEmojiMessage&quot;</span>)) &#123;<br>                    emojiMessagecnt1++;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> myNetwork.deleteColdEmoji(limit);<br>        <span class="hljs-type">int</span> [] emojiIdList2 = myNetwork.getEmojiIdList();<br>        <span class="hljs-type">int</span> [] emojiHeatList2 = myNetwork.getEmojiHeatList();<br>        Message [] messageList2 = myNetwork.getMessages();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">emojiMessagecnt2</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; messageList2.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (messageList2[i] != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (messageList2[i].getClass().getName().equals(<span class="hljs-string">&quot;MyEmojiMessage&quot;</span>)) &#123;<br>                    emojiMessagecnt2++;<br>                &#125;<br>            &#125;<br>        &#125;<br><span class="hljs-comment">//检查是否删去了非emojiMessage</span><br>        assertEquals(size - emojiMessagecnt1,messageList2.length - emojiMessagecnt2);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">expect</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; emojiHeatList1.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (emojiHeatList1[i] &lt; limit) &#123;<br>                <span class="hljs-comment">//检查是否所有coldEmojiMessage是否从emojiIdList删去</span><br>                assertFalse(myNetwork.containsEmojiId(emojiIdList1[i]));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                expect++;<br>            &#125;<br>        &#125;<br><span class="hljs-comment">//检查返回值是否正确</span><br>        assertEquals(expect, ans);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; messageList2.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (messageList2[i] != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (messageList2[i].getClass().getName().equals(<span class="hljs-string">&quot;MyEmojiMessage&quot;</span>)) &#123;<br>                    <span class="hljs-type">MyEmojiMessage</span> <span class="hljs-variable">mem</span> <span class="hljs-operator">=</span> (MyEmojiMessage) messageList2[i];<br>                    <span class="hljs-keyword">if</span> (ha.containsKey(mem.getEmojiId()) &amp;&amp; ha.get(mem.getEmojiId()) &lt; limit) &#123;<br>                        <span class="hljs-comment">//检查是否所有coldEmojiMessage是否从Message删去</span><br>                        assertEquals(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p><strong>如何利用规格信息来更好的设计实现Junit测试?</strong></p><p>我将其归纳为以下几条</p><ul><li>通过require信息生成对应数据</li><li>通过ensure信息测试对应结果</li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>这次作业由于中测数据没有任何参考价值，加上测试平台与本地测试运行时间的差距，做好本地测试尤为重要。</p><h3 id="黑箱测试和白箱测试"><a href="#黑箱测试和白箱测试" class="headerlink" title="黑箱测试和白箱测试"></a>黑箱测试和白箱测试</h3><p>维基百科对各自定义如下：</p><ul><li><strong>黑箱测试</strong>也称功能测试、数据驱动测试或基于规格说明的测试。测试者只知道程序的输入、输出和系统的功能，这是从使用者的角度针对软件的接口、功能及外部结构进行的测试，不考虑程序内部实现逻辑。</li><li><strong>白箱测试</strong>也称结构测试、逻辑驱动测试或基于程序本身的测试，测试程序内部结构或运行。在白箱测试时，从程序设计语言的角度来设计测试样例。测试者输入数据并验证数据在程序中的流动路径，并确定适当的输出，类似测试电路中的节点。</li></ul><p>课程组的测试就是名副其实的黑箱测试，不仅输入输出未知，甚至时间也完全未知。利用他人的评测机也是黑盒测试，尤其是在数据生成的效果不太好时，覆盖率率低，是一种简单但充满随机性的测试</p><p>Junit单元测试是一种比较好的也是比较典型的白箱测试，测试数据以及流程清晰，但是大规模测试实现比较难，也比较费事费时。</p><h3 id="各类测试的理解"><a href="#各类测试的理解" class="headerlink" title="各类测试的理解"></a>各类测试的理解</h3><ul><li>单元测试</li></ul><p>是指对软件的最小功能模块进行测试的方法，实现单个方法的测试，规模小，测试覆盖率高</p><ul><li>功能测试</li></ul><p>是指队整个软件用于保证功能测试</p><ul><li>集成测试</li></ul><p>进行单元测试后，将各个单元集合起来一起测试</p><ul><li>压力测试</li></ul><p>压力测试是指对软件进行高负载和高并发的测试，在本单元的作业中体现在边界数据与大数据卡CTLE</p><ul><li>回归测试</li></ul><p>回归测试是在软件系统进行修改或者升级后，重新运行之前的测试用例已验证修改是否引入新的错误或导致原有功能出现错误的方法。这在我们进行迭代remake时用的比较多，把remake后的代码再交一次之前作业的测试</p><h3 id="数据构造"><a href="#数据构造" class="headerlink" title="数据构造"></a>数据构造</h3><p>本单元的数据的构造主要体现在图的构造，如何构造出更加有效的图是本次作业的核心</p><p>随机生成指令时一定遇到生成的图过于稀疏，在进行各类操作时几乎都是异常，这样显然不可取。</p><p>于是采用先生成一个完全图再进行各类修边改边，这样就保证了既有稠密的部分又有稀疏的部分。</p><p>python的networkx，cyaron，plotly库可以查看生成的图！</p><h2 id="分析总结"><a href="#分析总结" class="headerlink" title="分析总结"></a>分析总结</h2><p>面向JML书写代码着实很爽，bug定位也容易，但是书写JML和阅读JML并不是容易事情，所以希望未来课程可以有！！！</p>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象OO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA_OS_lab2</title>
    <link href="/2024/03/21/BUAA-OS-lab2/"/>
    <url>/2024/03/21/BUAA-OS-lab2/</url>
    
    <content type="html"><![CDATA[<h1 id="BUAA-OS-lab2学习日记"><a href="#BUAA-OS-lab2学习日记" class="headerlink" title="BUAA_OS_lab2学习日记"></a>BUAA_OS_lab2学习日记</h1><h2 id="一、思考题Thinking"><a href="#一、思考题Thinking" class="headerlink" title="一、思考题Thinking"></a>一、思考题Thinking</h2><h3 id="Thinking-2-1"><a href="#Thinking-2-1" class="headerlink" title="Thinking 2.1"></a>Thinking 2.1</h3><p>问题：在编写的 C 程序中，指针变量中存储的地址 被视为虚拟地址，还是物理地址？MIPS 汇编程序中 lw 和 sw 指令使用的地址被视为虚拟 地址，还是物理地址？</p><p>答：均为虚拟地址，访存、跳转等指令以及用于取指的 PC 寄存器中的访存目标地 址都是虚拟地址。我们编写的 C 程序中也经常通过对指针解引用来进行访存，其中指针的值也 会被视为虚拟地址，经过编译后生成相应的访存指令。也就说编译后指针所存储的地址才会变为物理地址。</p><h3 id="Thinking-2-2"><a href="#Thinking-2-2" class="headerlink" title="Thinking 2.2"></a>Thinking 2.2</h3><p>问题：</p><ul><li>从可重用性的角度，阐述用宏来实现链表的好处。</li><li>查看实验环境中的/usr/include/sys/queue.h，了解其中单向链表与循环链表的实 现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。</li></ul><p>答：</p><ul><li>简化代码量，使用宏定义可以减少代码的服用对函数进行封装，提高了代码的可读性。</li><li>以下是各自特性<ul><li>单向链表：如果要执行删除某一节点的下一个节点和在某一结点后插入可以直接进行，此外，由于每次能访问一个节点的下一个节点，插入节点和删除节点相同，每次必须从头节点遍历找到节点才能找到进行删除和插入操作。</li><li>循环链表如果要执行删除某一节点和在某一结点后插入可以直接进行，此外，由于循环链表也是单向链表，每次也只能访问一个节点的后一个节点，但是每次遍历时不必从头节点开始。</li><li>双向链表可访问某一节点的前后节点，在某一节点前后插入或删除前后节点都可以直接执行，此外查找删除操作对于某些链表还可以使用二分法提高效率。</li></ul></li></ul><h3 id="Thinking-2-3"><a href="#Thinking-2-3" class="headerlink" title="Thinking 2.3"></a>Thinking 2.3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//核心相关代码如下</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">LIST_ENTRY</span><span class="hljs-params">(Page)</span> Page_LIST_entry_t;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_ENTRY(type)                                                               </span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>                                    <br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">type</span> *<span class="hljs-title">le_next</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">type</span> **<span class="hljs-title">le_prev</span>;</span>             <br>    &#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> &#123;</span><br>Page_LIST_entry_t pp_link; <br>u_short pp_ref;<br>&#125;;<br>LIST_HEAD(Page_list, Page);<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LIST_HEAD(name, type)               </span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">name</span> &#123;</span>                                                                         <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">type</span> *<span class="hljs-title">lh_first</span>;</span> <br>&#125;<br></code></pre></td></tr></table></figure><p>综上可以选出C</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page_list</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">le_next</span>;</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> **<span class="hljs-title">le_prev</span>;</span><br>        &#125; pp_link;<br>    u_short pp_ref;<br>    &#125;* lh_first;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Thinking-2-4"><a href="#Thinking-2-4" class="headerlink" title="Thinking 2.4"></a>Thinking 2.4</h3><p>问题：</p><ul><li>请阅读上面有关 TLB 的描述，从虚拟内存和多进程操作系统的实现角度，阐述 ASID 的必要性。</li><li>请阅读 MIPS 4Kc 文档《MIPS32® 4K™ Processor Core Family Software User’s Manual》的 Section 3.3.1 与 Section 3.4，结合 ASID 段的位数，说明 4Kc 中可容纳不同的地址空间的最大数量。</li></ul><p>答：</p><ul><li>ASID用于区分不同的地址空间，在多进程操作系统中，由于同一虚拟地址在不同的地址空间中通常映射到不同的物理地址，使用ASID区分不同的地址空间可以保证不用每次切换进程时TLB也要改变。</li><li>ASID有8位，可以区分256个不同的地址空间。</li></ul><h3 id="Thinking-2-5"><a href="#Thinking-2-5" class="headerlink" title="Thinking 2.5"></a>Thinking 2.5</h3><p> 请回答下述三个问题：</p><ul><li>tlb_invalidate 和 tlb_out 的调用关系？</li><li>请用一句话概括 tlb_invalidate 的作用。</li><li>逐行解释 tlb_out 中的汇编代码。</li></ul><p>答：</p><ul><li>```C<br>//由函数声明可以看出tlb_invalidate调用tlb_out<br>void tlb_invalidate(u_int asid, u_long va) {<pre><code class="hljs">tlb_out((va &amp; ~GENMASK(PGSHIFT, 0)) | (asid &amp; (NASID - 1)));</code></pre>}<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><br>- 实现删除特定虚拟地址在 TLB 中的旧表项<br><br>- ```C<br>  <span class="hljs-comment">#include &lt;asm/asm.h&gt;</span><br>  <br>  LEAF(tlb_out)<br>  <span class="hljs-meta">.set</span> <span class="hljs-keyword">noreorder</span><br><span class="hljs-keyword"></span>  <span class="hljs-keyword">mfc0 </span>   <span class="hljs-built_in">t0</span>, CP0_ENTRYHI <br>  <span class="hljs-comment">/*将当前EntryHi寄存器的值赋给t0保存当前的VPN和ASID*/</span><br>  <span class="hljs-keyword">mtc0 </span>   <span class="hljs-built_in">a0</span>, CP0_ENTRYHI<br>  <span class="hljs-comment">/*将调用函数传入的参数即新的VPN和ASID写入EntryHi寄存器*/</span><br>  <span class="hljs-keyword">nop </span><br>  <span class="hljs-comment">/*冒险处理*/</span><br>  <span class="hljs-comment">/* Step 1: Use &#x27;tlbp&#x27; to probe TLB entry */</span><br>  <span class="hljs-comment">/* Exercise 2.8: Your code here. (1/2) */</span><br>  <span class="hljs-keyword">tlbp</span><br>  <span class="hljs-comment">/*根据 EntryHi中的Key查找对应的旧表项，将表项的索引存入CP0_INDEX*/</span><br>  <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span>  <span class="hljs-comment">/* Step 2: Fetch the probe result from CP0.Index */</span><br>  <span class="hljs-keyword">mfc0 </span>   <span class="hljs-built_in">t1</span>, CP0_INDEX<br>      <span class="hljs-comment">/*取出CP0的值*/</span><br>  <span class="hljs-meta">.set</span> reorder<br>  <span class="hljs-keyword">bltz </span>   <span class="hljs-built_in">t1</span>, NO_SUCH_ENTRY<br>      <span class="hljs-comment">/*如果没有查到对应表项*/</span><br>  <span class="hljs-meta">.set</span> <span class="hljs-keyword">noreorder</span><br><span class="hljs-keyword"></span>  <span class="hljs-keyword">mtc0 </span>   <span class="hljs-built_in">zero</span>, CP0_ENTRYHI<br>  <span class="hljs-keyword">mtc0 </span>   <span class="hljs-built_in">zero</span>, CP0_ENTRYLO0<br>  <span class="hljs-keyword">mtc0 </span>   <span class="hljs-built_in">zero</span>, CP0_ENTRYLO1<br>      <span class="hljs-comment">/*将CP0_ENTRYHI、CP0_ENTRYLO0、CP0_ENTRYLO1三个寄存器赋值为0，后续写入实现清零*/</span><br>  <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span>  <span class="hljs-comment">/* Step 3: Use &#x27;tlbwi&#x27; to write CP0.EntryHi/Lo into TLB at CP0.Index  */</span><br>  <span class="hljs-comment">/* Exercise 2.8: Your code here. (2/2) */</span><br>  <span class="hljs-keyword">tlbwi</span><br><span class="hljs-keyword"></span>      <span class="hljs-comment">/*将 EntryHi 和 EntryLo0、EntryLo1 中的值写入索引指定的表项*/</span><br>  <span class="hljs-meta">.set</span> reorder<br><span class="hljs-symbol">  </span><br><span class="hljs-symbol">  NO_SUCH_ENTRY:</span><br>  <span class="hljs-keyword">mtc0 </span>   <span class="hljs-built_in">t0</span>, CP0_ENTRYHI<br>      <span class="hljs-comment">/*将t0的值写回CP0_ENTRYHI*/</span><br>  <span class="hljs-keyword">j </span>      <span class="hljs-built_in">ra</span><br>      <span class="hljs-comment">/*函数返回*/</span><br>  END(tlb_out)<br></code></pre></td></tr></table></figure></li></ul><h3 id="Thinking-2-6"><a href="#Thinking-2-6" class="headerlink" title="Thinking 2.6"></a>Thinking 2.6</h3><p>问题：</p><ul><li>简单了解并叙述 X86 体系结构中的内存管理机制，比较 X86 和 MIPS 在内存管理上的区别。</li><li>简单了解并叙述 RISC-V 中的内存管理机制，比较 RISC-V 与 MIPS 在内存管理上的区别。</li><li>简单了解并叙述 LoongArch 中的内存管理机制，比较 LoongArch 与 MIPS 在内存管理上的区别。</li></ul><p>答：</p><ul><li>在x86架构中内存被分为三种形式，分别是<strong>逻辑地址</strong>（Logical Address），<strong>线性地址</strong>（Linear Address）和<strong>物理地址</strong>（Physical Address）。而mips内存只有两种形式。X86 体系结构中的内存管理机制是基于分段和分页的。分段是将程序的地址空间划分为若干个段，每个段都有自己的基地址和长度，可以独立地进行保护和共享。而X86在TLB不命中时，是由硬件MMU以<code>CR3</code>为当前进程的PGD基址，索引获得PFN后，直接输出PA。同时MMU会填充TLB以加快下次转换的速度。另外转换失败的虚址，MIPS使用<code>BadVAddr</code>寄存器存放，X86使用<code>CR2</code>存放。</li><li>RISC-V提供三种权限模式（MSU），而MIPS只提供内核态和用户态两种权限状态。RISC-V SV39支持39位虚拟内存空间，每一页占用4KB，使用三级页表访存。</li><li>硬件能够支持两级地址翻译，x86到LoongArch+虚地址到物理地址（通过改造内存快表TLB，做到两级虚地址映射以减少映射开销，以及减少指令使用/指令翻译开销，即X86虚地址直接翻译成龙芯物理地址）</li></ul><h3 id="Thinking-A-1"><a href="#Thinking-A-1" class="headerlink" title="Thinking A.1"></a>Thinking A.1</h3><p>问题：在现代的 64 位系统中，提供了 64 位的字长，但实际上不是 64 位页式存储系统。假设在 64 位系统中采用三级页表机制，页面大小 4KB。由于 64 位系统中字长为 8B，且页目录也占用一页，因此页目录中有 512 个页目录项，因此每级页表都需要 9 位。 因此在 64 位系统下，总共需要 3 × 9 + 12 = 39 位就可以实现三级页表机制，并不需要 64 位。现考虑上述 39 位的三级页式存储系统，虚拟地址空间为 512 GB，若三级页表的基地址为 PTbase，请计算：</p><ul><li>三级页表页目录的基地址。</li><li>映射到页目录自身的页目录项（自映射）。</li></ul><p>答：</p><p>分析：页目录通常指一级页表，以二级页表为例：</p><p>页目录的1024 个表项映射到这 1024 个页表。因此只需要 4MB 的空间即可容纳页表和页目录。</p><p><img src="page.png" alt="页目录自映射"></p><p>同理，本题中，三级页表中，页目录的512个二级页表项映射到512个三级页表映射到512个页表。虚拟地址可以化为 $2^{39} / 2^{12} = 2 ^ {27}$ 页，既需要 $2^{27}$ 个页表项接收这么多个页表的映射。</p><p><img src="page3result.png" alt="页目录映射关系"></p><p><img src="page3.png" alt="page3"></p><p>于是页号： <code>PN = PTBase &gt;&gt; 12</code>;</p><p>二级页表的基地址：<code>PTTBase = PTBase + PN* 8 = PTBase + PTBase &gt;&gt; 9</code></p><p>一级页表(页目录)的基地址：<code>PSTBase = PTBase + (PTTBase &gt;&gt; 12)*8</code></p><p>映射到页目录自身的页目录项的地址：<code>PDBase =PTBase + (PSTBase &gt;&gt; 12)*8  = PTBase + PTBase &gt;&gt; 9 + PTBase &gt;&gt; 18 + PTBase &gt;&gt; 27</code></p><h2 id="二、Exercise"><a href="#二、Exercise" class="headerlink" title="二、Exercise"></a>二、Exercise</h2><h3 id="exercise-2-1"><a href="#exercise-2-1" class="headerlink" title="exercise 2.1"></a>exercise 2.1</h3><p><code>mmu.h</code>文件中定义了page的大小根据物理内存/页面大小即可求出页面数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PAGE_SIZE 4096</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGSHIFT 12</span><br></code></pre></td></tr></table></figure><h3 id="exercise-2-2"><a href="#exercise-2-2" class="headerlink" title="exercise 2.2"></a>exercise 2.2</h3><p>易错点：指向下一个元素的指针 le_next，以及指向前一个元素链表项 le_next 的指针 le_prev（指针的指针）</p><h3 id="exercise-2-3"><a href="#exercise-2-3" class="headerlink" title="exercise 2.3"></a>exercise 2.3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C">LIST_INIT(&amp;page_free_list);<br>freemem = ROUND(freemem,PAGE_SIZE);<br>u_long usedpage = PPN(PADDR(freemem));<br><span class="hljs-keyword">for</span> (u_long i = <span class="hljs-number">0</span>;i &lt; usedpage;i ++) &#123;<br>pages[i].pp_ref = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (u_long i = usedpage;i &lt; npage;i ++) &#123;<br>pages[i].pp_ref = <span class="hljs-number">0</span>;<br>LIST_INSERT_HEAD(&amp;page_free_list,&amp;pages[i],pp_link);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="exercise-2-4"><a href="#exercise-2-4" class="headerlink" title="exercise 2.4"></a>exercise 2.4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//根据题意写出即可</span><br><span class="hljs-keyword">if</span> (LIST_EMPTY(&amp;page_free_list)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-4</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>pp = LIST_FIRST(&amp;page_free_list);<br>&#125;<br>LIST_REMOVE(pp, pp_link);<br><span class="hljs-built_in">memset</span>((<span class="hljs-type">void</span>*)page2kva(pp),<span class="hljs-number">0</span>,PAGE_SIZE);<br></code></pre></td></tr></table></figure><h3 id="exercise-2-5"><a href="#exercise-2-5" class="headerlink" title="exercise 2.5"></a>exercise 2.5</h3><p>调用<code>LIST_INSERT_HEAD</code>即可</p><h3 id="exercise-2-6"><a href="#exercise-2-6" class="headerlink" title="exercise 2.6"></a>exercise 2.6</h3><p>第一级表称为页目录 (Page Directory)，第二级表称为页表 (Page Table)。</p><p>设 pgdir 是一个 Pde * 类型的指针，表示一个一级页表的基地址，那么使用 pgdir + i 即可得到偏移量为 i 的一级页表项（页目录项）地址</p><p><img src="address.png" alt="两级页表结构的地址变换机制"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Step 1: Get the corresponding page directory entry. */</span><br><span class="hljs-comment">/* Exercise 2.6: Your code here. (1/3) */</span><br>pgdir_entryp = pgdir + PDX(va);<br><span class="hljs-comment">/* Step 2: If the corresponding page table is not existent (valid) then:</span><br><span class="hljs-comment"> *   * If parameter `create` is set, create one. Set the permission bits &#x27;PTE_C_CACHEABLE |</span><br><span class="hljs-comment"> *     PTE_V&#x27; for this new page in the page directory. If failed to allocate a new page (out</span><br><span class="hljs-comment"> *     of memory), return the error.</span><br><span class="hljs-comment"> *   * Otherwise, assign NULL to &#x27;*ppte&#x27; and return 0.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/* Exercise 2.6: Your code here. (2/3) */</span><br><span class="hljs-keyword">if</span> (!(*pgdir_entryp &amp; PTE_V)) &#123;<span class="hljs-comment">//如果页面不合法</span><br><span class="hljs-keyword">if</span> (create) &#123;<br><span class="hljs-keyword">if</span> (page_alloc(&amp;pp) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//申请不到空间</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-4</span>;<br>&#125;<br>pp-&gt;pp_ref++; <span class="hljs-comment">//维护pp_ref</span><br>*pgdir_entryp = (PTE_D | PTE_V | page2pa(pp));<span class="hljs-comment">//并设置虚拟地址对应页目录项的内容 *pgdir_entryp = page2pa(pp) | PTE_D | PTE_V，使其与该物理页关联</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>*ppte = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">/* Step 3: Assign the kernel virtual address of the page table entry to &#x27;*ppte&#x27;. */</span><br><span class="hljs-comment">/* Exercise 2.6: Your code here. (3/3) */</span><br><span class="hljs-comment">/*二级页表基地址（指向二级页表的指针）：</span><br><span class="hljs-comment">页目录项-&gt;二级页表的物理地址-&gt;二级页表的虚拟地址-&gt;指向二级页表的指针*/</span><br>Pte *pgtable = (Pte *)KADDR(PTE_ADDR(*pgdir_entryp));<br>*ppte = pgtable + PTX(va);<br></code></pre></td></tr></table></figure><h3 id="exercise-2-7"><a href="#exercise-2-7" class="headerlink" title="exercise 2.7"></a>exercise 2.7</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Step 2: Flush TLB with &#x27;tlb_invalidate&#x27;. */</span><br><span class="hljs-comment">/* Exercise 2.7: Your code here. (1/3) */</span><br>tlb_invalidate(asid, va);<br><span class="hljs-comment">/* Step 3: Re-get or create the page table entry. */</span><br><span class="hljs-comment">/* If failed to create, return the error. */</span><br><span class="hljs-comment">/* Exercise 2.7: Your code here. (2/3) */</span><br><span class="hljs-keyword">if</span> (pgdir_walk(pgdir, va, <span class="hljs-number">1</span>, &amp;pte) == -E_NO_MEM)<br>&#123;<br><span class="hljs-keyword">return</span> -E_NO_MEM;<br>&#125;<br><span class="hljs-comment">/* Step 4: Insert the page to the page table entry with &#x27;perm | PTE_C_CACHEABLE | PTE_V&#x27;</span><br><span class="hljs-comment"> * and increase its &#x27;pp_ref&#x27;. */</span><br><span class="hljs-comment">/* Exercise 2.7: Your code here. (3/3) */</span><br>*pte = page2pa(pp) | perm | PTE_V;<br>pp-&gt;pp_ref ++;<br></code></pre></td></tr></table></figure><h3 id="exercise-2-8"><a href="#exercise-2-8" class="headerlink" title="exercise 2.8"></a>exercise 2.8</h3><p>题目描述的很清楚，指令填入即可，核心在于理解旧表项是如何被无效化的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Step 1: Use &#x27;tlbp&#x27; to probe TLB entry */</span><br><span class="hljs-comment">/* Step 2: Fetch the probe result from CP0.Index */</span><br><span class="hljs-comment">/* Step 3: Use &#x27;tlbwi&#x27; to write CP0.EntryHi/Lo into TLB at CP0.Index  */</span><br></code></pre></td></tr></table></figure><h3 id="exercise-2-9"><a href="#exercise-2-9" class="headerlink" title="exercise 2.9"></a>exercise 2.9</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/* Hints:</span><br><span class="hljs-comment"> *  Invoke &#x27;page_lookup&#x27; repeatedly in a loop to find the page table entry &#x27;*ppte&#x27;</span><br><span class="hljs-comment"> * associated with the virtual address &#x27;va&#x27; in the current address space &#x27;cur_pgdir&#x27;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  **While** &#x27;page_lookup&#x27; returns &#x27;NULL&#x27;, indicating that the &#x27;*ppte&#x27; could not be found,</span><br><span class="hljs-comment"> *  allocate a new page using &#x27;passive_alloc&#x27; until &#x27;page_lookup&#x27; succeeds.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/* Exercise 2.9: Your code here. */</span><br><span class="hljs-keyword">while</span> (page_lookup(cur_pgdir,va,&amp;ppte) == <span class="hljs-literal">NULL</span>) &#123;<br>passive_alloc(va,cur_pgdir,asid);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="exercise-2-10"><a href="#exercise-2-10" class="headerlink" title="exercise 2.10"></a>exercise 2.10</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Hint: use &#x27;tlbwr&#x27; to write CP0.EntryHi/Lo into a random tlb entry. */</span><br><span class="hljs-comment">/* Exercise 2.10: Your code here. */</span><br>tlbwr<br></code></pre></td></tr></table></figure><h2 id="三、实验难点及感想"><a href="#三、实验难点及感想" class="headerlink" title="三、实验难点及感想"></a>三、实验难点及感想</h2><h3 id="实验感想"><a href="#实验感想" class="headerlink" title="实验感想"></a>实验感想</h3><p>本次实验几乎花了整个周末，实验总体分为虚拟内存和TLB 重填两大部分，其中TLB重填部分由于提示给的相当足够，完成起来不是特别难，但是理解TLB重填的汇编代码较为困难，虚拟内存部分宏定义和大量指针的存在加大了阅读的难度，总体来说，lab2相比前两次，难度有了质的上升，特别是两级页表部分的实现，需要阅读大量的代码才能读懂。</p><h3 id="核心处理重难点"><a href="#核心处理重难点" class="headerlink" title="核心处理重难点"></a>核心处理重难点</h3><p>实验的核心都在围绕下面这张图进行寻址和地址处理</p><p><img src="ctm.png" alt="CPU-TLB-Memory关系图"></p><p>面对全是宏定义和满天飞的指针，理解各个宏定义的含义尤为重要。</p><h3 id="常见宏的理解"><a href="#常见宏的理解" class="headerlink" title="常见宏的理解"></a>常见宏的理解</h3><ul><li><code>page2kva</code>：将页面转换为虚拟地址</li><li><code>page2pa</code>：将页面转换为物理地址</li><li><code>pa2page</code>: 物理地址到页</li><li><code>KADDR</code>:将物理地址转化虚拟地址</li><li><code>PADDR</code>:将虚拟地址转化为物理地址</li></ul><h3 id="自映射机制"><a href="#自映射机制" class="headerlink" title="自映射机制"></a>自映射机制</h3><p>思考题A.1困扰我良久，下面是我找到到的比较详细的解释：</p><p>一些计算：因为1M个页表项和4G的地址空间是线性映射，因此页目录地址（简称PD）对应的应该是第PT&gt;&gt;12个页表项，也就是第一个页目录项。而一个页目录项32位，4字节，因此该项相对于起始地址的偏移为(PT&gt;&gt;12)&lt;<2 = pt>&gt;10，因此PD = PT | PT&gt;&gt;10。同理，PT&gt;&gt;10是页目录在整个页表上的偏移，对应(PT&gt;&gt;10)&gt;&gt;10是自映射页目录项在页目录这张页表上的偏移。</2></p><p>页表相关位</p><p><code>PTE_V</code> 有效位，若某页表项的有效位为 1，则该页表项有效，其中高 20 位就是对应的物理页号。</p><p><code>PTE_C_CACHEABLE</code> 可缓存位，配置对应页面的访问属性为可缓存。通常对于所有物理 页面，都将其配置为可缓存，以允许 CPU 使用 cache 加速对这些页面的访存请求。</p><p><code>PTE_D</code>可写位，若某页表项的可写位为 1，则允许经由该页表项对物理页进行写操作。</p>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA_OS_lab1</title>
    <link href="/2024/03/16/BUAA-OS-lab1/"/>
    <url>/2024/03/16/BUAA-OS-lab1/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统lab1学习日记"><a href="#操作系统lab1学习日记" class="headerlink" title="操作系统lab1学习日记"></a>操作系统lab1学习日记</h1><h2 id="一、思考题"><a href="#一、思考题" class="headerlink" title="一、思考题"></a>一、思考题</h2><h3 id="Thinking1-1"><a href="#Thinking1-1" class="headerlink" title="Thinking1.1"></a>Thinking1.1</h3><ul><li><code>objdump -DS 要反汇编的目标文件名 &gt; 导出文本文件名</code><ul><li>-D：反汇编所有的section；</li><li>-d：反汇编那些特定指令机器码的section；</li><li>-S ：尽可能反汇编出源代码，尤其当编译的时候指定了-g 这种调试参数时，效果比较明显,隐含了-d参数;</li><li>-s：显示指定section的完整内容。默认所有的非空section都会被显示</li></ul></li></ul><p>printf 的实现是在链接 (Link) 这一步骤中被插入到最终的可执行文件中的。节省了过程中对printf这些频繁使用的程序的编译。</p><p><img src="编译链接图.png" alt="编译链接"></p><h3 id="Thinking1-2"><a href="#Thinking1-2" class="headerlink" title="Thinking1.2"></a>Thinking1.2</h3><p>问题：</p><ul><li>尝试使用我们编写的 readelf 程序，解析之前在 target 目录下生成的内核 ELF 文 件。 </li><li>也许你会发现我们编写的 readelf 程序是不能解析 readelf 文件本身的，而我们刚 才介绍的系统工具 readelf 则可以解析，这是为什么呢？（提示：尝试使用 readelf -h，并阅读 tools/readelf 目录下的 Makefile，观察 readelf 与 hello 的不同）</li></ul><p><code>readelf [option(s)]</code> ，用来解析一个或者多个 ELF 文件的信息，使用readeif可以查看具体用法，我们执行 readelf -S hello 命令后，hello 文件中各个节的详细信息将以列表的形式为我们展示出来。我们可以利用 readelf 工具来验证我们自己写的简易版 readelf 输出的结果是否正确，还可以使用 readelf —help 看到该命令各个选项及其对 ELF 文件的解析方式</p><p>执行./tools/readelf/readelf ./target/mos后输出</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mos</span><br><span class="hljs-attribute">0</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">1</span>:<span class="hljs-number">0</span>x80020000<br><span class="hljs-attribute">2</span>:<span class="hljs-number">0</span>x80022080<br><span class="hljs-attribute">3</span>:<span class="hljs-number">0</span>x80022098<br><span class="hljs-attribute">4</span>:<span class="hljs-number">0</span>x800220b0<br><span class="hljs-attribute">5</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">6</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">7</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">8</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">9</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">10</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">11</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">12</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">13</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">14</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">15</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">16</span>:<span class="hljs-number">0</span>x0<br><span class="hljs-attribute">17</span>:<span class="hljs-number">0</span>x0<br></code></pre></td></tr></table></figure><p>执行readelf -h readelf输出如下</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">ELF 头：</span><br><span class="hljs-attribute">  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="hljs-attribute">  类别</span><span class="hljs-punctuation">:</span> <span class="hljs-string">                             ELF64</span><br>  <span class="hljs-attribute">数据</span><span class="hljs-punctuation">:</span> <span class="hljs-string">                             2 补码，小端序 (little endian)</span><br>  <span class="hljs-attribute">Version</span><span class="hljs-punctuation">:</span> <span class="hljs-string">                          1 (current)</span><br>  <span class="hljs-attribute">OS/ABI</span><span class="hljs-punctuation">:</span> <span class="hljs-string">                           UNIX - System V</span><br>  <span class="hljs-attribute">ABI 版本</span><span class="hljs-punctuation">:</span> <span class="hljs-string">                         0</span><br>  <span class="hljs-attribute">类型</span><span class="hljs-punctuation">:</span> <span class="hljs-string">                             DYN (Position-Independent Executable file)</span><br>  <span class="hljs-attribute">系统架构</span><span class="hljs-punctuation">:</span> <span class="hljs-string">                         Advanced Micro Devices X86-64</span><br>  <span class="hljs-attribute">版本</span><span class="hljs-punctuation">:</span> <span class="hljs-string">                             0x1</span><br>  <span class="hljs-attribute">入口点地址：               0x1180</span><br><span class="hljs-attribute">  程序头起点：          64 (bytes into file)</span><br><span class="hljs-attribute">  Start of section headers</span><span class="hljs-punctuation">:</span> <span class="hljs-string">         14488 (bytes into file)</span><br>  <span class="hljs-attribute">标志：             0x0</span><br><span class="hljs-attribute">  Size of this header</span><span class="hljs-punctuation">:</span> <span class="hljs-string">              64 (bytes)</span><br>  <span class="hljs-attribute">Size of program headers</span><span class="hljs-punctuation">:</span> <span class="hljs-string">          56 (bytes)</span><br>  <span class="hljs-attribute">Number of program headers</span><span class="hljs-punctuation">:</span> <span class="hljs-string">        13</span><br>  <span class="hljs-attribute">Size of section headers</span><span class="hljs-punctuation">:</span> <span class="hljs-string">          64 (bytes)</span><br>  <span class="hljs-attribute">Number of section headers</span><span class="hljs-punctuation">:</span> <span class="hljs-string">        31</span><br>  <span class="hljs-attribute">Section header string table index</span><span class="hljs-punctuation">:</span> <span class="hljs-string">30</span><br></code></pre></td></tr></table></figure><p>./readelf readelf无输出，readelf无法解析本身但是readelf命令可以</p><p>下面的图用于辅助理解下面的Makefile</p><p><img src="预定义变量.jpg" alt="Makefile预定义变量"></p><p>readelf 与 hello 的不同在于hello有static修饰是静态的，且hello文件被编译为32位而readelf是64位的</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">readelf: main.o readelf.o</span><br>        <span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span><br> <br><span class="hljs-section">hello: hello.c</span><br><span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$^</span> -o <span class="hljs-variable">$@</span> -m32 -static -g<br><span class="hljs-comment">#-g可执行程序包含调试信息，-g为了调试用的，加个-g 是为了gdb 用，不然gdb用不到</span><br></code></pre></td></tr></table></figure><h3 id="Thinking1-3"><a href="#Thinking1-3" class="headerlink" title="Thinking1.3"></a>Thinking1.3</h3><p>问题：</p><p>在理论课上我们了解到，MIPS 体系结构上电时，启动入口地址为 0xBFC00000 （其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但 一定是一个确定的地址），但实验操作系统的内核入口并没有放在上电启动地址，而是按照 内存布局图放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？ （提示：思考实验中启动过程的两阶段分别由谁执行。） </p><p>解答：</p><ul><li>bootloader 将内核可执行文件拷贝到内存中，之后将控制权交给操作系统，只需要启动入口地址为 bootloader 的入口地址。</li><li>Linker Script——控制加载地址，Linker Script 中记录了各个节应该如何映射到段，以及各个段应该被加载到的位置。程序执行的第一条指令的地址称为入口地址（entrypoint），与此同时kernel.lds规定了 ENTRY(_start) ，即把内核入口定为 _start 这个函数。</li><li>通过对 /init/start.S 中 _start 函数的设置，即可以正确的跳转至 mips_init 函数。</li></ul><h2 id="二、测试题Exercise"><a href="#二、测试题Exercise" class="headerlink" title="二、测试题Exercise"></a>二、测试题Exercise</h2><h3 id="exercise-1-1"><a href="#exercise-1-1" class="headerlink" title="exercise 1.1"></a>exercise 1.1</h3><p>核心思路：认识结构体中各个变量的意义计算地址及其他变量即可</p><p>测试结果：</p><p><img src="exercise1.1.png" alt="exercise1.1"></p><h3 id="exercise-1-2"><a href="#exercise-1-2" class="headerlink" title="exercise 1.2"></a>exercise 1.2</h3><p>Linker Script</p><p>.text 保存可执行文件的操作指令。 .data 保存已初始化的全局变量和静态变量。 .bss 保存未初始化的全局变量和静态变量。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">. = 0x8002000; /*load address of test section*/<br>/*。例如“<span class="hljs-string">.bss</span> : &#123;*<span class="hljs-params">(.bss)</span>&#125;”表示将所有输入文件中的 <span class="hljs-string">.bss</span> 节（右边的 <span class="hljs-string">.bss</span>）都放到输出的 <span class="hljs-string">.bss</span> 节（左边的 <span class="hljs-string">.bss</span>）中,请注意代码结尾无;*/<br><span class="hljs-string">.test</span> : &#123;*<span class="hljs-params">(.test)</span>&#125;<br><span class="hljs-string">.data</span> : &#123;*<span class="hljs-params">(.data)</span>&#125;<br><span class="hljs-string">.bss</span> : &#123;*<span class="hljs-params">(.bss)</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="exercise-1-3"><a href="#exercise-1-3" class="headerlink" title="exercise 1.3"></a>exercise 1.3</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment">/* set up the kernel stack */</span><br><span class="hljs-comment">/*注意Kernel Stack是向下增长，即栈顶在低地址*/</span><br>li      <span class="hljs-built_in">sp</span>, <span class="hljs-number">0x80400000</span><br><span class="hljs-keyword">jal </span>    mips_init<br></code></pre></td></tr></table></figure><h3 id="exercise-1-4"><a href="#exercise-1-4" class="headerlink" title="exercise 1.4"></a>exercise 1.4</h3><p>根据格式符<code>%[flags][width][length]</code>补齐即可</p><h2 id="三、难点分析与感想"><a href="#三、难点分析与感想" class="headerlink" title="三、难点分析与感想"></a>三、难点分析与感想</h2><p>lab1实验主要是大致理解printf函数的内部实现，与我们最初印象不同，printf并不是全部在C语言库中全部实现，而是通过一系列编译链接后，在操作系统基础上实现。</p><h4 id="3-1-编译链接部分"><a href="#3-1-编译链接部分" class="headerlink" title="3.1 编译链接部分"></a>3.1 编译链接部分</h4><p>在链接阶段，链接器会将所有的目标文件链接在一起，并填写具体的地址等信息，形成最终的可执行文件。核心在于ELF文件</p><p><img src="ELF.png" alt="ELF文件结构"></p><p>其由五部分构成，ELF头（包含程序基本信息、段头表与节头表的偏移量）、段头表、节头表、段头表中的每一个表项（记录了该段数据载入内存时的目标位置等，记录了用于指导应用 程序加载的各类信息）、节头表（记录了该段数据载入内存时的目标位置等，记录了用于指导应用 程序加载的各类信息）</p><h4 id="3-2-内存布局以及内核被加载到哪里"><a href="#3-2-内存布局以及内核被加载到哪里" class="headerlink" title="3.2 内存布局以及内核被加载到哪里"></a>3.2 内存布局以及内核被加载到哪里</h4><p>附录中给出了对于内存布局，根据Linker Script——控制加载地址，在使用了我们自定义的 Linker Script 以后，生成的程序中，各个节的位置就被 调整到了我们所指定的地址上。段是由节组合而成的，节的地址被调整了，那么最终段的地址也 会相应地被调整，我们的实验就在 kernel.lds 中通过 ENTRY(_start) 来设置程序入口为 _start。</p><h4 id="3-3-Make中是如何构建内核的？"><a href="#3-3-Make中是如何构建内核的？" class="headerlink" title="3.3 Make中是如何构建内核的？"></a>3.3 Make中是如何构建内核的？</h4><p>mos 的构建会在在完成了所有 (modules) 目标的构建后开始。从代码中可以看出，这里执 行了 <code>$(LD) -o $(mos_elf) -N -T $(link_script) $(objects)</code></p><p>$(LD)调用链接器，-o参数后设置输出文件名，-T 文件, —script 文件  读取链接脚本，这条命令作用是使用$(link_script) 将 $(objects) 链接， 输出到$(mos_elf) 位置。</p><h4 id="3-4-start函数怎么设置的？"><a href="#3-4-start函数怎么设置的？" class="headerlink" title="3.4 _start函数怎么设置的？"></a>3.4 _start函数怎么设置的？</h4><p>EXPORT(_start)是一个宏，它将 _start 函数导出为一个符号，使得链接器可以找到它。函数中实现跳转mips_init函数</p><h4 id="3-5-内核是如何输出到控制台的？"><a href="#3-5-内核是如何输出到控制台的？" class="headerlink" title="3.5 内核是如何输出到控制台的？"></a>3.5 内核是如何输出到控制台的？</h4><p>print.c函数实现了格式化输出的主体逻辑，outputk 函数指针传入 vprintfmt 这个函数中，这个函数实际上是用来输出一个字符串的，它实际上调用了一个叫做 printcharc 的函数（调用往 QEMU 的控制台输出字符，其原理为读写某一个特殊的内存地址的函数），想让控制台输出一个字符，实际上是对某一个内存地址写了一个字节。</p><p>总体感想：本次实验相比lab0理解要更难，重在理解 操作系统中mos的启动与构建</p><h2 id="四、附录"><a href="#四、附录" class="headerlink" title="四、附录"></a>四、附录</h2><p>lab1核心——课程内存布局</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs coq">/*<br> o     <span class="hljs-number">4</span>G -----------&gt;  +----------------------------+-----------<span class="hljs-number">-0x100000000</span><br> o                      |       <span class="hljs-type">...                  |  kseg2</span><br> o      KSEG2    -----&gt; +----------------------------+-----------<span class="hljs-number">-0xc000</span> <span class="hljs-number">0000</span><br> o                      |          <span class="hljs-type">Devices</span>           |  <span class="hljs-type">kseg1</span><br> o      KSEG1    -----&gt; +----------------------------+-----------<span class="hljs-number">-0xa000</span> <span class="hljs-number">0000</span><br> o                      |      <span class="hljs-type">Invalid</span> Memory        |   <span class="hljs-type">/|\</span><br><span class="hljs-type"> o</span>                      +----------------------------+----|<span class="hljs-type">-------Physical</span> Memory Max<br> o                      |       <span class="hljs-type">...                  |  kseg0</span><br> o      KSTACKTOP-----&gt; +----------------------------+----|<span class="hljs-type">-------0x8040</span> <span class="hljs-number">0000</span>-------<span class="hljs-keyword">end</span><br> o                      |       <span class="hljs-type">Kernel</span> Stack         |    <span class="hljs-type">| KSTKSIZE</span>            /|<span class="hljs-type">\</span><br><span class="hljs-type"> o</span>                      +----------------------------+----|<span class="hljs-type">------                |</span><br><span class="hljs-type"> o</span>                      |       <span class="hljs-type">Kernel</span> Text          |    <span class="hljs-type">|                    PDMAP</span><br> o      KERNBASE -----&gt; +----------------------------+----|<span class="hljs-type">-------0x8002</span> <span class="hljs-number">0000</span>    |<br> <span class="hljs-type">o</span>                      |      <span class="hljs-type">Exception</span> Entry       |   <span class="hljs-type">\|/                    \|/</span><br><span class="hljs-type"> o</span>      ULIM     -----&gt; +----------------------------+-----------<span class="hljs-number">-0x8000</span> <span class="hljs-number">0000</span>-------<br> o                      |         <span class="hljs-type">User</span> VPT           |     <span class="hljs-type">PDMAP</span>                /|<span class="hljs-type">\</span><br><span class="hljs-type"> o</span>      UVPT     -----&gt; +----------------------------+-----------<span class="hljs-number">-0x7fc0</span> <span class="hljs-number">0000</span>    |<br> <span class="hljs-type">o</span>                      |           <span class="hljs-type">pages</span>            |     <span class="hljs-type">PDMAP</span>                 |<br> <span class="hljs-type">o</span>      UPAGES   -----&gt; +----------------------------+-----------<span class="hljs-number">-0x7f80</span> <span class="hljs-number">0000</span>    |<br> <span class="hljs-type">o</span>                      |           <span class="hljs-type">envs</span>             |     <span class="hljs-type">PDMAP</span>                 |<br> <span class="hljs-type">o</span>  UTOP,UENVS   -----&gt; +----------------------------+-----------<span class="hljs-number">-0x7f40</span> <span class="hljs-number">0000</span>    |<br> <span class="hljs-type">o</span>  UXSTACKTOP -/       |     <span class="hljs-type">user</span> exception stack   |     <span class="hljs-type">PTMAP</span>                 |<br> <span class="hljs-type">o</span>                      +----------------------------+-----------<span class="hljs-number">-0x7f3f</span> f000    |<br> <span class="hljs-type">o</span>                      |                            <span class="hljs-type">|     PTMAP</span>                 |<br> <span class="hljs-type">o</span>      USTACKTOP ----&gt; +----------------------------+-----------<span class="hljs-number">-0x7f3f</span> e000    |<br> <span class="hljs-type">o</span>                      |     <span class="hljs-type">normal</span> user stack      |     <span class="hljs-type">PTMAP</span>                 |<br> <span class="hljs-type">o</span>                      +----------------------------+-----------<span class="hljs-number">-0x7f3f</span> d000    |<br> <span class="hljs-type">a</span>                      |                            <span class="hljs-type">|                           |</span><br><span class="hljs-type"> a</span>                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                           |<br> <span class="hljs-type">a</span>                      .                            .                           |<br> <span class="hljs-type">a</span>                      .                            .                         kuseg<br> a                      .                            .                           |<br> <span class="hljs-type">a</span>                      |<span class="hljs-type">~~~~~~~~~~~~~~~~~~~~~~~~~~~~|                           |</span><br><span class="hljs-type"> a</span>                      |                            <span class="hljs-type">|                           |</span><br><span class="hljs-type"> o</span>       UTEXT   -----&gt; +----------------------------+-----------<span class="hljs-number">-0x0040</span> <span class="hljs-number">0000</span>    |<br> <span class="hljs-type">o</span>                      |      <span class="hljs-type">reserved</span> <span class="hljs-keyword">for</span> COW      |     <span class="hljs-type">PTMAP</span>                 |<br> <span class="hljs-type">o</span>       UCOW    -----&gt; +----------------------------+-----------<span class="hljs-number">-0x003f</span> f000    |<br> <span class="hljs-type">o</span>                      |   <span class="hljs-type">reversed</span> <span class="hljs-keyword">for</span> temporary   |     <span class="hljs-type">PTMAP</span>                 |<br> <span class="hljs-type">o</span>       UTEMP   -----&gt; +----------------------------+-----------<span class="hljs-number">-0x003f</span> e000    |<br> <span class="hljs-type">o</span>                      |       <span class="hljs-type">invalid</span> memory       |                          <span class="hljs-type">\|/</span><br><span class="hljs-type"> a</span>     <span class="hljs-number">0</span> ------------&gt;  +----------------------------+ ----------------------------<br> o<br>*/<br>/* <span class="hljs-keyword">End</span> of Key Code <span class="hljs-string">&quot;load-kernel&quot;</span> */<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA_OS_lab0</title>
    <link href="/2024/03/06/BUAA-OS-lab0/"/>
    <url>/2024/03/06/BUAA-OS-lab0/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统lab0学习日记"><a href="#操作系统lab0学习日记" class="headerlink" title="操作系统lab0学习日记"></a>操作系统lab0学习日记</h1><h3 id="1-学习阶段的难点分析与体会"><a href="#1-学习阶段的难点分析与体会" class="headerlink" title="1 学习阶段的难点分析与体会"></a>1 学习阶段的难点分析与体会</h3><h4 id="1-1-基础命令和快捷键"><a href="#1-1-基础命令和快捷键" class="headerlink" title="1.1 基础命令和快捷键"></a>1.1 基础命令和快捷键</h4><ul><li>Ctrl+C 终止当前程序的执行</li><li>Ctrl+Z 挂起当前程序 </li><li>Ctrl+D 终止输入（若正在使用 shell，则退出当前 shell）</li><li>Ctrl+L 清屏</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">语法:gcc [选项]... [参数]... <br>选项（常用）：<br>-o 指定生成的输出文件 <br>-S 将 C 代码转换为汇编代码 <br>-Wall 显示一些警告信息 <br>-c 仅执行编译操作，不进行链接操作<br>-M 列出依赖<br>-I 编译时指定头文件目录，使用标准库时不需要指定目录，-I 参数可以用相对 ,→ 路径，比如头文件在当前目录，可以用-I. 来指定<br></code></pre></td></tr></table></figure><h4 id="1-2-ctags"><a href="#1-2-ctags" class="headerlink" title="1.2 ctags"></a>1.2 ctags</h4><p>回到命令行界面，执行命令<code>ctags -R *</code>，会发现在该目录下出现了新的文 件 tags，接下来就可以使用一些 ctags 的功能了：</p><p>按下 Ctrl+ ]，便可以跳转到函数定义处；再按下 Ctrl+T 或 Ctrl+O（有 些浏览器 Ctrl+T 是新建页面，会出现热键冲突），便可以回到跳转前的位置。</p><h4 id="1-3-git"><a href="#1-3-git" class="headerlink" title="1.3 git"></a>1.3 git</h4><p>git四种状态：</p><p><img src="git.png" alt="Git"></p><p><img src="gitPrinciple.png" alt></p><p>详见指导书p22，图中我们可以看出此时 HEAD 实际是指向 master 分支的一个“指针”。所以图示 的命令中出现 HEAD 的地方可以用 master 来替换。</p><p>当执行 <code>git rm --cached&lt;file&gt;</code>命令时，会直接从暂存区删除文件，工作区则 不做出改变，实现从暂存区删去不想继续跟踪的文件</p><p><code>git checkout -- &lt;file&gt;</code>如果在工作区中对多个文件经过多次修改后，发现编译 无法通过了。如果尚未执行 <code>git add</code>，则可使用本命令将工作区恢复成原来的样子。作用和<code>git restore</code>类似</p><p><code>git reset HEAD &lt;file&gt;</code>上一条命令是在未执行 <code>git add</code>命令便修改文件生效并 放入暂存区，可使用<code>git checkout</code> 命令。那么如果不慎已经执行了<code>git add</code>，则 可使用本命令。再对需要恢复的文件使用上一条命令即可。</p><p><code>git reset --hard</code>进行版本回退，使用这条命令可以进行版本回退或者切换到任何一个版本。它有两种用法：第一 种是使用<code>HEAD</code>类似形式，如果想退回上个版本就用<code>HEAD^</code>，上上个版本的话就用<code>HEAD^^</code>，要是回退到前 50 个版本则可使用<code>HEAD~50</code>来代替；第二种就是使用<code>hash</code>值，使用<code>hash</code>值可以在不同版本之间任意切换，足见<code>hash</code>值的强大。但是，它强制覆盖了工作目录中的文件。若该文件还未提交，Git 会覆盖它从 而导致无法恢复。</p><p><code>git branch</code>,</p><p>选项：</p><p><code>-D</code>  强制删除一个指定分支</p><p><code>-a</code>   查看所有的原地和本地分支</p><p><img src="gitBranch.png" alt="git branch"></p><h4 id="1-4-linux进阶"><a href="#1-4-linux进阶" class="headerlink" title="1.4 linux进阶"></a>1.4 linux进阶</h4><p><code>find</code>:使用 find 命令并加上 -name 选项可以在当前目录下递归地查找符合参数所示文件 名的文件，并将文件的路径输出至屏幕上。</p><p><code>grep</code>:grep 命令可以从文件中查找包含 pattern 部分字符串的行，并将 该文件的路径和该行输出至屏幕</p><p><code>chmod</code>:+ 表示增加权限、- 表示取消权限、= 表示唯一设定权 限。r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者 该文件已经被设定过为可执行。</p><p><code>diff</code>:比较文件差异，-b 不检查空白字符的不同，-B不检查空行，-q仅显示有无差异不显示详细信息</p><p><code>sed</code>:</p><p>选项（常用）：</p><ul><li>-n 安静模式，只显示经过 sed 处理的内容。否则显示输入文本的所有内容。</li><li>-i 直接修改读取的档案内容，而不是输出到屏幕。否则，只输出不编辑。</li><li><code>-e</code>允许在同一行类执行多条命令</li></ul><p>命令（常用）：</p><ul><li>[行号]a[内容] 新增，在行号后新增一行相应内容。行号可以是“数字”，在这一行之后新增，不写行号时，在每一行之后新增。使用 $ 表示最后一行。后面的命令同理。</li><li>[行号]c[内容] 取代。用内容取代相应行的文本。</li><li>[行号]i[内容] 插入。在当前行的上面插入一行文本。</li><li>[行号]d 删除当前行的内容。</li><li>[行号]p 输出选择的内容。通常与选项-n 一起使用。</li><li>s/re/string 将 re（正则表达式）匹配的内容替换为 string。</li></ul><p><code>awk</code>:awk ‘pattern action’ file，pattern 为条件，action 为命 令，file 为文件。</p><h4 id="1-5-shell"><a href="#1-5-shell" class="headerlink" title="1.5 shell"></a>1.5 shell</h4><p><code>$n</code>就表示第几个参数，<code>$#</code>表示传递参数的个数，<code>$*</code>表示传递的全部参数</p><h3 id="2-Thinking"><a href="#2-Thinking" class="headerlink" title="2 Thinking"></a>2 Thinking</h3><h4 id="Thinking-0-1"><a href="#Thinking-0-1" class="headerlink" title="Thinking 0.1"></a>Thinking 0.1</h4><p>问题：思考下列有关 Git 的问题：</p><ul><li>在前述已初始化的 ~/learnGit 目录下，创建一个名为 README.txt 的文件。执 行命令 git status &gt; Untracked.txt（其中的 &gt; 为输出重定向，我们将在 0.6.3 中 详细介绍）。 </li><li>在 README.txt 文件中添加任意文件内容，然后使用 add 命令，再执行命令 git status &gt; Stage.txt。 </li><li>提交 README.txt，并在提交说明里写入自己的学号。</li><li>执行命令 cat Untracked.txt 和 cat Stage.txt，对比两次运行的结果，体会 README.txt 两次所处位置的不同。</li><li>修改 README.txt 文件，再执行命令 git status &gt; Modified.txt。</li><li>执行命令 cat Modified.txt，观察其结果和第一次执行 add 命令之前的 status 是 否一样，并思考原因。</li></ul><p>解答：新建<code>README.txt</code>文件后，文件处于Untracked状态，文件中添加部分内容，git add后会处于staged状态。先git commit文件接下来再修改文件，文件会处于Modified状态</p><h4 id="Thinking-0-2"><a href="#Thinking-0-2" class="headerlink" title="Thinking 0.2"></a>Thinking 0.2</h4><p>问题：上图中思考一下箭头中的 add the file 、stage the file 和 commit 分别对应的是 Git 里的哪些命令呢？ </p><p>解答：</p><ul><li><code>git add</code></li><li><code>git add</code></li><li><code>git commit</code></li></ul><h4 id="Thinking-0-3"><a href="#Thinking-0-3" class="headerlink" title="Thinking 0.3"></a>Thinking 0.3</h4><p>问题：</p><ol><li>代码文件 print.c 被错误删除时，应当使用什么命令将其恢复？ </li><li>代码文件 print.c 被错误删除后，执行了 git rm print.c 命令，此时应当 使用什么命令将其恢复？</li><li>无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区</li></ol><p>解答：</p><ul><li><code>git checkout --print.c</code></li><li><code>git reset HEAD print.c &amp;&amp; git checkout --print.c</code></li><li><code>git rm -- chched print.c</code></li></ul><h4 id="Thinking-0-4"><a href="#Thinking-0-4" class="headerlink" title="Thinking 0.4"></a>Thinking 0.4</h4><p>版本回退中，<code>git reset --hard</code>后面添加<code>HEAD^</code>可以回到上一版本，<code>HEAD~32</code>这样最多支持回到上五十个版本，此外也使用 hash 值可以在不同版本之间任意切换。</p><h4 id="Thinking-0-5"><a href="#Thinking-0-5" class="headerlink" title="Thinking 0.5"></a>Thinking 0.5</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">执行如下命令, 并查看结果<br>• echo first #输出first<br>• echo second &gt; output.txt #将second输出到output.txt<br>• echo third &gt; output.txt<br><span class="hljs-meta prompt_">#</span><span class="language-bash">将third输出到output.txt并覆盖</span><br>• echo forth &gt;&gt; output.txt<br><span class="hljs-meta prompt_">#</span><span class="language-bash">将forth输出到output.txt但不覆盖</span><br><br></code></pre></td></tr></table></figure><h4 id="Thinking-0-6"><a href="#Thinking-0-6" class="headerlink" title="Thinking 0.6"></a>Thinking 0.6</h4><p>echo echo Shell Start 直接把“echo Shell Start” 作为字符串输出；</p><p>echo (反顿号)echo Shell Start(反顿号)是将 “echo Shell Start” 的输出作为 外层echo 的输入，故会输出 Shell Start；</p><p>echo (单引号)echo Shell Start(单引号)直接把“echo Shell Start” 作为字符串输出</p><h3 id="3-lab0作业debug阶段的易错点"><a href="#3-lab0作业debug阶段的易错点" class="headerlink" title="3 lab0作业debug阶段的易错点"></a>3 lab0作业debug阶段的易错点</h3><h4 id="3-1-脚本执行参数不能丢"><a href="#3-1-脚本执行参数不能丢" class="headerlink" title="3.1 脚本执行参数不能丢"></a>3.1 脚本执行参数不能丢</h4><p>在./search.sh 时未输入一下参数会爆出重定向有歧义（只是其中之一）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep -n <span class="hljs-string">&quot;<span class="hljs-variable">$2</span>&quot;</span> <span class="hljs-variable">$1</span> | awk -F <span class="hljs-string">&#x27;:&#x27;</span> <span class="hljs-string">&#x27;&#123;print $1&#125;&#x27;</span> &gt; <span class="hljs-variable">$3</span><br></code></pre></td></tr></table></figure><h4 id="3-2-Makefile中的问题"><a href="#3-2-Makefile中的问题" class="headerlink" title="3.2 Makefile中的问题"></a>3.2 Makefile中的问题</h4><ol><li><code>.PHONY</code>后面跟的目标都被称为伪目标，也就是说我们 make 命令后面跟的参数如果出现在.PHONY 定义的伪目标中，那就直接在Makefile中就执行伪目标的依赖和命令。不管Makefile同级目录下是否有该伪目标同名的文件，即使有也不会产生冲突。另一个就是提高执行makefile时的效率。</li><li>如下,如果执行all会同时执行fibo和clean对应命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">all :fibo clean<br><br>clean:<br><span class="hljs-built_in">rm</span> -rf $(TARGET)<br>fibo: fibo.c<br>gcc -o fibo fibo.c<br></code></pre></td></tr></table></figure><h4 id="3-3-gcc"><a href="#3-3-gcc" class="headerlink" title="3.3 gcc"></a>3.3 gcc</h4><p><code>-I</code>参数是用来指定头文件目录</p><p><code>-l</code>参数就是用来指定程序要链接的库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc ./code/fibo.o ./code/main.o -o fibo <br></code></pre></td></tr></table></figure><p>这段代码作用:</p><p>这段代码使用了gcc编译器将两个目标文件（fibo.o和main.o）链接在一起，生成一个名为fibo的可执行文件。通常，这种编译方式适用于将程序分成多个源文件编写，然后分别编译成目标文件，最后将它们链接在一起以生成最终的可执行文件。</p><h3 id="4-Exercice总结"><a href="#4-Exercice总结" class="headerlink" title="4 Exercice总结"></a>4 Exercice总结</h3><h4 id="4-1-Exercise-0-1"><a href="#4-1-Exercise-0-1" class="headerlink" title="4.1 Exercise 0.1"></a>4.1 Exercise 0.1</h4><ol><li><p>palindrome.c代码补全，实现回文数判断，核心思路：将数字n的各位上的数字存到数组中进行比对</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> main &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span> (<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>        a[i++] = n % <span class="hljs-number">10</span>;<br>        n /= <span class="hljs-number">10</span>;<br>    &#125;<br>    j = i - <span class="hljs-number">1</span>;<br>    i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">if</span> (a[i] != a[j]) &#123;<br>            flag = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        i ++;<br>        j --;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flag) &#123;<br>        print(<span class="hljs-string">&quot;Y\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>print(<span class="hljs-string">&quot;N\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ol><li><p>```shell<br>gcc -o palindrome palindrome.c</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><br><span class="hljs-number">3.</span> sed指令的使用<br><br>   ```shell<br>   <span class="hljs-meta">#实现通过命令 bash hello_os.sh AAA BBB，在 hello_os.sh 所处的目录新建一个名为 BBB 的文件，内容是AAA 文件的第 8、32、128、512、1024 行的内容提取</span><br>   sed -n <span class="hljs-string">&#x27;8p;32p;128p;512p;1024p&#x27;</span> $1 &gt; $2<br>   <span class="hljs-meta">#-n 表示在安静模式下进行</span><br></code></pre></td></tr></table></figure></li><li><p>文件复制,co指令的使用</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cp -r src<span class="hljs-regexp">/* dst/</span><br>re dst<span class="hljs-regexp">/sh_test/</span>hello_os.sh<br></code></pre></td></tr></table></figure></li></ol><h4 id="4-2-Exercise-0-2"><a href="#4-2-Exercise-0-2" class="headerlink" title="4.2 Exercise 0.2"></a>4.2 Exercise 0.2</h4><ol><li><p>删除和重命名的使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -r &quot;file$a&quot; #删除file4(若$a == 4)<br>mv ./&quot;file$a&quot; ./&quot;newfile$a&quot;<br>let a=a+1 #使得a递增，注意不要加些空格<br></code></pre></td></tr></table></figure></li></ol><h4 id="4-3-Exercise-0-3"><a href="#4-3-Exercise-0-3" class="headerlink" title="4.3 Exercise 0.3"></a>4.3 Exercise 0.3</h4><p>​    <code>grep</code>与<code>awk</code>的使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -n $2 $1 | awk -F &#x27;:&#x27; &#x27;&#123;print $1&#125;&#x27; &gt; $3<br></code></pre></td></tr></table></figure><h4 id="4-4-Exercise-0-4"><a href="#4-4-Exercise-0-4" class="headerlink" title="4.4 Exercise 0.4"></a>4.4 Exercise 0.4</h4><ol><li><p><code>sed</code>使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#将$1文件中的$s2替换为$s3</span><br>sed -i <span class="hljs-string">&quot;s/<span class="hljs-variable">$2</span>/<span class="hljs-variable">$3</span>/g&quot;</span> <span class="hljs-variable">$1</span><br></code></pre></td></tr></table></figure></li><li><p><code>Makefile</code>编写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"> 内部Makefile<br>  1 all: fibo main<br>  2 <br>  3 fibo: fibo.c<br>  4         gcc -I ../include -c fibo.c<br>  5 <br>  6 main: main.c fibo.o<br>  7         gcc -I ../include -c main.c<br>  8 <br>  9 clean:<br> 10         rm *.o<br>外部<br>  1 all: fibo<br>  2 <br>  3 fibo: <br>  4         cd code &amp;&amp; make <br>  5         gcc ./code/fibo.o ./code/main.o -o fibo<br>  6 <br>  7 clean: <br>  8         rm ./code/fibo.o<br>  9         rm ./code/main.o<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA_OO_Unit1</title>
    <link href="/2024/03/01/BUAA-OO-Unit1/"/>
    <url>/2024/03/01/BUAA-OO-Unit1/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="BUAA-OO-Unit1总结"><a href="#BUAA-OO-Unit1总结" class="headerlink" title="BUAA_OO_Unit1总结"></a>BUAA_OO_Unit1总结</h1><h2 id="一、第一次作业hw1"><a href="#一、第一次作业hw1" class="headerlink" title="一、第一次作业hw1"></a>一、第一次作业hw1</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>耗时数天完成了代码书写及代码调试，感悟良多，归功于Training中的内容，我在本次作业中也选择了对应的递归下降的思路构造语法树，同时在根据语法树利用逆向思路将解析完的表达式转化为多项式形式，最后多项式存入TreeMap中按要求降序输出结果。此外UML图中单箭头为本人添加，代表核心的依赖关系。</p><h3 id="1-代码UML框架"><a href="#1-代码UML框架" class="headerlink" title="1.代码UML框架"></a>1.代码UML框架</h3><p><img src="uml.png" alt="UML框架"></p><p><code>NumFactor,VarFactor,ExprFactor</code>继承Factor父类，既可以调用父类<code>exponet</code>的相关方法，又有各自<code>toPoly</code>的方法，<code>Monomial</code>单项式类用于处理单项式，<code>Poly</code>用于处理多项式，<code>PolynomialAnswer</code>用于最终化简输出</p><h3 id="2-代码架构分析"><a href="#2-代码架构分析" class="headerlink" title="2.代码架构分析"></a>2.代码架构分析</h3><h4 id="2-1-预处理"><a href="#2-1-预处理" class="headerlink" title="2.1 预处理"></a>2.1 预处理</h4><p><img src="image-20240301204258960.png" alt="形式化表述"></p><p>根据表达式的形式化表达我们可以得到以下结论：</p><ol><li>表达式中最多三个连续的<code>+</code>或者<code>-</code></li><li>常数因子可以有前导0</li><li>指数符号后只可能是<code>token.ADD</code>或者<code>token.NUM</code></li><li>表达式中可能存在大量 <code>space</code>和<code>\t</code></li><li>表达式或<code>(</code>后可能存在符号</li></ol><p>于是为了简化后续操作我选择进行的以下操作</p><ol><li>若读到<code>+</code>且前面存在其他符号或位于开头则去掉加号</li><li>若读到<code>-</code>且前面存在<code>(</code>或者位于开头则在前面加上0，若减号连续则将其换为一个<code>+</code></li><li>去掉所有空格</li></ol><h4 id="2-2-词法分析与解析部分"><a href="#2-2-词法分析与解析部分" class="headerlink" title="2.2 词法分析与解析部分"></a>2.2 词法分析与解析部分</h4><h5 id="2-2-1-Lexer部分"><a href="#2-2-1-Lexer部分" class="headerlink" title="2.2.1 Lexer部分"></a>2.2.1 Lexer部分</h5><ol><li>在读取到<code>token.NUM</code>时去除前缀0（但是谨记保证数不会被全部去掉）</li><li>在读取到未知符号时我们选择抛出异常（强烈建议此方法，后续可以快速定位bug）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Invalid token&quot;</span>);<br></code></pre></td></tr></table></figure><h5 id="2-2-2-Parse"><a href="#2-2-2-Parse" class="headerlink" title="2.2.2 Parse"></a>2.2.2 Parse</h5><p>该部分是代码词法解析的核心部分</p><ol><li><p>我完成了<code>parseExpr()、parseTerm()、parseFactor()</code>的书写并采用递归下降的方法调用</p></li><li><p>由于预处理我们可以只对Term加上正负属性并且在这里完成项的正负号的确定</p></li><li><p>在解析项时去掉指数符号，将其全部转化为因子形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">Factor</span> <span class="hljs-variable">factor</span> <span class="hljs-operator">=</span> parseFactor();<br>        <span class="hljs-keyword">if</span> (factor.getExponent() == <span class="hljs-number">0</span>) &#123;<br>            term.addFactor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NumFactor</span>(BigInteger.ONE));<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; factor.getExponent(); i++) &#123;<br>            term.addFactor(factor);<br>        &#125;<br></code></pre></td></tr></table></figure></li></ol><ol><li><p>同上在解析未知符号是我们选择抛出异常便于debug</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Invalid token&quot;</span>);<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-3-根据解析结果转化为多项式"><a href="#2-3-根据解析结果转化为多项式" class="headerlink" title="2.3 根据解析结果转化为多项式"></a>2.3 根据解析结果转化为多项式</h4><p>该部分核心思路还是递归思路</p><p>Expr -&gt; Term -&gt; Factor</p><p>然后多项式中存入<code>TreeMap&lt;Integer,BigInteger&gt; polynomial</code></p><p>最后，我们要得到形如：$Expr =  \sum\limits_ { i = 0 } a_i * x ^ { b_i }$</p><p>好处：保证有序性和便于得到$a_i$和$b_i$，在此基础上得到一个字符串即可</p><h3 id="3-测试思路"><a href="#3-测试思路" class="headerlink" title="3.测试思路"></a>3.测试思路</h3><h4 id="3-1-自动化测试"><a href="#3-1-自动化测试" class="headerlink" title="3.1.自动化测试"></a>3.1.自动化测试</h4><h5 id="3-11-数据生成"><a href="#3-11-数据生成" class="headerlink" title="3.11 数据生成"></a>3.11 数据生成</h5><p>思路还是和解答程序程序相似,按照generate_factor  —&gt; generate_term —&gt; generate_expr —&gt;generate_testcase</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_factor</span>(<span class="hljs-params">floor</span>):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_term</span>(<span class="hljs-params">floor</span>):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_expr</span>(<span class="hljs-params">floor</span>):<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_testcase</span>(<span class="hljs-params">Limit,floor</span>):<br></code></pre></td></tr></table></figure><p>最后随机在生成式之间添加空格</p><h5 id="3-12-测试比对"><a href="#3-12-测试比对" class="headerlink" title="3.12 测试比对"></a>3.12 测试比对</h5><p>依赖于sympy自带的化简功能实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">execute_java</span> (stdin, <span class="hljs-built_in">str</span>):<br>    cmd = [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-built_in">str</span> + <span class="hljs-string">&quot;.jar&quot;</span>]  <span class="hljs-comment"># 更改为自己的.jar包名</span><br>    proc = subprocess.Popen(cmd, stdin=PIPE, stdout=PIPE, stderr=STDOUT)<br>    stdout, stderr = proc.communicate(stdin.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>    <span class="hljs-keyword">return</span> stdout.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>).strip()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">isEqual</span>(<span class="hljs-params">javaInput,javaOutput</span>):<br>    javaInput = sp.simplify(javaInput)<br>    javaOutput = sp.simplify(javaOutput)<br>    <span class="hljs-keyword">return</span> javaInput.equals(javaOutput)<br></code></pre></td></tr></table></figure><h2 id="二、第二次作业hw2"><a href="#二、第二次作业hw2" class="headerlink" title="二、第二次作业hw2"></a>二、第二次作业hw2</h2><h4 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h4><p>本次作业花费大多时间在构思解决最后的化简上，同时在debug时也遇到了不少问题，但最终一一解决，虽代码相比第一次变化不小，但总体思路大致相同</p><h4 id="1-代码UML框架-1"><a href="#1-代码UML框架-1" class="headerlink" title="1.代码UML框架"></a>1.代码UML框架</h4><p><img src="UML_Unit1.2.png" alt="UML"></p><p>相比上次增加了自定义函数类、自定义函数集合、自定义函数因子类用于处理自定义函数以及其替换，迭代中发现<code>PolynomailAnswer</code>类作为最终输出由于增加了<code>ExpFuncFactor</code>指数函数类的原因，反而不能起到化简的作用，于是删去了，相关输出在<code>Poly</code>类中实现。</p><h4 id="2-作业体会"><a href="#2-作业体会" class="headerlink" title="2.作业体会"></a>2.作业体会</h4><ol><li>关于使用替换进行函数展开，要注意不要引入新的形参。例如f(y, x)=y+x，展开f(x, x^2)时，若不加任何修改直接用x替换形参y，f就会变为x+x， 再直接用x^2替换所有形参x，就会变为x^2+x^2的错误结果。因此，可以先将所有形参变为其他形式， 如f(v,u) = v+u，再替换形参v和u就不会发生上述错误。对于<code>exp(x)</code>,由于<code>exp</code>中包含x，可能会影响我们后续对于x的替换，所以在一开始我们可以选择将<code>exp</code>替换为<code>e</code></li><li>深拷贝与浅拷贝学习，由于JAVA默认一般是浅拷贝，如下我们正常写法应该是<code>return this.defineFunctions</code>,但是函数的参数替换时可能会涉及多次形参的替换，如果不采用深拷贝的话，会导致第一遍替换后会影响我们到后续的替换。        </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ArrayList&lt;DefineFunction&gt; <span class="hljs-title function_">getDefineFunctions</span><span class="hljs-params">()</span> &#123;<br>    ArrayList&lt;DefineFunction&gt; dfs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (DefineFunction defineFunction : <span class="hljs-built_in">this</span>.defineFunctions) &#123;<br>        dfs.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefineFunction</span>(defineFunction.getName(), defineFunction.getBody()));<br>        dfs.get(dfs.size() - <span class="hljs-number">1</span>).setParameters(defineFunction.getParameters());<br>    &#125;<br>    <span class="hljs-keyword">return</span> dfs;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现深拷贝也有很多种方法，对于String 类型的我们可以new一个String类型对象后赋值，对于某一个自定义对象，我们可以通过以下方法实现：</p><ul><li><p>重写<code>clone（）</code>方法，但是这种方法某一类有多少个引用类型，我们就要重写多少次，如果存在很多引用类型，那么代码量显然会很大，所以这种方法不太合适。</p></li><li><p>利用序列化序，列化是将对象写到流中便于传输，而反序列化则是把对象从流中读取出来。这里写到流中的对象则是原始对象的一个拷贝，因为原始对象还存在 JVM 中，所以我们可以利用对象的序列化产生克隆对象，然后通过反序列化获取这个对象。 注意每个需要序列化的类都要实现 Serializable 接口，如果有某个属性不需要序列化，可以将其声明为 transient，即将其排除在克隆属性之外。下面是一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.Serial;<br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><span class="hljs-keyword">import</span> java.io.ByteArrayInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-comment">//Serializable的作用是为了实现对象的序列化，只有实现了Serializable接口的类才能被序列化</span><br>    <span class="hljs-meta">@Serial</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> age; <span class="hljs-comment">//transient关键字修饰的变量不会被序列化</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">deepClone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//序列化</span><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>(); <span class="hljs-comment">//创建字节数组输出流</span><br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bos);<br>        oos.writeObject(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-comment">//反序列化</span><br>        <span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bos.toByteArray());<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(bis);<br>        <span class="hljs-keyword">return</span> ois.readObject();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h4 id="3-代码架构分析"><a href="#3-代码架构分析" class="headerlink" title="3.代码架构分析"></a>3.代码架构分析</h4><p>本次迭代继承了上次大部分的思路，增加了DefineFunction，FunctionList两个类用于读取和储存自定义函数，同时根据提示题意增加了需要的DefineFunctionFactor、ExpFuncFactor类适应新的需求</p><h5 id="3-1-自定义函数的替换"><a href="#3-1-自定义函数的替换" class="headerlink" title="3.1 自定义函数的替换"></a>3.1 自定义函数的替换</h5><p>由于在于处理中一直没有好的思路实现替换，于是我决定牺牲部分运行的时间，先解析一遍表达式，再将Expr通过递归思路转化为String形式，在这个过程中在DefineFunctionFactor下的toString()方法实现替换，但在这里要注意调用我们储存好的FunctionList的内容时要实现深拷贝</p><h5 id="3-2-多项式的化简"><a href="#3-2-多项式的化简" class="headerlink" title="3.2 多项式的化简"></a>3.2 多项式的化简</h5><p>本次单项式相比上次多了Poly类对象对应exp（）内部的多项式，多项式类采用以下储存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> ArrayList&lt;Monomial&gt; monomials;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TreeMap&lt;BigInteger, HashMap&lt;Poly, BigInteger&gt;&gt; polyMap;<br></code></pre></td></tr></table></figure><p>最开始先不断在monomials中添加单项式，后再往polyMap中添加实现化简，注意由于HashMap的key是自定义类，我们需要重写equals（）方法和hashcode()方法</p><h3 id><a href="#" class="headerlink" title=" "></a> </h3><h3 id="4-debug"><a href="#4-debug" class="headerlink" title="4. debug"></a>4. debug</h3><h4 id="CPU超时以及超内存应对"><a href="#CPU超时以及超内存应对" class="headerlink" title="CPU超时以及超内存应对"></a>CPU超时以及超内存应对</h4><ul><li><strong>慎用异常</strong></li></ul><p>异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace()的本地同步方法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。</p><p>本次bug是由于递归深度过深导致的下面这条数据超内存且超时，尝试了很多提高性能的方法均不奏效，于是被迫更改递归思路</p><p><code>0(((((((((((x^8)^8)^8)^8)^8)^8)^8)^8)^8)^8)^8)^8</code></p><p>原思路如下，没读到一个因子就根据其次数向项中加入对应数量的因子，后续会导致递归不断深入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">for</span> (<span class="hljs-type">BigInteger</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> BigInteger.ZERO; i.compareTo(factor.getExponent()) &lt; <span class="hljs-number">0</span>;<br>     i = i.add(BigInteger.ONE)) &#123;<br>    term.addFactor(factor);<br>&#125;<br></code></pre></td></tr></table></figure><p>更改后，在转换为多项式时根据次数乘上对应因子，极大简化了对应的递归深度。</p><p>至于Main中的更改，原因在于我采用的是解析<code>String</code>类型字符串再<code>ToString</code>实现替换的功能，当没有需要替换的的函数时就只需要解析一次。综上实现了超内存和超时的问题。</p><p>综上，递归解决问题中，如何保证递归的深度不会太深是我们必须需要思考的问题。</p><h3 id="5-hack经历"><a href="#5-hack经历" class="headerlink" title="5. hack经历"></a>5. hack经历</h3><p>hack时主要还是通过评测机进行初查，但由于python的<code>sympy</code>包无法检测作业中的格式问题，最终主要还是人力排查格式问题，本次通过exp((-x))格式错误hack成功一次。</p><h2 id="三、第三次作业"><a href="#三、第三次作业" class="headerlink" title="三、第三次作业"></a>三、第三次作业</h2><h4 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h4><p>本次作业相比前两次代码量上有所减少，作业核心求导方面还是第一单元的核心思路递归下降解决。但是由于作业难度的加大以及迭代导致本次在debug方面耗费了大量的时间。</p><h4 id="1-代码UML框架-2"><a href="#1-代码UML框架-2" class="headerlink" title="1.代码UML框架"></a>1.代码UML框架</h4><p><img src="UML1.3.png" alt="UML1.3"></p><p>增加了求导函数因子，求导过程主要是转化为<code>String</code>类型递归实现。但是注意指数函数（<del>血的教训</del>）的求导如下：</p><p>$dx(exp((expr))^n) = n<em>dx(expr)</em>(exp((expr))^n)$</p><h4 id="2-作业体会-1"><a href="#2-作业体会-1" class="headerlink" title="2. 作业体会"></a>2. 作业体会</h4><p><code>derivation()</code>求导函数和<code>toString()</code>类似返回String类型，采用递归下降思路，此外无较大改动。</p><h4 id="3-hack经历"><a href="#3-hack经历" class="headerlink" title="3. hack经历"></a>3. hack经历</h4><p>本次hack过程，有了上次自己超时的经验，卡着代价函数通过下面数据卡了性能成功一次</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-number">0</span><br><span class="hljs-function"><span class="hljs-title">dx</span>(<span class="hljs-title">exp</span>(<span class="hljs-title">exp</span>(<span class="hljs-title">exp</span>(<span class="hljs-title">exp</span>(<span class="hljs-title">exp</span>(<span class="hljs-title">exp</span>(<span class="hljs-title">exp</span>(<span class="hljs-title">exp</span>(<span class="hljs-variable">x</span>^<span class="hljs-number">2</span>)))))))))</span><br></code></pre></td></tr></table></figure><h4 id="4-输出优化"><a href="#4-输出优化" class="headerlink" title="4. 输出优化"></a>4. 输出优化</h4><p>关于输出优化我没做特别的提出exp内部的最小公因数和因式分解操作，但是通过<code>TreeMap&lt;BigInteger, HashMap&lt;Poly, BigInteger&gt;&gt; polyMap</code>的多项式储存方式，通过讨论指数和系数的值通过打表的方式，对于无指数函数多项式的优化几乎是最简形式。</p><h2 id="Unit1总结"><a href="#Unit1总结" class="headerlink" title="Unit1总结"></a>Unit1总结</h2><p>第一单元的核心是解析表达式，总体处理思路是递归下降构建语法树，总体代码规模如下，为了便于理解，我将Factor抽象为父类，里面实现一些因子类的通用方法，并将所有的因子都对应创建的一个子类从而实现不同的<code>toString(),derivation(),toPoly</code>方法。</p><h4 id="1-代码规模以及复杂度"><a href="#1-代码规模以及复杂度" class="headerlink" title="1.代码规模以及复杂度"></a>1.代码规模以及复杂度</h4><p><img src="codeNum.png" alt="codeNum"></p><p>通过与他人对比，发现个人的代码规模还是比较庞大的，主要在于部分类的抽象程度还是不够高，将对应因子以及各类处理都写成了对应的类——因此可以提高抽象程度，例如Expr作为Factor接口下的实例。优点：理解起来较为容易，更改增加新功能较为容易。缺点：随着代码的迭代，增添的代码量相比会更加多。</p><p>复杂度如下：</p><ul><li><strong>OCavg</strong> : 每个类中所有非抽象方法的平均圈复杂度(继承的方法不计算在内)。</li><li><strong>OCmax</strong> : 每个类中非抽象方法的最大圈复杂度(继承的方法不计算在内)。</li><li><strong>WMC</strong> : 每个类中方法的总圈复杂度.</li></ul><div class="table-container"><table><thead><tr><th>Class</th><th>OCavg</th><th>OCmax</th><th>WMC</th></tr></thead><tbody><tr><td>MainClass</td><td>2</td><td>2</td><td>2</td></tr><tr><td>analysis.Lexer</td><td>4</td><td>16</td><td>36</td></tr><tr><td>analysis.Parser</td><td>2.75</td><td>7</td><td>33</td></tr><tr><td>analysis.Token</td><td>1</td><td>1</td><td>4</td></tr><tr><td>analysis.Token.Type</td><td>n/a</td><td>n/a</td><td>0</td></tr><tr><td>definefunction.DefineFunction</td><td>1</td><td>1</td><td>7</td></tr><tr><td>definefunction.FunctionList</td><td>2.8</td><td>8</td><td>14</td></tr><tr><td>expression.DefineFuncFactor</td><td>2.33</td><td>5</td><td>7</td></tr><tr><td>expression.DerivationFactor</td><td>1</td><td>1</td><td>4</td></tr><tr><td>expression.ExpFuncFactor</td><td>1.75</td><td>2</td><td>7</td></tr><tr><td>expression.Expr</td><td>2</td><td>3</td><td>10</td></tr><tr><td>expression.ExprFactor</td><td>2</td><td>3</td><td>8</td></tr><tr><td>expression.Factor</td><td>1</td><td>1</td><td>6</td></tr><tr><td>expression.NumFactor</td><td>1</td><td>1</td><td>4</td></tr><tr><td>expression.Term</td><td>2.86</td><td>8</td><td>20</td></tr><tr><td>expression.VarFactor</td><td>1.5</td><td>2</td><td>6</td></tr><tr><td>gather.Monomial</td><td>1.43</td><td>3</td><td>10</td></tr><tr><td>gather.Poly</td><td>4.13</td><td>14</td><td>62</td></tr><tr><td>pre.Treatment</td><td>2</td><td>5</td><td>12</td></tr></tbody></table></div><h4 id="2-调试闹鬼现象的分析"><a href="#2-调试闹鬼现象的分析" class="headerlink" title="2.调试闹鬼现象的分析"></a>2.调试闹鬼现象的分析</h4><p>通过讨论区即自己学习，后续作业中可以选择遵循Command与Query分离原则，即命令型方法无返回值，查询型方法不修改字段，不对形参进行副作用操作。</p><h4 id="3-作业感想"><a href="#3-作业感想" class="headerlink" title="3.作业感想"></a>3.作业感想</h4><p>关于第一次作业，开学第一天就被狠狠上强度，被迫开始速通OO，第二次作业中由于自己测试时没有充分考虑运行时间，所以强测寄了一个点，后续大改后，加上第三次作业较为简单，没出啥问题。</p><p>最后，未来建议互测小房间可不可以及时给出被hack的点（出现超时问题需要重构好及时构想，待到下一次作业布置两手抓真的不知道咋办）。</p>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象OO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA_CO_P7设计文稿</title>
    <link href="/2024/01/01/BUAA-CO-P7%E8%AE%BE%E8%AE%A1%E6%96%87%E7%A8%BF/"/>
    <url>/2024/01/01/BUAA-CO-P7%E8%AE%BE%E8%AE%A1%E6%96%87%E7%A8%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="P7CPU设计文稿"><a href="#P7CPU设计文稿" class="headerlink" title="P7CPU设计文稿"></a>P7CPU设计文稿</h1><h2 id="1-总体架构"><a href="#1-总体架构" class="headerlink" title="1.总体架构"></a>1.总体架构</h2><p><img src="Structure.png" alt="Structure"></p><p><strong>任务清单</strong></p><p>新增指令：<strong>mfc0,</strong> <strong>mtc0,</strong> <strong>eret,</strong> <strong>syscall</strong></p><p>P7 与之前的 project 相比，涉及的内容较多，所以在实现的时候很容易手忙脚乱，这里列出完成 P7 需要的事宜：</p><div class="table-container"><table><thead><tr><th style="text-align:left">任务</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">计时器</td><td style="text-align:left">课程组提供实现代码，只需要结合代码和文档理解应用即可。</td></tr><tr><td style="text-align:left">系统桥</td><td style="text-align:left">为 CPU 提供统一的访问外设的接口，需要按规格自行实现。</td></tr><tr><td style="text-align:left">协处理器 CP0</td><td style="text-align:left">设置 CPU 的异常处理功能，反馈 CPU 的异常信息，需要按规格自行实现。</td></tr><tr><td style="text-align:left">内部异常检测与流水</td><td style="text-align:left">CPU 需要具有可以检测内部指令执行错误的能力。</td></tr><tr><td style="text-align:left">外部中断响应</td><td style="text-align:left">CPU 需要具有初步响应外部中断信号的能力。</td></tr><tr><td style="text-align:left">异常处理指令</td><td style="text-align:left">在异常处理程序中，会有一些特殊的指令需要实现。</td></tr><tr><td style="text-align:left">单周期 CPU 的封装</td><td style="text-align:left">让 CPU 从外部看上去是一个单周期 CPU。</td></tr><tr><td style="text-align:left">异常处理程序</td><td style="text-align:left">利用 MARS 编写简单的异常处理程序用于测试。</td></tr></tbody></table></div><p><img src="p6cpu.jpg" alt="p6CPU"></p><h2 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2.具体实现"></a>2.具体实现</h2><h3 id="1-CP0"><a href="#1-CP0" class="headerlink" title="1.CP0"></a>1.CP0</h3><p>将CP0置于M级，故宏观PC为M级对于PC</p><p> CP0 的端口声明如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">端口</th><th style="text-align:left">方向</th><th style="text-align:left">位数</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">clk</td><td style="text-align:left">I</td><td style="text-align:left">1</td><td style="text-align:left">时钟信号。</td></tr><tr><td style="text-align:left">reset</td><td style="text-align:left">I</td><td style="text-align:left">1</td><td style="text-align:left">复位信号。</td></tr><tr><td style="text-align:left">en</td><td style="text-align:left">I</td><td style="text-align:left">1</td><td style="text-align:left">写使能信号。</td></tr><tr><td style="text-align:left">CP0Addr</td><td style="text-align:left">I</td><td style="text-align:left">5</td><td style="text-align:left">寄存器地址。</td></tr><tr><td style="text-align:left">CP0In</td><td style="text-align:left">I</td><td style="text-align:left">32</td><td style="text-align:left">CP0 写入数据。</td></tr><tr><td style="text-align:left">CP0Out</td><td style="text-align:left">O</td><td style="text-align:left">32</td><td style="text-align:left">CP0 读出数据。</td></tr><tr><td style="text-align:left">VPC</td><td style="text-align:left">I</td><td style="text-align:left">32</td><td style="text-align:left">受害 PC。</td></tr><tr><td style="text-align:left">BDIn</td><td style="text-align:left">I</td><td style="text-align:left">1</td><td style="text-align:left">是否是延迟槽指令。</td></tr><tr><td style="text-align:left">ExcCodeIn</td><td style="text-align:left">I</td><td style="text-align:left">5</td><td style="text-align:left">记录异常类型。</td></tr><tr><td style="text-align:left">HWInt</td><td style="text-align:left">I</td><td style="text-align:left">6</td><td style="text-align:left">输入中断信号。</td></tr><tr><td style="text-align:left">EXLClr</td><td style="text-align:left">I</td><td style="text-align:left">1</td><td style="text-align:left">用来复位 EXL。</td></tr><tr><td style="text-align:left">EPCOut</td><td style="text-align:left">O</td><td style="text-align:left">32</td><td style="text-align:left">EPC 的值。</td></tr><tr><td style="text-align:left">Req</td><td style="text-align:left">O</td><td style="text-align:left">1</td><td style="text-align:left">进入处理程序请求。</td></tr></tbody></table></div><p>CP0位置确定</p><h3 id="2-约定"><a href="#2-约定" class="headerlink" title="2.约定"></a>2.约定</h3><ol><li>如果发生异常的指令是延迟槽指令，那么返回程序时仍然返回这条指令所属的跳转指令。也就是说“异常延迟槽回到跳转”。</li><li>如果发生异常的指令是跳转指令，那么我们要求执行完延迟槽。</li><li>如果发生异常的指令是乘除指令的下一条，乘除指令不被撤回。也就是对于 M错误指令，W乘除指令 的情况，此时乘除槽正在计算，本来在异常处理时可能会覆盖乘除槽的结果，但是我们约定不会这么做。但是注意，如果是 E乘除指令，M错误指令，你要保证乘除指令不执行。</li></ol><p><strong>范围约定</strong></p><p><img src="strict.png" alt="strict"></p><h3 id="3-中断异常"><a href="#3-中断异常" class="headerlink" title="3.中断异常"></a>3.中断异常</h3><p><strong>中断异常约束</strong></p><ul><li><p>异常入口：《SMRL》的表 5.1 中定义了 MIPS 的异常入口，但考虑到简化设计以及与 MARS 保持一致，我们只支持 0x4180 一个入口地址，所有异常与中断都将从这里进入。</p></li><li><p>嵌套中断异常：本实验不要求支持中断异常嵌套的情况。</p></li><li><p>优先级：中断优先级高于异常优先级，即当有异常提交至 CP0 寄存器时，若有中断发生，则硬件应先响应中断，并重新执行受害指令及其后续指令；若没有中断发生，则处理异常。</p></li><li><p>精确异常：</p><ul><li><p>除下面的情况外，对所有中断异常的处理都应遵循精确异常的处理规则。</p></li><li><p>在进入中断或异常状态时，如果受害指令及其后续指令</p><p>已经改变</p><p>了 MDU 的状态，则无需恢复。假设 CP0 在 M 级，MDU 在 E 级，考虑以下情况：</p><ul><li><code>mult</code> 在 E 级启动了乘法运算，流水到 M 级时产生了中断，此时无需停止乘法计算，其它乘除法指令同理。</li><li><code>mthi</code> 在 E 级修改了 HI 寄存器，流水到 M 级时产生了中断，此时无需恢复 HI 寄存器的值，<code>mtlo</code> 同理。</li><li><code>mult</code> 在 E 级，受害指令在 M 级，此时还未改变 MDU 状态，不应开始乘法计算，其它乘除法指令同理。</li><li><code>mthi</code> 在 E 级，受害指令在 M 级，此时还未改变 MDU 状态，不应修改 HI 寄存器的值，<code>mtlo</code> 同理。</li></ul></li></ul></li><li><p>中断规范：</p><ul><li>Timer0 输出的中断信号接入 HWInt[0] (最低中断位)，Timer1 输出的中断信号接入 HWInt[1]，来自中断发生器的中断信号接入 HWInt[2]。</li><li>规定中断产生时的受害指令为宏观 PC 对应的指令，此时应将宏观 PC 写入 EPC。</li></ul></li><li><p>MIPS 微系统需要支持的异常：</p><p>| ExcCode | 助记符  | 描述                                             |<br>| :——— | :——— | :———————————————————————- |<br>| 0       | Int     | 中断。                                           |<br>| 4       | AdEL    | 取数或取指时地址错误。                           |<br>| 5       | AdES    | 存数时地址错误。                                 |<br>| 8       | Syscall | 系统调用。                                       |<br>| 10      | RI      | 不认识的（或者非法的）指令码。                   |<br>| 12      | Ov      | 自陷形式的整数算术指令（例如 <code>add</code>）导致的溢出。 |</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">异常与中断码</th><th style="text-align:left">助记符与名称</th><th style="text-align:left">指令与指令类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left"><code>Int</code> （外部中断）</td><td style="text-align:left">所有指令</td><td style="text-align:left">中断请求，来源于计时器与外部中断。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><code>AdEL</code> （取指异常）</td><td style="text-align:left">所有指令</td><td style="text-align:left">PC 地址未字对齐。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">PC 地址超过 <code>0x3000 ~ 0x6ffc</code>。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>AdEL</code> （取数异常）</td><td style="text-align:left"><code>lw</code></td><td style="text-align:left">取数地址未与 4 字节对齐。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"><code>lh</code></td><td style="text-align:left">取数地址未与 2 字节对齐。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"><code>lh</code>, <code>lb</code></td><td style="text-align:left">取 Timer 寄存器的值。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">load 型指令</td><td style="text-align:left">计算地址时加法溢出。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">load 型指令</td><td style="text-align:left">取数地址超出 DM、Timer0、Timer1、中断发生器的范围。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><code>AdES</code> （存数异常）</td><td style="text-align:left"><code>sw</code></td><td style="text-align:left">存数地址未 4 字节对齐。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"><code>sh</code></td><td style="text-align:left">存数地址未 2 字节对齐。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"><code>sh</code>, <code>sb</code></td><td style="text-align:left">存 Timer 寄存器的值。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">store 型指令</td><td style="text-align:left">计算地址加法溢出。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">store 型指令</td><td style="text-align:left">向计时器的 Count 寄存器存值。</td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left">store 型指令</td><td style="text-align:left">存数地址超出 DM、Timer0、Timer1、中断发生器的范围。</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><code>Syscall</code> （系统调用）</td><td style="text-align:left"><code>syscall</code></td><td style="text-align:left">系统调用。</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><code>RI</code>（未知指令）</td><td style="text-align:left"></td><td style="text-align:left">未知的指令码。</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><code>Ov</code>（溢出异常）</td><td style="text-align:left"><code>add</code>, <code>addi</code>, <code>sub</code></td><td style="text-align:left">算术溢出。</td></tr></tbody></table></div><h3 id="4-eret指令"><a href="#4-eret指令" class="headerlink" title="4.eret指令"></a>4.eret指令</h3><p>eret 将保存在 CP0 的 EPC 寄存器中的现场(被中断指令的下一条地址)写入 PC，从而实现从中断、 异常或指令执行错误的处理程序中返回</p><h2 id="3-思考题"><a href="#3-思考题" class="headerlink" title="3.思考题"></a>3.思考题</h2><h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h3><p>1、请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？</p><p>2、请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）</p><p>3、为何与外设通信需要 Bridge？</p><p>4、请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。</p><p>5、倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？</p><p>6、为什么 <code>jalr</code> 指令为什么不能写成 <code>jalr $31, $31</code>？</p><h3 id="2-答案"><a href="#2-答案" class="headerlink" title="2.答案"></a>2.答案</h3><ol><li><p>鼠标和键盘的输入信号是通过它们的接口（例如 USB）发送给计算机的主板。主板上的输入/输出控制器会将这些信号转换成数字信号，然后发送给中央处理器（CPU）。CPU会解析这些信号并根据用户的操作来执行相应的指令。IO设备的输入输出有好几种方式，键盘、鼠标这类的低速设备是通过中断请求的方式进行IO操作的。即当键盘上按下一个按键的时候，键盘会发出一个中断信号，中断信号经过中断控制器传到CPU，然后CPU根据不同的中断号执行不同的中断响应程序，然后进行相应的IO操作，把按下的按键编码读到寄存器（或者鼠标的操作），最后放入内存中。</p></li><li><p>保证设计的统一性，即通过协议保证接口更加兼容。用户使用自定义处理可能出现不兼容的问题</p></li><li><p>正如教程所说，系统桥是连接 CPU 和外设的功能设备，它会给 CPU 提供一种接口，使得 CPU 可以像读写普通存储器一样（即按地址读写）来读写复杂多变的外设，不用管数据是从哪来，怎么来，只用发挥CPU本身功能就可以。系统桥统一且简化了 CPU 的对外接口，CPU 不必为每种外设单独提供接口，符合高内聚，低耦合的设计思想。</p></li><li><p>模式0通常用于产生定时中断  ,当计数器倒计数为 0 后，计数器停止计数，Ctrl 寄存器的计数使能自动变为 0，并且中断信号始终保持有效，直到屏蔽中断或重新开始计数。</p><p><img src="mode0.jpg" alt="mode0"></p><p>模式1当计数器倒计数为 0 后， 初值寄存器值被自动加载至计数器， 计数器继续倒计数。模式 1 通常用于产生周期性脉冲</p><p><img src="mode1.jpg" alt="mode1"></p></li><li><p>会导致宏观PC突然为0或者为x。在清空流水线的时候，应该保留PC信息。</p></li><li><p>PC &lt;- GPR[rs]和GPR[rd] &lt;- PC + 4的进行顺序未知，存在二义</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成CO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAA_CO_P5和P6CPU设计文稿</title>
    <link href="/2024/01/01/BUAA-CO-P5%E5%92%8CP6CPU%E8%AE%BE%E8%AE%A1%E6%96%87%E7%A8%BF/"/>
    <url>/2024/01/01/BUAA-CO-P5%E5%92%8CP6CPU%E8%AE%BE%E8%AE%A1%E6%96%87%E7%A8%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="P5——CPU设计文稿"><a href="#P5——CPU设计文稿" class="headerlink" title="P5——CPU设计文稿"></a>P5——CPU设计文稿</h1><h2 id="1-总示意图"><a href="#1-总示意图" class="headerlink" title="1.总示意图"></a>1.总示意图</h2><p><img src="p5cpu.jpg" alt="p5CPU"></p><h2 id="2-命名规范"><a href="#2-命名规范" class="headerlink" title="2.命名规范"></a>2.命名规范</h2><p>1.模块以及接口加上各级前缀</p><p>2.属于某模块在级后面在加模块名</p><h2 id="3-模块定义"><a href="#3-模块定义" class="headerlink" title="3.模块定义"></a>3.模块定义</h2><h3 id="1）Datapath"><a href="#1）Datapath" class="headerlink" title="1）Datapath"></a>1）Datapath</h3><h4 id="1、E-ALU模块"><a href="#1、E-ALU模块" class="headerlink" title="1、E_ALU模块"></a>1、E_ALU模块</h4><p>同指导书，改为case来操作</p><div class="table-container"><table><thead><tr><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">E_ALU_A [31 : 0]</td><td style="text-align:center">I</td><td style="text-align:left">32位输入信号</td></tr><tr><td style="text-align:center">E_ALU_B [31 : 0]</td><td style="text-align:center">I</td><td style="text-align:left">32位输入信号</td></tr><tr><td style="text-align:center">E_ALU_Shamt [4 : 0]</td><td style="text-align:center">I</td><td style="text-align:left">五位输入信号</td></tr><tr><td style="text-align:center">E_ALUop [2 : 0]</td><td style="text-align:center">I</td><td style="text-align:left">操作选择控制    <br>E_ALUop == 3’b000 A +B；<br>E_ALUop == 3’b001 A - B;<br>E_ALUop == 3’b010 A \</td><td>B; <br>E_ALUop == 3’b011 A &amp; B;<br>E_ALUop == 3’b100 B左移Shamt位<br>E_ALUop == 3’b101 B加载到高位</td></tr><tr><td style="text-align:center">E_ALU_Result [31 : 0]</td><td style="text-align:center">O</td><td style="text-align:left">32位输出信号</td></tr></tbody></table></div><h4 id="2、D-CMP模块"><a href="#2、D-CMP模块" class="headerlink" title="2、D_CMP模块"></a>2、D_CMP模块</h4><p>从原来的ALU模块分离出来到译码阶段</p><div class="table-container"><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>D_CMP_A [31: 0]</td><td>I</td><td>32位输入</td></tr><tr><td>D_CMP_B [31: 0]</td><td>I</td><td>32位输入</td></tr><tr><td>D_CMP_Equal</td><td>O</td><td>相等 ？ 1  ：0</td></tr><tr><td>D_CMP_Less</td><td>O</td><td>小于 ？ 1  ：0</td></tr><tr><td>D_CMP_Greater</td><td>O</td><td>大于 ？ 1 ： 0</td></tr></tbody></table></div><h4 id="3、E-EXT模块"><a href="#3、E-EXT模块" class="headerlink" title="3、E_EXT模块"></a>3、E_EXT模块</h4><div class="table-container"><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>D_EXT_Imm [15: 0 ]</td><td>I</td><td>16位待扩展立即数</td></tr><tr><td>D_EXTop [1:0]</td><td>I</td><td>扩展选择<br>D_EXTop == 2’b00 符号扩展<br>D_EXTop == 2’b01 无符号扩展</td></tr><tr><td>D_EXT_Result [31:0]</td><td>O</td><td>扩展结果</td></tr></tbody></table></div><h4 id="4、F-PC模块"><a href="#4、F-PC模块" class="headerlink" title="4、F_PC模块"></a>4、F_PC模块</h4><div class="table-container"><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>F_PC_clk</td><td>I</td><td>时钟信号</td></tr><tr><td>F_PC_reset</td><td>I</td><td>复位信号</td></tr><tr><td>F_PC_en</td><td>I</td><td>使能信号</td></tr><tr><td>F_PC_ NPC [31:0]</td><td>I</td><td>32位输入信号</td></tr><tr><td>F_PC_PC [31:0]</td><td>O</td><td>输出信号</td></tr></tbody></table></div><h4 id="5、F-IM模块"><a href="#5、F-IM模块" class="headerlink" title="5、F_IM模块"></a>5、F_IM模块</h4><div class="table-container"><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>F_IM_PC [31:0]</td><td>I</td><td>32位取址信号</td></tr><tr><td>F_IM_Instr [31 :0]</td><td>O</td><td>32位结果</td></tr></tbody></table></div><h4 id="6、D-NPC模块"><a href="#6、D-NPC模块" class="headerlink" title="6、D_NPC模块"></a>6、D_NPC模块</h4><div class="table-container"><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>D_NPC_PC[31:0]</td><td>I</td><td>32位PC信号</td></tr><tr><td>D_NPC_Imm[26:0]</td><td>I</td><td>26位立即数地址</td></tr><tr><td>D_NPC_RA[31:0]</td><td>I</td><td>$RA</td></tr><tr><td>D_NPC_Branch[2 :0]</td><td>I</td><td>对应不同Branch<br>3’b000表示不是Branch<br>若为3’b001对应beq</td></tr><tr><td>D_NPC_J</td><td>I</td><td>对应J跳转指令</td></tr><tr><td>D_NPC_JR</td><td>I</td><td>对应Jr跳转指令</td></tr><tr><td>D_NPC_Equal</td><td>I</td><td>比较结果</td></tr><tr><td>D_NPC_Great</td><td>I</td><td>比较结果</td></tr><tr><td>D_NPC_Less</td><td>I</td><td>比较结果</td></tr><tr><td>D_NPC_NPC[31:0]</td><td>O</td><td></td></tr><tr><td>D_Jump</td><td>O</td><td>判断地址是否跳转</td></tr></tbody></table></div><h4 id="7、D-GRF模块"><a href="#7、D-GRF模块" class="headerlink" title="7、D_GRF模块"></a>7、D_GRF模块</h4><div class="table-container"><table><thead><tr><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">D_GRF_A1 [4:0]</td><td style="text-align:center">I</td><td style="text-align:left">5位地址输入信号，输入rs指定的寄存器并将其结果读出到RD1</td></tr><tr><td style="text-align:center">D_GRF_A2 [4:0]</td><td style="text-align:center">I</td><td style="text-align:left">5位地址输入信号，输入rt指定的寄存器并将其结果读出到RD2</td></tr><tr><td style="text-align:center">D_GRF_A3 [4:0]</td><td style="text-align:center">I</td><td style="text-align:left">5位地址输入信号，输入rd指定的寄存器并将WD写入</td></tr><tr><td style="text-align:center">D_GRF_WD [31:0]</td><td style="text-align:center">I</td><td style="text-align:left">32位输入信号</td></tr><tr><td style="text-align:center">D_GRF_clk</td><td style="text-align:center">I</td><td style="text-align:left">时钟信号</td></tr><tr><td style="text-align:center">D_GRF_reset</td><td style="text-align:center">I</td><td style="text-align:left">异步复位信号</td></tr><tr><td style="text-align:center">D_GRF_WE</td><td style="text-align:center">I</td><td style="text-align:left">使能信号</td></tr><tr><td style="text-align:center">D_GRF_RD1 [31:0]</td><td style="text-align:center">O</td><td style="text-align:left">输出A1指定寄存器的32位数据</td></tr><tr><td style="text-align:center">D_GRF_RD2 [31:0]</td><td style="text-align:center">O</td><td style="text-align:left">输出A2指定寄存器的32位数据</td></tr></tbody></table></div><h4 id="8、M-DM模块"><a href="#8、M-DM模块" class="headerlink" title="8、M_DM模块"></a>8、M_DM模块</h4><div class="table-container"><table><thead><tr><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">M_DM_clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">M_DM_reset</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">M_Mem_Write</td><td style="text-align:center">I</td><td style="text-align:center">写信号</td></tr><tr><td style="text-align:center">M_signed</td><td style="text-align:center">I</td><td style="text-align:center">输出是否符号位扩展信号</td></tr><tr><td style="text-align:center">Size</td><td style="text-align:center">I</td><td style="text-align:center">决定是字、半字、字节</td></tr><tr><td style="text-align:center">M_ALU_Result[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">储存地址</td></tr><tr><td style="text-align:center">M_WriteData[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">储存数据</td></tr><tr><td style="text-align:center">M_PC[31:0]]</td><td style="text-align:center">I</td><td style="text-align:center">PC</td></tr><tr><td style="text-align:center">M_Read_Data</td><td style="text-align:center">O</td><td style="text-align:center">load结果</td></tr></tbody></table></div><h4 id="9、Controller"><a href="#9、Controller" class="headerlink" title="9、Controller"></a>9、Controller</h4><p>根据名称要求更改，采取重构</p><div class="table-container"><table><thead><tr><th style="text-align:center">信号名</th><th style="text-align:center">方向</th></tr></thead><tbody><tr><td style="text-align:center">opcode[5:0]</td><td style="text-align:center">I</td></tr><tr><td style="text-align:center">funct[5:0]</td><td style="text-align:center">I</td></tr><tr><td style="text-align:center">D_EXTop [1:0]</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">D_NPC_Branch [2:0]</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">D_NPC_J</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">D_NPC_JR</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">E_Reg_Dst [1:0]</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">E_ALU_Src [1:0]</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">E_ALUop [2:0]</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">M_Mem_Write</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">M_DM_Size[1:0]</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">M_Signed</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">W_MemtoReg [1:0]</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">W_RegWrite</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">D_Rs_Tuse</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">D_Rt_Tuse</td><td style="text-align:center">O</td></tr><tr><td style="text-align:center">D_Tnew</td><td style="text-align:center">O</td></tr></tbody></table></div><p>其真值表对应如下，同时改为case结构，代码长度显著增加，但便于debug</p><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th>D_EXTop[1:0]</th><th>D_NPC_Branch[2:0]</th><th>D_NPC_J</th><th>D_NPC_JR</th><th>D_Reg_Dst[1:0]</th><th>E_ALU_Src[1:0]</th><th>E_ALUop[2:0]</th><th>M_Mem_Write</th><th>M_DM_Size[1:0]</th><th>M_signed</th><th>W_MemtoReg[1:0]</th><th>W_RegWrite</th></tr></thead><tbody><tr><td style="text-align:center">Add</td><td>00</td><td>000</td><td>0</td><td>0</td><td>01</td><td>00</td><td>000</td><td>0</td><td>00</td><td>0</td><td>01</td><td>1</td></tr><tr><td style="text-align:center">Sub</td><td>00</td><td>000</td><td>0</td><td>0</td><td>01</td><td>00</td><td>001</td><td>0</td><td>00</td><td>0</td><td>01</td><td>1</td></tr><tr><td style="text-align:center">Jr</td><td>00</td><td>000</td><td>0</td><td>1</td><td>00</td><td>00</td><td>000</td><td>0</td><td>00</td><td>0</td><td>00</td><td>0</td></tr><tr><td style="text-align:center">Ori</td><td>01</td><td>000</td><td>0</td><td>0</td><td>00</td><td>01</td><td>010</td><td>0</td><td>00</td><td>0</td><td>01</td><td>1</td></tr><tr><td style="text-align:center">Lw</td><td>00</td><td>000</td><td>0</td><td>0</td><td>00</td><td>01</td><td>000</td><td>0</td><td>00</td><td>0</td><td>00</td><td>1</td></tr><tr><td style="text-align:center">Sw</td><td>00</td><td>000</td><td>0</td><td>0</td><td>00</td><td>01</td><td>000</td><td>1</td><td>00</td><td>0</td><td>00</td><td>0</td></tr><tr><td style="text-align:center">Beq</td><td>00</td><td>001</td><td>0</td><td>0</td><td>00</td><td>00</td><td>000</td><td>0</td><td>00</td><td>0</td><td>00</td><td>0</td></tr><tr><td style="text-align:center">Lui</td><td>00</td><td>000</td><td>0</td><td>0</td><td>00</td><td>01</td><td>101</td><td>0</td><td>00</td><td>0</td><td>01</td><td>1</td></tr><tr><td style="text-align:center">J</td><td>00</td><td>000</td><td>1</td><td>0</td><td>00</td><td>00</td><td>00</td><td>0</td><td>00</td><td>0</td><td>00</td><td>0</td></tr><tr><td style="text-align:center">Jal</td><td>00</td><td>000</td><td>1</td><td>0</td><td>10</td><td>01</td><td>000</td><td>0</td><td>00</td><td>0</td><td>10</td><td>1</td></tr></tbody></table></div><h3 id="2）RiskUnit-冒险处理"><a href="#2）RiskUnit-冒险处理" class="headerlink" title="2）RiskUnit 冒险处理"></a>2）RiskUnit 冒险处理</h3><p>D_Tuse与D_Tnew表格，每次走过一个寄存器，T_new都会减一</p><p>Tuse&lt;Tnew 暂停</p><p>对不需要使用寄存器的Tuse置最大值。</p><p>注意：不转发0</p><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">D_Rs_Tuse</th><th style="text-align:center">D_Rt_Tuse</th><th style="text-align:center">D_Tnew</th></tr></thead><tbody><tr><td style="text-align:center">Add</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Sub</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Jr</td><td style="text-align:center">0</td><td style="text-align:center">M</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Ori</td><td style="text-align:center">1</td><td style="text-align:center">M</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">Lw</td><td style="text-align:center">1</td><td style="text-align:center">M</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">Sw</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Beq</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Lui</td><td style="text-align:center">M</td><td style="text-align:center">M</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">J</td><td style="text-align:center">M</td><td style="text-align:center">M</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Jal</td><td style="text-align:center">M</td><td style="text-align:center">M</td><td style="text-align:center">2</td></tr></tbody></table></div><h2 id="4-测试数据"><a href="#4-测试数据" class="headerlink" title="4.测试数据"></a>4.测试数据</h2><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-string">`0x0000000000000000:  34 1C 00 00    ori <span class="hljs-variable">$gp</span>, <span class="hljs-variable">$zero</span>, 0`</span> <br><br><span class="hljs-string">`0x0000000000000004:  34 1D 00 00    ori <span class="hljs-variable">$sp</span>, <span class="hljs-variable">$zero</span>, 0`</span> <br><br><span class="hljs-string">`0x0000000000000008:  34 01 10 10    ori <span class="hljs-variable">$at</span>, <span class="hljs-variable">$zero</span>, 0x1010`</span> <br><br><span class="hljs-string">`0x000000000000000c:  3C 02 87 23    lui <span class="hljs-variable">$v0</span>, 0x8723`</span> <br><br><span class="hljs-string">`0x0000000000000010:  34 03 78 56    ori <span class="hljs-variable">$v1</span>, <span class="hljs-variable">$zero</span>, 0x7856`</span> <br><br><span class="hljs-string">`0x0000000000000014:  3C 04 85 FF    lui <span class="hljs-variable">$a0</span>, 0x85ff`</span> <br><br><span class="hljs-string">`0x0000000000000018:  34 05 00 01    ori <span class="hljs-variable">$a1</span>, <span class="hljs-variable">$zero</span>, 1`</span> <br><br><span class="hljs-string">`0x000000000000001c:  3C 06 FF FF    lui <span class="hljs-variable">$a2</span>, 0xffff`</span> <br><br><span class="hljs-string">`0x0000000000000020:  34 07 FF FF    ori <span class="hljs-variable">$a3</span>, <span class="hljs-variable">$zero</span>, 0xffff`</span> <br><br><span class="hljs-string">`0x0000000000000024:  00 22 08 20    add <span class="hljs-variable">$at</span>, <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v0</span>`</span> <br><br><span class="hljs-string">`0x0000000000000028:  00 23 48 20    add <span class="hljs-variable">$t1</span>, <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v1</span>`</span> <br><br><span class="hljs-string">`0x000000000000002c:  00 22 40 22    sub <span class="hljs-variable">$t0</span>, <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v0</span>`</span> <br><br><span class="hljs-string">`0x0000000000000030:  00 E0 00 22    sub <span class="hljs-variable">$zero</span>, <span class="hljs-variable">$a3</span>, <span class="hljs-variable">$zero</span>`</span> <br><br><span class="hljs-string">`0x0000000000000034:  13 91 00 03    beq <span class="hljs-variable">$gp</span>, <span class="hljs-variable">$s1</span>, 0x44`</span> <br><br><span class="hljs-string">`0x0000000000000038:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x000000000000003c:  10 00 00 15    b   0x94`</span> <br><br><span class="hljs-string">`0x0000000000000040:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x0000000000000044:  10 22 00 13    beq <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v0</span>, 0x94`</span> <br><br><span class="hljs-string">`0x0000000000000048:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x000000000000004c:  34 02 00 0C    ori <span class="hljs-variable">$v0</span>, <span class="hljs-variable">$zero</span>, 0xc`</span> <br><br><span class="hljs-string">`0x0000000000000050:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x0000000000000054:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x0000000000000058:  00 00 00 00    nop`</span> <br><br><span class="hljs-string">`0x000000000000005c:  0C 00 0C 1B    jal 0x306c`</span> <br><br><span class="hljs-string">`0x0000000000000060:  AC 41 00 00    sw  <span class="hljs-variable">$at</span>, (<span class="hljs-variable">$v0</span>)`</span> <br><br><span class="hljs-string">`0x0000000000000064:  10 00 00 0B    b   0x94`</span> <br><br><span class="hljs-string">`0x0000000000000068:  00 22 08 20    add <span class="hljs-variable">$at</span>, <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v0</span>`</span> <br><br><span class="hljs-string">`0x000000000000006c:  00 22 08 20    add <span class="hljs-variable">$at</span>, <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v0</span>`</span> <br><br><span class="hljs-string">`0x0000000000000070:  00 22 08 20    add <span class="hljs-variable">$at</span>, <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v0</span>`</span><br><br> <span class="hljs-string">`0x0000000000000074:  00 22 08 20    add <span class="hljs-variable">$at</span>, <span class="hljs-variable">$at</span>, <span class="hljs-variable">$v0</span>`</span> <br><br><span class="hljs-string">`0x0000000000000078:  AC 5F 00 00    sw  <span class="hljs-variable">$ra</span>, (<span class="hljs-variable">$v0</span>)`</span> <br><br><span class="hljs-string">`0x000000000000007c:  8C 41 00 00    lw  <span class="hljs-variable">$at</span>, (<span class="hljs-variable">$v0</span>)`</span> <br><br><span class="hljs-string">`0x0000000000000080:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x0000000000000084:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x0000000000000088:  00 00 00 00    nop`</span>  <br><br><span class="hljs-string">`0x000000000000008c:  00 20 00 08    jr  <span class="hljs-variable">$at</span>`</span> <br><br><span class="hljs-string">`0x0000000000000090:  AC 5F 00 00    sw  <span class="hljs-variable">$ra</span>, (<span class="hljs-variable">$v0</span>)`</span> <br><br><span class="hljs-string">`0x0000000000000094:  10 00 FF FF    b   0x94`</span> <br><br><span class="hljs-string">`0x0000000000000098:  00 00 00 00    nop`</span> <br></code></pre></td></tr></table></figure><h2 id="5-思考题"><a href="#5-思考题" class="headerlink" title="5.思考题"></a>5.思考题</h2><p>1.在D级就直接就直接计算出是否需要跳转，若需要发生跳转，由于NPC是组合逻辑，下一条指令的地址直接传出到PC模块，这样只会多读跳转指令下一条的指令，即使将分支判断提到 D 级，发生跳转的时候，F 级指令依然是需要作废的。但是我们如果约定 F 级指令不作废呢？也就是说，不论判断结果如何，我们都将执行分支或跳转指令的下一条指令。这也就是所谓的“<strong>延迟槽</strong>”。那么指令执行的效率就提高了。</p><p>2.Jal需要将jal下一条指令的位置写入$ra寄存器，由于延迟槽的地址是PC+4，所以实际应该写回PC +8了。</p><p>3.流水线中的各个阶段需要在特定的时钟周期内完成其任务。如果数据来自功能部件，可能会增加流水线的复杂性，导致更难以保持稳定的时序。通过限制数据转发只能来自寄存器，可以简化流水线的设计，提高稳定性。</p><p>4.当前 GPR 被写入的值会即时反馈到读取端上。具体的说，当读寄存器时的地址与同周期写寄存器的地址相同时，我们将读取的内容改为写寄存器的内容，而不是该地址可以索引到的寄存器文件中的值。这也就对应着图中的两个四选一多路选择器。利用冲突单元生成选择信号即可</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">assign</span> D_ForwardA = <br>    (D_Rs == M_Write_Reg &amp;&amp; M_MemtoReg == <span class="hljs-number">2&#x27;b01</span> &amp;&amp; M_Reg_Write == <span class="hljs-number">1&#x27;b1</span> &amp;&amp; M_Write_Reg != <span class="hljs-number">5&#x27;b00000</span>) ? `M_Data_ALU :<br>    (D_Rs == M_Write_Reg &amp;&amp; M_MemtoReg == <span class="hljs-number">2&#x27;b10</span> &amp;&amp; M_Reg_Write == <span class="hljs-number">1&#x27;b1</span> &amp;&amp; M_Write_Reg != <span class="hljs-number">5&#x27;b00000</span>) ? `M_Data_PC8 :<br>    (D_Rs == W_Write_Reg &amp;&amp; W_Reg_Write == <span class="hljs-number">1&#x27;b1</span>  &amp;&amp; W_Write_Reg != <span class="hljs-number">5&#x27;b00000</span>) ? `W_Data :<br>                                                `D_Data ;<br></code></pre></td></tr></table></figure><p>5.需求者：D级：CMP，E级：ALU</p><p>​    提供者：M级：ALU_Result,PC8</p><p>​                    W级：因为已经被选择过，过Writeback_Data就已经可以满足需求</p><p>6.大致可将指令分为三类</p><p>​    1）计算指令，主要对ALU模块进行增加操作，如Add指令</p><p>​    2）跳转指令，可能需要调整ALU模块或者NPC，由于这里是流水线，ALU模块的输出不能直接和单周期一样课上直接连在NPC模块，可能需要考虑在增加D级就增加符合跳转的运算</p><p>​    3）访存指令，DM中已经支持字、半字、字节的存取，根据题意做ALU，NPC等对应的增添即可</p><p>7.采取分散式译码</p><p>译码结果较易观察，且不容易产生bug，不同指令之间完全分离，缺点就是代码冗长。</p><p>选做2，采取交叉式出现</p><h1 id="P6——CPU"><a href="#P6——CPU" class="headerlink" title="P6——CPU"></a>P6——CPU</h1><p>支持指令：<strong>add,</strong> <strong>sub,</strong> <strong>and,</strong> <strong>or,</strong> <strong>slt,</strong> <strong>sltu,</strong> <strong>lui</strong> <strong>addi,</strong> <strong>andi,</strong> <strong>ori</strong> <strong>lb,</strong> <strong>lh,</strong> <strong>lw,</strong> <strong>sb,</strong> <strong>sh,</strong> <strong>sw</strong> <strong>mult,</strong> <strong>multu,</strong> <strong>div,</strong> <strong>divu,</strong> <strong>mfhi,</strong> <strong>mflo,</strong> <strong>mthi,</strong> <strong>mtlo</strong> <strong>beq,</strong> <strong>bne,</strong> <strong>jal,</strong> <strong>jr</strong></p><h2 id="1-模块定义"><a href="#1-模块定义" class="headerlink" title="1.模块定义"></a>1.模块定义</h2><p>增加E_MUDI乘除模块与M_DE模块，删除看F_IM与M_DM模块</p><h4 id="1、M-BE"><a href="#1、M-BE" class="headerlink" title="1、M_BE"></a>1、M_BE</h4><div class="table-container"><table><thead><tr><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">M_BE_A[1:0]</td><td style="text-align:center">I</td><td style="text-align:left">最低两位的地址</td></tr><tr><td style="text-align:center">M_BE_Din[31:0]</td><td style="text-align:center">I</td><td style="text-align:left">输入的 32 位数据</td></tr><tr><td style="text-align:center">M_BE_Op[2:0]</td><td style="text-align:center">I</td><td style="text-align:left">数据扩展控制码 000：<br>无扩展 001：无符号字节数据扩展 <br>010：符号字节数据扩展 <br>011：无符号半字数据扩展 <br>100：符号半字数据扩展</td></tr><tr><td style="text-align:center">M_BE_Dout[31:0]</td><td style="text-align:center">O</td><td style="text-align:left">扩展后的 32 位数据</td></tr></tbody></table></div><h4 id="2、E-MUDI"><a href="#2、E-MUDI" class="headerlink" title="2、E_MUDI"></a>2、E_MUDI</h4><div class="table-container"><table><thead><tr><th>信号名</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>E_MUDI_clk</td><td>I</td><td>时钟信号</td></tr><tr><td>E_MUDI_reset</td><td>I</td><td>复位信号</td></tr><tr><td>E_MUDI_A [31:0]</td><td>I</td><td>运算数据A</td></tr><tr><td>E_MUDI_B [31:0]</td><td>I</td><td>运算数据B</td></tr><tr><td>E_MUDI_Start</td><td>I</td><td>开始计算信号</td></tr><tr><td>E_MUDI_op [2:0]</td><td>I</td><td>运算选择信号</td></tr><tr><td>E_HI_Write</td><td>I</td><td>高位写信号</td></tr><tr><td>E_LO_Write</td><td>I</td><td>地位写信号</td></tr><tr><td>E_HI [31:0]</td><td>O</td><td>高位寄存器输出结果</td></tr><tr><td>E_LO[31:0]</td><td>O</td><td>低位寄存器输出结果</td></tr><tr><td>E_MUDI_Busy</td><td>O</td><td>计算中信号</td></tr></tbody></table></div><h2 id="2-总示意图"><a href="#2-总示意图" class="headerlink" title="2.总示意图"></a>2.总示意图</h2><p><img src="p6cpu.jpg" alt="p6CPU"></p><h2 id="3-思考题"><a href="#3-思考题" class="headerlink" title="3.思考题"></a>3.思考题</h2><p>1.乘除法运算效率远低于ALU内的各个计算，需要耗费大量时间，放在一起会大大拖慢效率，独立的HI、LO也是为了高效率，因为只有乘除法会用到高位寄存器，低位寄存器，与其他不一致，分开便于控制。</p><p>2.真实的流水线 CPU 使用乘法和除法指令来实现乘除法运算。在执行乘法和除法指令时，CPU会将操作数加载到寄存器中，然后通过一系列的算术逻辑单元(ALU)来进行乘法或除法计算。这些计算通常会在多个时钟周期内完成，因为乘法和除法是比较复杂的运算。乘法：乘法可以通过一系列的加法和移位来实现。处理器中的乘法单元通常包括：部分积生成器（Partial Product Generator）：将两个乘数的每一位相乘，生成部分积。部分积累加器（Partial Product Accumulator）： 将所有部分积相加，得到最终的乘积。这个过程可能需要多个时钟周期，因此在流水线中可能会有多个阶段用于处理不同的部分。除法：除法通常比乘法更为复杂，可能涉及到迭代的过程。处理器中的除法单元通常包括：部分商生成器（Partial Quotient Generator）： 生成每一位的部分商。部分商累加器（Partial Quotient Accumulator）： 将所有部分商相加，得到最终的商。这个过程同样可能需要多个时钟周期，并且可能需要进行多轮迭代来得到最终的结果。</p><p>在流水线中，这些乘法和除法的阶段可能被划分为多个子阶段，以便在每个时钟周期内执行一些部分操作。流水线的设计需要考虑到数据相关性、控制信号的传递以及流水线暂停和刷新等问题，以确保正确且高效地执行指令。</p><p>3.当且仅当Busy且指令为乘除有关的那八条指令时阻塞</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">assign</span> MUDI_Stall = (E_MUDI_Busy == <span class="hljs-number">1&#x27;b1</span>  || E_MUDI_Start == <span class="hljs-number">1&#x27;b1</span>) &amp;&amp; (D_MD_MT_MF == <span class="hljs-number">1&#x27;b1</span>) ? <span class="hljs-number">1&#x27;b1</span> : <span class="hljs-number">1&#x27;b0</span>;<br></code></pre></td></tr></table></figure><p>4.清晰性：每个字节的写分开，互不干扰，统一性：各个字节的控制信号仍然来自m_data_byteen[3:0]</p><p>5.不是，如果只实现按字使能，就不得不先读取值再进行更改，这样数据通路就延长了，导致效率下降。</p><p>6.对于选择信号以及条件尽可能实现宏定义来实现，避免出现6‘b100000这种无缘无故的常数，方便查找bug</p><p>7.连续的乘除有关的那八条指令，同3进行阻塞或者转发实现，测试数据</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">ori </span>$<span class="hljs-built_in">t1</span> $<span class="hljs-built_in">t1</span> <span class="hljs-number">0x1234</span><br><span class="hljs-keyword">mult </span>$<span class="hljs-built_in">t0</span> $<span class="hljs-built_in">t1</span><br><span class="hljs-keyword">mfhi </span>$<span class="hljs-built_in">s0</span><br></code></pre></td></tr></table></figure><p>8.多增加连续的乘除有关的那八条指令，其余同P5构造</p><p><strong>{</strong>temp_hi<strong>,</strong> temp_lo<strong>}</strong> <strong>&lt;=</strong> <strong>{</strong>hi<strong>,</strong> lo<strong>}</strong> <strong>+</strong> $signed<strong>(</strong>$signed<strong>(64’d0</strong>) <strong>+</strong> $signed<strong>(</strong>rs<strong>)</strong> <strong>*</strong> $signed<strong>(</strong>rt<strong>));</strong></p>]]></content>
    
    
    <categories>
      
      <category>BUAA_Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机组成CO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FirstTest</title>
    <link href="/2023/12/15/FirstTest/"/>
    <url>/2023/12/15/FirstTest/</url>
    
    <content type="html"><![CDATA[<hr><p>这是我的第一篇博客，用于记录自己的学习过程。</p><p>下面是我创建过程中的一些tips</p><h6 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo n -p post <span class="hljs-built_in">dir</span>/post1<br></code></pre></td></tr></table></figure><p>通过这个指令会在<code>source/_post/dir</code>目录下创建<code>post1.md</code></p><h6 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h6><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure><p>这个指令启动本地服务器</p><h6 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h6><ul><li><p>删除已有静态文件：<code>hexo clean</code>（为了避免可能的错误）</p></li><li><p>重新生成静态文件：<code>hexo g</code></p></li><li><p>重新部署：<code>hexo d</code>，稍等一段时间后刷新网页，发现主题生效</p><p></p><p align="right">By Fantasylee</p><p></p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Test</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
